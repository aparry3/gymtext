{"version":3,"sources":["../../../../../packages/shared/src/server/connections/messaging/twilioClient.ts","../../../../../packages/shared/src/server/connections/messaging/localClient.ts","../../../../../packages/shared/src/server/connections/messaging/factory.ts","../../../../../packages/shared/src/server/services/messaging/messageService.ts","../../../../../packages/shared/src/server/services/agents/messaging/messagingAgentService.ts"],"sourcesContent":["/**\n * Twilio Messaging Client\n *\n * Implements IMessagingClient for Twilio SMS delivery.\n * Wraps the Twilio API and provides a standardized messaging interface.\n */\n\nimport { twilioClient as twilioSdk } from '../twilio/twilio';\nimport type { IMessagingClient, MessageResult, MessagingProvider } from './types';\nimport type { UserWithProfile } from '@/server/models/user';\n\nexport class TwilioMessagingClient implements IMessagingClient {\n  public readonly provider: MessagingProvider = 'twilio';\n\n  async sendMessage(user: UserWithProfile, message?: string, mediaUrls?: string[]): Promise<MessageResult> {\n    try {\n      const twilioResponse = await twilioSdk.sendSMS(user.phoneNumber, message, mediaUrls);\n\n      return {\n        messageId: twilioResponse.sid,\n        status: this.mapTwilioStatus(twilioResponse.status),\n        provider: this.provider,\n        to: twilioResponse.to,\n        from: twilioResponse.from,\n        timestamp: twilioResponse.dateCreated,\n        metadata: {\n          twilioSid: twilioResponse.sid,\n          twilioStatus: twilioResponse.status,\n          errorCode: twilioResponse.errorCode,\n          errorMessage: twilioResponse.errorMessage,\n          mediaUrls,\n        },\n      };\n    } catch (error) {\n      console.error('TwilioMessagingClient: Failed to send message', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Maps Twilio status to standardized message status\n   */\n  private mapTwilioStatus(\n    twilioStatus: string\n  ): MessageResult['status'] {\n    switch (twilioStatus) {\n      case 'sent':\n      case 'delivered':\n        return 'delivered';\n      case 'queued':\n      case 'accepted':\n      case 'sending':\n        return 'queued';\n      case 'failed':\n      case 'undelivered':\n        return 'failed';\n      default:\n        return 'sent';\n    }\n  }\n}\n\n// Export singleton instance\nexport const twilioMessagingClient = new TwilioMessagingClient();\n","/**\n * Local Messaging Client\n *\n * Implements IMessagingClient for local development and testing.\n * Uses EventEmitter to broadcast messages to connected SSE clients.\n * Does not actually send SMS - instead emits events for local consumption.\n */\n\nimport { EventEmitter } from 'events';\nimport type { IMessagingClient, MessageResult, MessagingProvider } from './types';\nimport type { UserWithProfile } from '@/server/models/user';\n\nexport interface LocalMessage {\n  messageId: string;\n  to: string;\n  from: string;\n  content: string;\n  timestamp: Date;\n}\n\nexport class LocalMessagingClient implements IMessagingClient {\n  public readonly provider: MessagingProvider = 'local';\n  private eventEmitter: EventEmitter;\n  private messageCounter = 0;\n\n  constructor() {\n    this.eventEmitter = new EventEmitter();\n    // Increase max listeners for SSE connections\n    this.eventEmitter.setMaxListeners(100);\n  }\n\n  async sendMessage(user: UserWithProfile, message?: string, mediaUrls?: string[]): Promise<MessageResult> {\n    const messageId = `local-${Date.now()}-${++this.messageCounter}`;\n    const timestamp = new Date();\n    const to = user.phoneNumber;\n\n    const localMessage: LocalMessage = {\n      messageId,\n      to,\n      from: 'local-system',\n      content: message || '[MMS only - no text]',\n      timestamp,\n    };\n\n    // Emit the message event for SSE listeners\n    this.eventEmitter.emit('message', localMessage);\n\n    console.log(`[LocalMessagingClient] Message sent (not actual SMS):`, {\n      messageId,\n      to,\n      userId: user.id,\n      preview: message ? message.substring(0, 50) : '[MMS only]',\n      mediaUrls,\n    });\n\n    return {\n      messageId,\n      status: 'sent',\n      provider: this.provider,\n      to,\n      from: 'local-system',\n      timestamp,\n      metadata: {\n        userId: user.id,\n        phoneNumber: to,\n        contentLength: message?.length || 0,\n        mediaUrls,\n      },\n    };\n  }\n\n  /**\n   * Subscribe to message events (for SSE connections)\n   */\n  onMessage(listener: (message: LocalMessage) => void): void {\n    this.eventEmitter.on('message', listener);\n  }\n\n  /**\n   * Unsubscribe from message events\n   */\n  offMessage(listener: (message: LocalMessage) => void): void {\n    this.eventEmitter.off('message', listener);\n  }\n\n  /**\n   * Get current number of active listeners\n   */\n  getListenerCount(): number {\n    return this.eventEmitter.listenerCount('message');\n  }\n}\n\n// Export singleton instance\nexport const localMessagingClient = new LocalMessagingClient();\n","/**\n * Messaging Client Factory\n *\n * Provides a centralized way to get the appropriate messaging client\n * based on environment configuration.\n */\n\nimport type { IMessagingClient, MessagingProvider } from './types';\nimport { twilioMessagingClient } from './twilioClient';\nimport { localMessagingClient } from './localClient';\nimport { getMessagingConfig } from '@/shared/config';\n\n/**\n * Get the messaging client based on environment configuration\n * Defaults to Twilio in production, can be overridden with MESSAGING_PROVIDER env var\n */\nexport function getMessagingClient(): IMessagingClient {\n  const { provider } = getMessagingConfig();\n\n  switch (provider) {\n    case 'local':\n      console.log('[MessagingFactory] Using LocalMessagingClient (no SMS will be sent)');\n      return localMessagingClient;\n    case 'twilio':\n    default:\n      return twilioMessagingClient;\n  }\n}\n\n/**\n * Get a specific messaging client by provider name\n * Useful for testing or when you need direct access to a specific provider\n */\nexport function getMessagingClientByProvider(provider: MessagingProvider): IMessagingClient {\n  switch (provider) {\n    case 'local':\n      return localMessagingClient;\n    case 'twilio':\n      return twilioMessagingClient;\n    default:\n      throw new Error(`Unknown messaging provider: ${provider}`);\n  }\n}\n\n// Export the default client as a singleton\nexport const messagingClient = getMessagingClient();\n","import { UserWithProfile } from '../../models/user';\nimport { FitnessPlan } from '../../models/fitnessPlan';\nimport { messagingClient } from '../../connections/messaging';\nimport { inngest } from '../../connections/inngest/client';\nimport { workoutAgentService } from '../agents/training';\nimport { messagingAgentService } from '../agents/messaging';\nimport { WorkoutInstance, EnhancedWorkoutInstance } from '../../models/workout';\nimport { Message } from '../../models/conversation';\nimport { MessageRepository } from '../../repositories/messageRepository';\nimport { postgresDb } from '../../connections/postgres/postgres';\nimport { CircuitBreaker } from '@/server/utils/circuitBreaker';\nimport { Json } from '../../models/_types';\nimport { UserService } from '../user/userService';\nimport { WorkoutInstanceService } from '../training/workoutInstanceService';\nimport { getTwilioSecrets } from '@/server/config';\n\n/**\n * Parameters for storing an inbound message\n */\nexport interface StoreInboundMessageParams {\n  clientId: string;\n  from: string;\n  to: string;\n  content: string;\n  twilioData?: Record<string, unknown>;\n}\n\n/**\n * Parameters for ingesting an inbound message (async path)\n */\nexport interface IngestMessageParams {\n  /** User receiving the message */\n  user: UserWithProfile;\n  /** Message content */\n  content: string;\n  /** Phone number message is from */\n  from: string;\n  /** Phone number message is to */\n  to: string;\n  /** Optional Twilio webhook data */\n  twilioData?: Record<string, unknown>;\n}\n\n/**\n * Result of ingesting an inbound message\n */\nexport interface IngestMessageResult {\n  /** Inngest job ID for tracking (undefined if no async processing needed) */\n  jobId?: string;\n  /** Quick acknowledgment or full answer message */\n  ackMessage: string;\n  /** Action taken: resendWorkout, fullChatAgent, or null */\n  action: 'resendWorkout' | 'fullChatAgent' | null;\n  /** Reasoning for the decision (for debugging) */\n  reasoning: string;\n}\n\n/**\n * Parameters for receiving an inbound message (sync path)\n */\nexport interface ReceiveMessageParams {\n  /** User receiving the message */\n  user: UserWithProfile;\n  /** Message content */\n  content: string;\n  /** Phone number message is from */\n  from: string;\n  /** Phone number message is to */\n  to: string;\n  /** Optional Twilio webhook data */\n  twilioData?: Record<string, unknown>;\n  /** Optional callback to generate a response */\n  responseGenerator?: (\n    user: UserWithProfile,\n    content: string\n  ) => Promise<string>;\n}\n\n/**\n * Result of receiving an inbound message\n */\nexport interface ReceiveMessageResult {\n  /** The generated response (if responseGenerator was provided) */\n  response?: string;\n  /** Whether the inbound message was stored successfully */\n  inboundStored: boolean;\n  /** Whether the outbound response was stored successfully (if response was generated) */\n  outboundStored?: boolean;\n}\n\n/**\n * MessageService\n *\n * Handles message transport, storage, and flow orchestration.\n * Does NOT handle message content generation - that's for agents/generators.\n *\n * Responsibilities:\n * - Send messages via messaging clients (Twilio, local, etc.)\n * - Receive and store inbound messages\n * - Orchestrate message flow (receive → store → respond)\n * - Store outbound messages\n */\nexport class MessageService {\n  private static instance: MessageService;\n  private messageRepo: MessageRepository;\n  private userService: UserService;\n  private workoutInstanceService: WorkoutInstanceService;\n  private circuitBreaker: CircuitBreaker;\n\n  private constructor() {\n    this.messageRepo = new MessageRepository(postgresDb);\n    this.userService = UserService.getInstance();\n    this.workoutInstanceService = WorkoutInstanceService.getInstance();\n    this.circuitBreaker = new CircuitBreaker({\n      failureThreshold: 5,\n      resetTimeout: 60000, // 1 minute\n      monitoringPeriod: 60000 // 1 minute\n    });\n  }\n\n  public static getInstance(): MessageService {\n    if (!MessageService.instance) {\n      MessageService.instance = new MessageService();\n    }\n    return MessageService.instance;\n  }\n\n  // ==========================================\n  // Message Storage Methods\n  // ==========================================\n\n  /**\n   * Store an inbound message to the database\n   */\n  async storeInboundMessage(params: StoreInboundMessageParams): Promise<Message | null> {\n    return await this.circuitBreaker.execute(async () => {\n      const { clientId, from, to, content, twilioData } = params;\n\n      // Store the message directly (no conversation needed)\n      const message = await this.messageRepo.create({\n        conversationId: null, // No longer using conversations\n        clientId: clientId,\n        direction: 'inbound',\n        content,\n        phoneFrom: from,\n        phoneTo: to,\n        provider: 'twilio', // Inbound messages always come from Twilio webhook\n        providerMessageId: (twilioData?.MessageSid as string) || null,\n        metadata: (twilioData || {}) as Json\n      });\n\n      return message;\n    });\n  }\n\n  /**\n   * Store an outbound message to the database\n   */\n  async storeOutboundMessage(\n    clientId: string,\n    to: string,\n    messageContent: string,\n    from: string = getTwilioSecrets().phoneNumber,\n    provider: 'twilio' | 'local' | 'websocket' = 'twilio',\n    providerMessageId?: string,\n    metadata?: Record<string, unknown>\n  ): Promise<Message | null> {\n    // TODO: Implement periodic message summarization\n    return await this.circuitBreaker.execute(async () => {\n\n      const user = await this.userService.getUser(clientId);\n      if (!user) {\n        return null;\n      }\n\n      // Store the message with initial delivery tracking\n      const message = await this.messageRepo.create({\n        conversationId: null, // No longer using conversations\n        clientId: clientId,\n        direction: 'outbound',\n        content: messageContent,\n        phoneFrom: from,\n        phoneTo: to,\n        provider,\n        providerMessageId: providerMessageId || null,\n        metadata: (metadata || {}) as Json,\n        deliveryStatus: 'queued',\n        deliveryAttempts: 1,\n        lastDeliveryAttemptAt: new Date(),\n      });\n\n      // Optionally summarize messages periodically (implementation TBD)\n      // For now, we'll skip summarization on every message to improve performance\n      // const messages = await this.getRecentMessages(clientId, 50);\n      // const summary = await this.summarizeMessages(user, messages);\n      // Store summary somewhere (TBD - maybe in a separate summaries table)\n\n      return message;\n    });\n  }\n\n  /**\n   * Get messages for a client with pagination support\n   */\n  async getMessages(clientId: string, limit: number = 50, offset: number = 0): Promise<Message[]> {\n    return await this.messageRepo.findByClientId(clientId, limit, offset);\n  }\n\n  /**\n   * Get recent messages for a client\n   *\n   * Convenience method for retrieving the most recent messages for a client.\n   * Useful for passing conversation context to agents.\n   *\n   * @param clientId - The client ID\n   * @param limit - Maximum number of recent messages to return (default: 10)\n   * @returns Array of recent messages, ordered oldest to newest\n   *\n   * @example\n   * ```typescript\n   * // Get last 10 messages for context\n   * const previousMessages = await messageService.getRecentMessages(clientId);\n   * const response = await chatAgent(user, message, previousMessages);\n   * ```\n   */\n  async getRecentMessages(clientId: string, limit: number = 10): Promise<Message[]> {\n    // Get recent messages directly by clientId\n    return await this.messageRepo.findRecentByClientId(clientId, limit);\n  }\n\n  /**\n   * Split messages into pending (to be processed) and context (conversation history).\n   *\n   * Pure function - no DB calls. Used to separate messages that need responses\n   * from messages that serve as conversation context.\n   *\n   * @param messages - Array of messages ordered oldest to newest\n   * @param contextMinutes - Time window in minutes for context messages\n   * @returns Object with pending (ALL inbound after last outbound) and context (messages within time window up to last outbound)\n   */\n  splitMessages(messages: Message[], contextMinutes: number): { pending: Message[]; context: Message[] } {\n    // Calculate time threshold for context messages\n    const cutoffTime = new Date(Date.now() - contextMinutes * 60 * 1000);\n\n    // Find index of last outbound message\n    let lastOutboundIndex = -1;\n    for (let i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].direction === 'outbound') {\n        lastOutboundIndex = i;\n        break;\n      }\n    }\n\n    // Pending: ALL inbound messages after last outbound (no time limit - always include unresponded messages)\n    const pending = lastOutboundIndex >= 0\n      ? messages.slice(lastOutboundIndex + 1)\n      : messages.filter(m => m.direction === 'inbound');\n\n    // Context: Messages up to last outbound, filtered by time window\n    const allContext = lastOutboundIndex >= 0 ? messages.slice(0, lastOutboundIndex + 1) : [];\n    const context = allContext.filter(m => new Date(m.createdAt) >= cutoffTime);\n\n    return { pending, context };\n  }\n\n  /**\n   * Get pending (unanswered) inbound messages for a client\n   *\n   * Retrieves the tail of inbound messages that have occurred since the last outbound message.\n   * Used for batch processing in the debounced chat flow.\n   *\n   * @param clientId - The client ID\n   * @returns Array of pending inbound messages, ordered oldest to newest\n   */\n  async getPendingMessages(clientId: string): Promise<Message[]> {\n    // Get a reasonable batch of recent messages (e.g., last 20)\n    // We assume the user hasn't sent more than 20 messages without a reply\n    const recentMessages = await this.getRecentMessages(clientId, 20);\n\n    const pendingMessages: Message[] = [];\n    \n    // Iterate backwards from the most recent message\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\n      const message = recentMessages[i];\n      \n      // If we hit an outbound message, stop - we've found the break point\n      if (message.direction === 'outbound') {\n        break;\n      }\n      \n      // Collect inbound messages\n      if (message.direction === 'inbound') {\n        pendingMessages.unshift(message); // Add to front to maintain time order\n      }\n    }\n    \n    return pendingMessages;\n  }\n\n\n  // ==========================================\n  // Message Transport & Orchestration Methods\n  // ==========================================\n\n  /**\n   * Ingest an inbound message (async path)\n   *\n   * Fast path for webhook acknowledgment:\n   * 1. Store inbound message\n   * 2. Queue processing job via Inngest\n   * 3. Return success\n   *\n   * @returns IngestMessageResult with optional jobId\n   */\n  public async ingestMessage(params: IngestMessageParams): Promise<IngestMessageResult> {\n    const { user, content, from, to, twilioData } = params;\n\n    // Store the inbound message\n    const storedMessage = await this.storeInboundMessage({\n      clientId: user.id,\n      from,\n      to,\n      content,\n      twilioData\n    });\n\n    if (!storedMessage) {\n      throw new Error('Failed to store inbound message');\n    }\n\n    // Always queue the message processing job via Inngest\n    // The Inngest function handles debouncing and batch processing\n    const { ids } = await inngest.send({\n      name: 'message/received',\n      data: {\n        userId: user.id,\n        content,\n        from,\n        to,\n      },\n    });\n    const jobId = ids[0];\n\n    console.log('[MessageService] Message stored and queued:', {\n      userId: user.id,\n      messageId: storedMessage.id,\n      jobId,\n    });\n\n    // Return simple acknowledgment\n    return {\n      jobId,\n      ackMessage: '', // No immediate reply\n      action: 'fullChatAgent', // Always full agent now\n      reasoning: 'Queued for processing',\n    };\n  }\n\n  /**\n   * Send a message to a user\n   * Stores the message and sends it via the configured messaging client\n   * @param user - User to send message to\n   * @param message - Optional message content (can be undefined for MMS-only messages)\n   * @param mediaUrls - Optional array of media URLs for MMS (images, videos, etc.)\n   * @returns The stored Message object\n   */\n  public async sendMessage(user: UserWithProfile, message?: string, mediaUrls?: string[]): Promise<Message> {\n    // Get the provider from the messaging client\n    const provider = messagingClient.provider;\n\n    let stored: Message | null = null;\n    try {\n        stored = await this.storeOutboundMessage(\n            user.id,\n            user.phoneNumber,\n            message || '[MMS only]', // Store placeholder for MMS-only messages\n            undefined, // from (uses default)\n            provider, // messaging provider\n            undefined,  // providerMessageId (not available yet)\n            mediaUrls ? { mediaUrls } : undefined // store media URLs in metadata\n        );\n        if (!stored) {\n            console.warn('Circuit breaker prevented storing outbound message');\n        }\n        } catch (error) {\n            // Log error but don't block SMS processing\n            console.error('Failed to store outbound message:', error);\n        }\n\n    if (!stored) {\n      throw new Error('Failed to store message');\n    }\n\n    // Send via messaging client and get the result\n    const result = await messagingClient.sendMessage(user, message, mediaUrls);\n\n    // Update the stored message with provider message ID from the send result\n    if (result.messageId) {\n      try {\n        const messageRepo = new MessageRepository(postgresDb);\n        await messageRepo.updateProviderMessageId(stored.id, result.messageId);\n        console.log('[MessageService] Updated message with provider ID:', {\n          messageId: stored.id,\n          providerMessageId: result.messageId,\n        });\n      } catch (error) {\n        console.error('[MessageService] Failed to update provider message ID:', error);\n        // Don't throw - message was sent successfully\n      }\n    }\n\n    // Simulate delivery for local messages (for queue processing)\n    if (provider === 'local') {\n      // Fire-and-forget delivery simulation (non-blocking)\n      this.simulateLocalDelivery(stored.id).catch(error => {\n        console.error('[MessageService] Local delivery simulation failed:', error);\n      });\n    }\n\n    return stored;\n  }\n\n  /**\n   * Simulate message delivery for local development\n   *\n   * Called when using the local messaging client to simulate the Twilio\n   * webhook callback that normally triggers queue processing.\n   *\n   * @param messageId - ID of the message to mark as delivered\n   */\n  private async simulateLocalDelivery(messageId: string): Promise<void> {\n    const delay = 1500; // 1.5 seconds to simulate realistic SMS timing\n    console.log(`[MessageService] Simulating local delivery in ${delay}ms for message ${messageId}`);\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    // Update message delivery status in database\n    await this.messageRepo.updateDeliveryStatus(messageId, 'delivered');\n\n    // Trigger queue processing (simulates Twilio webhook calling queue service)\n    const { messageQueueService } = await import('./messageQueueService');\n    await messageQueueService.markMessageDelivered(messageId);\n\n    console.log(`[MessageService] Local delivery simulation complete for message ${messageId}`);\n  }\n\n  /**\n   * Send welcome message to a user\n   * Uses messagingAgentService and sends the generated message\n   * @returns The stored Message object\n   */\n  public async sendWelcomeMessage(user: UserWithProfile): Promise<Message> {\n    const welcomeMessage = await messagingAgentService.generateWelcomeMessage(user);\n    return await this.sendMessage(user, welcomeMessage);\n  }\n\n  /**\n   * Send fitness plan summary messages to a user\n   * Uses messagingAgentService and sends the generated messages\n   * @param user - The user to send to\n   * @param plan - The fitness plan to summarize\n   * @param previousMessages - Optional previous messages for context\n   * @returns Array of stored Message objects\n   */\n  public async sendPlanSummary(\n    user: UserWithProfile,\n    plan: FitnessPlan,\n    previousMessages?: Message[]\n  ): Promise<Message[]> {\n    const generatedMessages = await messagingAgentService.generatePlanSummary(user, plan, previousMessages);\n\n    // Send each message in sequence\n    const sentMessages: Message[] = [];\n    for (const message of generatedMessages) {\n      const storedMessage = await this.sendMessage(user, message);\n      sentMessages.push(storedMessage);\n      // Small delay between messages to ensure proper ordering\n      if (generatedMessages.length > 1) {\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n    }\n\n    if (sentMessages.length === 0) {\n      throw new Error('No messages were sent');\n    }\n\n    return sentMessages;\n  }\n\n  /**\n   * Send workout message to a user\n   * Generates SMS from workout data and sends it\n   * @param user - The user to send to\n   * @param workout - The workout instance (should have pre-generated message or description/reasoning)\n   * @returns The stored Message object\n   */\n  public async sendWorkoutMessage(\n    user: UserWithProfile,\n    workout: WorkoutInstance | EnhancedWorkoutInstance\n  ): Promise<Message> {\n    let message: string;\n    const workoutId = 'id' in workout ? workout.id : 'unknown';\n\n    // Fast path: Use pre-generated message if available\n    if ('message' in workout && workout.message) {\n      console.log(`[MessageService] Using pre-generated message from workout ${workoutId}`);\n      message = workout.message;\n      return await this.sendMessage(user, message);\n    }\n\n    // Fallback: Generate from description/reasoning (shouldn't happen in production)\n    if ('description' in workout && 'reasoning' in workout && workout.description && workout.reasoning) {\n      console.log(`[MessageService] Generating fallback message for workout ${workoutId}`);\n\n      try {\n        // Get message agent from workout agent service\n        const messageAgent = await workoutAgentService.getMessageAgent();\n\n        // Invoke with workout description string\n        const result = await messageAgent.invoke(workout.description);\n        message = result.response;\n\n        // Save generated message for future use\n        if ('id' in workout && workout.id) {\n          await this.workoutInstanceService.updateWorkoutMessage(workout.id, message);\n          console.log(`[MessageService] Saved fallback message to workout ${workout.id}`);\n        }\n\n        return await this.sendMessage(user, message);\n      } catch (error) {\n        console.error(`[MessageService] Failed to generate fallback message for workout ${workoutId}:`, error);\n        throw new Error('Failed to generate workout message');\n      }\n    }\n\n    // Should never reach here in production\n    throw new Error(`Workout ${workoutId} missing required fields (description/reasoning or message) for SMS generation`);\n  }\n}\n\n// Export singleton instance\nexport const messageService = MessageService.getInstance();","import { z } from 'zod';\nimport { initializeModel } from '@/server/agents';\nimport type { UserWithProfile } from '@/server/models/user';\nimport type { FitnessPlan } from '@/server/models/fitnessPlan';\nimport type { Message } from '@/server/models/conversation';\nimport type { DayOfWeek } from '@/shared/utils/date';\nimport { DAY_NAMES } from '@/shared/utils/date';\nimport type { MicrocycleGenerationOutput } from '@/server/services/agents/prompts/microcycles';\n\n// Schemas for structured outputs\nconst WeeklyMessageSchema = z.object({\n  feedbackMessage: z.string().describe(\"Message asking for feedback on the past week\")\n});\ntype WeeklyMessage = z.infer<typeof WeeklyMessageSchema>;\n\nconst PlanSummarySchema = z.object({\n  messages: z.array(z.string()).describe(\"Array of SMS messages (each under 160 chars)\")\n});\ntype PlanSummary = z.infer<typeof PlanSummarySchema>;\n\n// Prompts\nconst WEEKLY_MESSAGE_SYSTEM_PROMPT = `You are a fitness coach sending a weekly check-in message via SMS.\n\nYour task is to generate a FEEDBACK MESSAGE asking how their workouts went this past week.\n\nMESSAGE REQUIREMENTS:\n- Warm, conversational greeting using their first name\n- Ask about their training progress this past week\n- Keep it encouraging and supportive\n- If next week is a deload week, acknowledge it positively (recovery is important!)\n- Keep it around 20-40 words total\n- SMS-friendly format\n\nTone:\n- Supportive and motivating\n- Concise (SMS format)\n- Professional but friendly\n- Personal and caring\n\nFormat:\nReturn a JSON object with one field:\n{\n  \"feedbackMessage\": \"...\"\n}`;\n\nconst PLAN_READY_SYSTEM_PROMPT = `\nYou are a fitness coach sending a friendly \"your plan is ready\" message to a new client.\n\nThis is the second message they receive:\n- The first message went out when they signed up.\n- THIS message is sent once their full plan and Week 1 are ready.\n\nYour job is to take:\n1) A short \"Fitness Plan\" summary\n2) A short \"Week 1\" breakdown\nand merge them into ONE medium-length SMS.\n\n-----------------------------------------\nTONE\n-----------------------------------------\n- Friendly, confident, human\n- No jargon\n- Plain-speak, simple phrasing\n- SMS-friendly, concise\n- Supportive but not overly hyped\n\n-----------------------------------------\nCRITICAL LOGIC RULE\n-----------------------------------------\nYou must ONLY show the remaining days of the current week based on the user's signup day.\n\nInput weekday will be one of:\nMon, Tue, Wed, Thu, Fri, Sat, Sun.\n\nShow only today through Sunday. Never show past days.\n\n-----------------------------------------\nDAY LINE FORMAT RULES\n-----------------------------------------\nEvery day line must:\n- Be VERY short\n- Fit on a single phone line with no wrapping\n- Use simple wording\n- Ideal format examples:\n    \"Thu: Push + cardio (20–25 min)\"\n    \"Fri: Pull + cardio\"\n    \"Sat: Legs (technique)\"\n    \"Sun: Rest (optional walk)\"\n- NO em dashes — only colons, hyphens, parentheses, commas, plus signs.\n- One simple focus per day.\n\n-----------------------------------------\nSTRUCTURE & SPACING RULES\n-----------------------------------------\nYour final SMS must follow this exact structure WITH BLANK LINES between sections:\n\n1. **Opening paragraph (ONE paragraph)**\n   - Start with a friendly opener confirming the plan is ready.\n   - Immediately continue with a plain-English summary of the full plan.\n   - These MUST form a single paragraph with **no blank lines** inside.\n\n2. **Blank line**\n\n3. **Transition sentence**\n   - Example: \"Here's what the rest of this week looks like:\"\n\n4. **Blank line**\n\n5. **Day-by-day list**\n   - Only remaining days\n   - One day per line\n   - Each line must be short\n\n6. **Blank line**\n\n7. **Short supportive closing line**\n\n-----------------------------------------\nSTRICT RULES\n-----------------------------------------\n- Output ONLY the final composed SMS\n- Must match the spacing described above\n- No jargon or technical terms (no RIR, mesocycle, hypertrophy, etc.)\n- No em dashes\n- No more than 1–2 emojis total\n- Keep sentences short\n- Paraphrase naturally\n`;\n\nconst UPDATED_MICROCYCLE_SYSTEM_PROMPT = `\nYou are a fitness coach sending a friendly \"your week has been updated\" message to a client.\n\nThis message is sent when the client requests changes to their training week.\n\nYour job is to take:\n1) An explanation of what changed\n2) The updated week breakdown\nand create ONE concise SMS.\n\n-----------------------------------------\nTONE\n-----------------------------------------\n- Friendly, confident, human\n- No jargon\n- Plain-speak, simple phrasing\n- SMS-friendly, concise\n- Supportive and responsive to their request\n\n-----------------------------------------\nCRITICAL LOGIC RULE\n-----------------------------------------\nYou must ONLY show the remaining days of the current week based on the current day.\n\nInput weekday will be one of:\nMon, Tue, Wed, Thu, Fri, Sat, Sun.\n\nShow only today through Sunday. Never show past days.\n\n-----------------------------------------\nDAY LINE FORMAT RULES\n-----------------------------------------\nEvery day line must:\n- Be VERY short\n- Fit on a single phone line with no wrapping\n- Use simple wording\n- NO em dashes — only colons, hyphens, parentheses, commas, plus signs.\n- Keep each day to one simple focus.\n\n-----------------------------------------\nSESSION NAME SIMPLIFICATION\n-----------------------------------------\nTranslate technical terms into plain English:\n- Push → Chest & Shoulders\n- Pull → Back & Arms\n- Upper → Upper Body\n- Lower → Lower Body\n- Legs / Legs & Glutes → Lower Body\n- Active Recovery → Light Movement\n- Rest / Off → Rest Day\n- Deload → Recovery Day\n\nNo jargon terms: hypertrophy, mesocycle, microcycle, RIR, RPE, volume, intensity, etc.\n\n-----------------------------------------\nSTRUCTURE\n-----------------------------------------\nYour final SMS must follow this structure:\n\n1. Friendly acknowledgment of the update\n2. Brief explanation of what changed (1–2 sentences)\n3. Remaining days breakdown (today through Sunday)\n4. Optional short supportive closing (if space allows)\n\n-----------------------------------------\nSTRICT RULES\n-----------------------------------------\n- Output ONLY the final composed SMS\n- No jargon or technical terms\n- No em dashes\n- No more than 1 emoji total (or none)\n- Keep sentences short\n- Paraphrase the modifications explanation naturally\n- Show ONLY remaining days\n`;\n\n/**\n * MessagingAgentService - Handles all messaging-related AI operations\n *\n * Responsibilities:\n * - Welcome messages for new users\n * - Weekly check-in messages\n * - Plan summary messages\n * - Plan ready (combined plan + microcycle) messages\n * - Updated microcycle messages\n *\n * @example\n * ```typescript\n * const message = await messagingAgentService.generateWelcomeMessage(user);\n * ```\n */\nexport class MessagingAgentService {\n  private static instance: MessagingAgentService;\n\n  private constructor() {}\n\n  public static getInstance(): MessagingAgentService {\n    if (!MessagingAgentService.instance) {\n      MessagingAgentService.instance = new MessagingAgentService();\n    }\n    return MessagingAgentService.instance;\n  }\n\n  /**\n   * Generate a welcome message for a new user\n   * Uses a static template - no LLM needed\n   */\n  async generateWelcomeMessage(user: UserWithProfile): Promise<string> {\n    const firstName = user.name?.split(' ')[0] || 'there';\n\n    return `Hey ${firstName}!\n\nAfter you hit \"Sign Up,\" millions of documents were scanned—each with one goal: to build the best plan for your fitness journey.\n\nThen came the planning stage—millions of AI bots mapping, testing, and re-testing until your plan was dialed in. Working to the studs to perfect the product.\n\nNow, as your first workout sends, the bots cheer…then back to work…and we at the GymText family smile as another perfect plan leaves the factory.\n\nWelcome to GymText.\n\nText me anytime with questions about your workouts, your plan, or if you just need a little extra help!`;\n  }\n\n  /**\n   * Generate a weekly check-in message asking for feedback\n   */\n  async generateWeeklyMessage(\n    user: UserWithProfile,\n    isDeload: boolean,\n    absoluteWeek: number\n  ): Promise<string> {\n    const model = initializeModel<WeeklyMessage>(WeeklyMessageSchema);\n    const firstName = user.name.split(' ')[0];\n\n    const userPrompt = `Generate a weekly feedback check-in message for the user.\n\nUser Information:\n- Name: ${user.name}\n- First Name: ${firstName}\n- Week: ${absoluteWeek} of their program\n\n${isDeload ? `IMPORTANT: Next week is a DELOAD week - a planned recovery week with reduced intensity.\nAcknowledge this positively and remind them that recovery is part of the training process.` : 'This is a regular training week.'}\n\nGenerate the feedback message now.`;\n\n    console.log(`[MessagingAgentService] Weekly message user prompt: ${userPrompt}`);\n\n    const prompt = [\n      { role: 'system' as const, content: WEEKLY_MESSAGE_SYSTEM_PROMPT },\n      { role: 'user' as const, content: userPrompt }\n    ];\n\n    const result = await model.invoke(prompt);\n    return result.feedbackMessage;\n  }\n\n  /**\n   * Generate plan summary SMS messages (2-3 messages under 160 chars each)\n   */\n  async generatePlanSummary(\n    user: UserWithProfile,\n    plan: FitnessPlan,\n    previousMessages?: Message[]\n  ): Promise<string[]> {\n    const model = initializeModel<PlanSummary>(PlanSummarySchema);\n\n    const hasContext = previousMessages && previousMessages.length > 0;\n    const contextSection = hasContext\n      ? `\n<Previous Messages>\n${previousMessages.map(msg => `${msg.direction === 'inbound' ? 'User' : 'Coach'}: ${msg.content}`).join('\\n\\n')}\n</Previous Messages>\n\nIMPORTANT: You are continuing a conversation that has already started. DO NOT greet the user by name again. DO NOT introduce yourself again. Just continue naturally with the plan summary.\n`\n      : '';\n\n    const prompt = `\nYou are a motivational fitness coach sending an exciting SMS message about a new fitness plan.\n\n${contextSection}\n\n<Task>\nCreate 2-3 SMS messages (each under 160 characters) that summarize this fitness plan in an exciting, motivational way.\n</Task>\n\n<User>\nName: ${user.name}\n</User>\n\n<Plan Details>\n${plan.description || 'No plan description available.'}\n</Plan Details>\n\n<Guidelines>\n- Keep each message under 160 characters (SMS limit)\n- Be enthusiastic and motivational\n- Focus on what the plan will do for them (outcomes, not just structure)\n- Mention the training split and key focuses from the plan\n- Make them excited to start\n- Use conversational, friendly tone\n- Don't use emojis unless they help save characters\n- Number the messages if multiple (e.g., \"1/3:\", \"2/3:\")\n\n<Output Format>\nReturn a JSON object with an array of messages:\n{\n  \"messages\": [\n    \"Message 1 text here...\",\n    \"Message 2 text here...\",\n    \"Message 3 text here (if needed)...\"\n  ]\n}\n</Output Format>\n\nNow create the motivational SMS messages for ${user.name}'s training program.\n`;\n\n    const result = await model.invoke(prompt);\n    return result.messages;\n  }\n\n  /**\n   * Generate a \"plan ready\" message combining plan summary and week one breakdown\n   */\n  async generatePlanMicrocycleCombinedMessage(\n    fitnessPlan: string,\n    weekOne: string,\n    currentWeekday: DayOfWeek\n  ): Promise<string> {\n    const model = initializeModel(undefined); // Plain text output\n\n    const userPrompt = `\nCreate the \"your plan is ready\" SMS using the inputs below.\nFollow the System Prompt exactly.\n\n[FITNESS PLAN]\n${fitnessPlan}\n\n[WEEK 1]\n${weekOne}\n\n[TODAY]\n${currentWeekday}\n\nOutput ONE medium-length SMS:\n- Confirm the plan is ready\n- Summarize the plan plainly\n- Transition into the week\n- Show ONLY the remaining days, each on one short line\n- NO em dashes\n- Supportive closing line\n`.trim();\n\n    const messages = [\n      { role: 'system', content: PLAN_READY_SYSTEM_PROMPT },\n      { role: 'user', content: userPrompt }\n    ];\n\n    return model.invoke(messages);\n  }\n\n  /**\n   * Generate an \"updated week\" message when a microcycle is modified\n   */\n  async generateUpdatedMicrocycleMessage(\n    modifiedMicrocycle: MicrocycleGenerationOutput,\n    modifications: string,\n    currentWeekday: DayOfWeek\n  ): Promise<string> {\n    const model = initializeModel(undefined); // Plain text output\n\n    // Get day index (Mon=0, Tue=1, etc.)\n    const dayIndex = DAY_NAMES.indexOf(currentWeekday);\n\n    // Get remaining days (today through Sunday)\n    const remainingDays = modifiedMicrocycle.days\n      .slice(dayIndex)\n      .map((dayOverview, idx) => {\n        const actualDayName = DAY_NAMES[dayIndex + idx];\n        return `${actualDayName}:\\n${dayOverview}`;\n      })\n      .join('\\n\\n');\n\n    const userPrompt = `\nCreate an \"updated week\" SMS using the inputs below.\nFollow the System Prompt exactly.\n\n[WHAT CHANGED]\n${modifications}\n\n[UPDATED WEEK OVERVIEW]\n${modifiedMicrocycle.overview}\n\n[IS DELOAD WEEK]\n${modifiedMicrocycle.isDeload}\n\n[REMAINING DAYS]\n${remainingDays}\n\n[TODAY]\n${currentWeekday}\n\nOutput ONE concise SMS:\n- Acknowledge the update\n- Briefly explain what changed (paraphrase naturally)\n- Show ONLY the remaining days, each on one short line\n- NO em dashes\n- Optional supportive closing\n`.trim();\n\n    const messages = [\n      { role: 'system', content: UPDATED_MICROCYCLE_SYSTEM_PROMPT },\n      { role: 'user', content: userPrompt }\n    ];\n\n    return model.invoke(messages);\n  }\n}\n\nexport const messagingAgentService = MessagingAgentService.getInstance();\n"],"names":[],"mappings":"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"}