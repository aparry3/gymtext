{"version":3,"sources":["../../../../../../packages/shared/src/server/repositories/fitnessPlanRepository.ts","../../../../../../packages/shared/src/server/services/training/fitnessPlanService.ts","../../../../../../packages/shared/src/server/repositories/workoutInstanceRepository.ts","../../../../../../packages/shared/src/server/services/training/workoutInstanceService.ts","../../../../../../packages/shared/src/server/services/training/progressService.ts","../../../../../../packages/shared/src/server/repositories/microcycleRepository.ts","../../../../../../packages/shared/src/server/services/training/microcycleService.ts","../../../../../../packages/shared/src/server/repositories/shortLinkRepository.ts","../../../../../../packages/shared/src/server/services/links/shortLinkService.ts","../../../../../../packages/shared/src/server/utils/formatters/microcycle.ts","../../../../../../packages/shared/src/server/utils/formatters/fitnessProfile.ts","../../../../../../packages/shared/src/server/utils/formatters/text.ts"],"sourcesContent":["import { BaseRepository } from '@/server/repositories/baseRepository';\nimport {\n  FitnessPlanModel,\n  type FitnessPlan,\n} from '@/server/models/fitnessPlan';\n\n/**\n * Repository for fitness plan database operations\n *\n * Plans are now simple structured text - no more JSON mesocycles array\n */\nexport class FitnessPlanRepository extends BaseRepository {\n  /**\n   * Insert a new fitness plan\n   */\n  async insertFitnessPlan(fitnessPlan: FitnessPlan): Promise<FitnessPlan> {\n    const result = await this.db\n      .insertInto('fitnessPlans')\n      .values({\n        clientId: fitnessPlan.clientId,\n        description: fitnessPlan.description,\n        message: fitnessPlan.message,\n        structured: fitnessPlan.structured ? JSON.stringify(fitnessPlan.structured) : null,\n        startDate: fitnessPlan.startDate,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return FitnessPlanModel.fromDB(result);\n  }\n\n  /**\n   * Get a fitness plan by ID\n   */\n  async getFitnessPlan(id: string): Promise<FitnessPlan | null> {\n    const result = await this.db\n      .selectFrom('fitnessPlans')\n      .selectAll()\n      .where('id', '=', id)\n      .executeTakeFirst();\n\n    if (!result) return null;\n    return FitnessPlanModel.fromDB(result);\n  }\n\n  /**\n   * Get the current (latest) fitness plan for a user\n   */\n  async getCurrentPlan(userId: string): Promise<FitnessPlan | null> {\n    const result = await this.db\n      .selectFrom('fitnessPlans')\n      .selectAll()\n      .where('clientId', '=', userId)\n      .orderBy('createdAt', 'desc')\n      .executeTakeFirst();\n\n    if (!result) return null;\n    return FitnessPlanModel.fromDB(result);\n  }\n\n  /**\n   * Get all fitness plans for a user (for history)\n   * Returns plans ordered by creation date (newest first)\n   */\n  async getPlanHistory(userId: string): Promise<FitnessPlan[]> {\n    const results = await this.db\n      .selectFrom('fitnessPlans')\n      .selectAll()\n      .where('clientId', '=', userId)\n      .orderBy('createdAt', 'desc')\n      .execute();\n\n    return results.map(FitnessPlanModel.fromDB);\n  }\n\n  /**\n   * Update a fitness plan\n   */\n  async updateFitnessPlan(\n    id: string,\n    updates: Partial<Pick<FitnessPlan, 'description' | 'message' | 'structured'>>\n  ): Promise<FitnessPlan | null> {\n    const updateData: Record<string, unknown> = {\n      updatedAt: new Date(),\n    };\n\n    if (updates.description !== undefined) {\n      updateData.description = updates.description;\n    }\n    if (updates.message !== undefined) {\n      updateData.message = updates.message;\n    }\n    if (updates.structured !== undefined) {\n      updateData.structured = updates.structured ? JSON.stringify(updates.structured) : null;\n    }\n\n    const result = await this.db\n      .updateTable('fitnessPlans')\n      .set(updateData)\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirst();\n\n    if (!result) return null;\n    return FitnessPlanModel.fromDB(result);\n  }\n\n  /**\n   * Delete a fitness plan by ID\n   */\n  async deleteFitnessPlan(id: string): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom('fitnessPlans')\n      .where('id', '=', id)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows) > 0;\n  }\n}\n","import { FitnessPlanRepository } from '@/server/repositories/fitnessPlanRepository';\nimport { FitnessPlan, FitnessPlanModel } from '../../models/fitnessPlan';\nimport { UserWithProfile } from '../../models/user';\nimport { fitnessPlanAgentService } from '../agents/training';\nimport { postgresDb } from '@/server/connections/postgres/postgres';\n\n/**\n * Simplified FitnessPlanService\n *\n * Creates and manages fitness plans. Plans are now simple structured text\n * that describe the training split, frequency, goals, and progression rules.\n * No more mesocycle generation - microcycles are generated directly from the plan.\n */\nexport class FitnessPlanService {\n  private static instance: FitnessPlanService;\n  private fitnessPlanRepo: FitnessPlanRepository;\n\n  private constructor() {\n    this.fitnessPlanRepo = new FitnessPlanRepository(postgresDb);\n  }\n\n  public static getInstance(): FitnessPlanService {\n    if (!FitnessPlanService.instance) {\n      FitnessPlanService.instance = new FitnessPlanService();\n    }\n    return FitnessPlanService.instance;\n  }\n\n  /**\n   * Create a new fitness plan for a user\n   *\n   * Uses the FitnessPlanAgent to generate a structured text plan\n   * that contains split, frequency, goals, deload rules, and progression principles.\n   */\n  public async createFitnessPlan(user: UserWithProfile): Promise<FitnessPlan> {\n    // Use AI agent service to generate fitness plan\n    const agentResponse = await fitnessPlanAgentService.generateFitnessPlan(user);\n\n    const fitnessPlan = FitnessPlanModel.fromFitnessPlanOverview(user, agentResponse);\n    console.log('[FitnessPlanService] Created plan:', fitnessPlan.description?.substring(0, 200));\n\n    const savedFitnessPlan = await this.fitnessPlanRepo.insertFitnessPlan(fitnessPlan);\n\n    return savedFitnessPlan;\n  }\n\n  /**\n   * Get the current (latest) fitness plan for a user\n   */\n  public async getCurrentPlan(userId: string): Promise<FitnessPlan | null> {\n    return await this.fitnessPlanRepo.getCurrentPlan(userId);\n  }\n\n  /**\n   * Get a fitness plan by ID\n   */\n  public async getPlanById(planId: string): Promise<FitnessPlan | null> {\n    return await this.fitnessPlanRepo.getFitnessPlan(planId);\n  }\n\n  /**\n   * Get all fitness plans for a user (for history)\n   */\n  public async getPlanHistory(userId: string): Promise<FitnessPlan[]> {\n    return await this.fitnessPlanRepo.getPlanHistory(userId);\n  }\n\n  /**\n   * Update a fitness plan's AI-generated fields\n   */\n  public async updateFitnessPlan(\n    planId: string,\n    updates: Partial<Pick<FitnessPlan, 'description' | 'message' | 'structured'>>\n  ): Promise<FitnessPlan | null> {\n    return await this.fitnessPlanRepo.updateFitnessPlan(planId, updates);\n  }\n\n  /**\n   * Delete a fitness plan by ID\n   */\n  public async deleteFitnessPlan(planId: string): Promise<boolean> {\n    return await this.fitnessPlanRepo.deleteFitnessPlan(planId);\n  }\n}\n\n// Export singleton instance\nexport const fitnessPlanService = FitnessPlanService.getInstance();\n","import { BaseRepository } from '@/server/repositories/baseRepository';\nimport type {\n  NewWorkoutInstance,\n  WorkoutInstance\n} from '@/server/models/workout';\n\nexport class WorkoutInstanceRepository extends BaseRepository {\n  /**\n   * Create a new workout instance\n   */\n  async create(data: NewWorkoutInstance): Promise<WorkoutInstance> {\n    // Ensure details and structured fields are properly serialized for JSONB columns\n    const serializedData = {\n      ...data,\n      details: typeof data.details === 'string'\n        ? data.details\n        : JSON.stringify(data.details),\n      structured: data.structured\n        ? (typeof data.structured === 'string' ? data.structured : JSON.stringify(data.structured))\n        : null\n    };\n\n    const result = await this.db\n      .insertInto('workoutInstances')\n      .values(serializedData)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Find workout instances for a client within a date range\n   */\n  async findByClientIdAndDateRange(\n    clientId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<WorkoutInstance[]> {\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .where('clientId', '=', clientId)\n      .where('date', '>=', startDate)\n      .where('date', '<=', endDate)\n      .orderBy('date', 'asc')\n      .selectAll()\n      .execute();\n\n    return results;\n  }\n\n  /**\n   * Find a single workout instance by client ID and date\n   */\n  async findByClientIdAndDate(\n    clientId: string,\n    date: Date\n  ): Promise<WorkoutInstance | undefined> {\n    // The incoming date is already midnight in the user's timezone (as a UTC timestamp)\n    // We need to find workouts within the next 24 hours from that point\n    const startOfDay = new Date(date);\n\n    const endOfDay = new Date(date);\n    endOfDay.setUTCDate(endOfDay.getUTCDate() + 1);\n\n    const result = await this.db\n      .selectFrom('workoutInstances')\n      .where('clientId', '=', clientId)\n      .where('date', '>=', startOfDay)\n      .where('date', '<', endOfDay)\n      .selectAll()\n      .executeTakeFirst();\n\n    return result;\n  }\n\n  /**\n   * Get recent workouts for a user\n   * @param userId The user's ID\n   * @param limit Number of workouts to return (default 10)\n   */\n  async getRecentWorkouts(\n    userId: string,\n    limit: number = 10\n  ): Promise<WorkoutInstance[]> {\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .leftJoin('microcycles', 'workoutInstances.microcycleId', 'microcycles.id')\n      .select([\n        'workoutInstances.id',\n        'workoutInstances.clientId',\n        'workoutInstances.microcycleId',\n        'workoutInstances.date',\n        'workoutInstances.sessionType',\n        'workoutInstances.goal',\n        'workoutInstances.details',\n        'workoutInstances.structured',\n        'workoutInstances.description',\n        'workoutInstances.message',\n        'workoutInstances.completedAt',\n        'workoutInstances.createdAt',\n        'workoutInstances.updatedAt',\n        'microcycles.absoluteWeek'\n      ])\n      .where('workoutInstances.clientId', '=', userId)\n      .orderBy('workoutInstances.date', 'desc')\n      .limit(limit)\n      .execute();\n\n    return results as unknown as WorkoutInstance[];\n  }\n\n  /**\n   * Get recent workouts for a user by date range\n   * @param userId The user's ID\n   * @param days Number of days to look back\n   */\n  async getRecentWorkoutsByDays(\n    userId: string,\n    days: number = 7\n  ): Promise<WorkoutInstance[]> {\n    const endDate = new Date();\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .where('clientId', '=', userId)\n      .where('date', '>=', startDate)\n      .where('date', '<=', endDate)\n      .orderBy('date', 'desc')\n      .selectAll()\n      .execute();\n\n    return results;\n  }\n\n  /**\n   * Get workout by specific date\n   * @param userId The user's ID\n   * @param date The specific date\n   */\n  async getWorkoutByDate(\n    userId: string,\n    date: Date\n  ): Promise<WorkoutInstance | undefined> {\n    return this.findByClientIdAndDate(userId, date);\n  }\n\n  /**\n   * Update workout instance\n   * @param id The workout ID\n   * @param data The update data\n   */\n  async update(\n    id: string,\n    data: Partial<NewWorkoutInstance>\n  ): Promise<WorkoutInstance | undefined> {\n    const updateData = {\n      ...data,\n      updatedAt: new Date()\n    };\n\n    if (data.details) {\n      updateData.details = typeof data.details === 'string'\n        ? data.details\n        : JSON.stringify(data.details);\n    }\n\n    if (data.structured !== undefined) {\n      updateData.structured = data.structured\n        ? (typeof data.structured === 'string' ? data.structured : JSON.stringify(data.structured))\n        : null;\n    }\n\n    const result = await this.db\n      .updateTable('workoutInstances')\n      .set(updateData)\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirst();\n\n    return result;\n  }\n\n  /**\n   * Delete old workout instances (cleanup)\n   * @param daysToKeep Number of days to keep\n   */\n  async deleteOldWorkouts(daysToKeep: number = 90): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);\n\n    const result = await this.db\n      .deleteFrom('workoutInstances')\n      .where('date', '<', cutoffDate)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows);\n  }\n\n  /**\n   * Get a workout by its ID\n   * @param workoutId The workout's ID\n   */\n  async getWorkoutById(workoutId: string): Promise<WorkoutInstance | undefined> {\n    const result = await this.db\n      .selectFrom('workoutInstances')\n      .selectAll()\n      .where('id', '=', workoutId)\n      .executeTakeFirst();\n\n    return result;\n  }\n\n  /**\n   * Get workouts by microcycle\n   * @param userId The user's ID\n   * @param microcycleId The microcycle ID\n   */\n  async getWorkoutsByMicrocycle(\n    userId: string,\n    microcycleId: string\n  ): Promise<WorkoutInstance[]> {\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .where('clientId', '=', userId)\n      .where('microcycleId', '=', microcycleId)\n      .orderBy('date', 'asc')\n      .selectAll()\n      .execute();\n\n    return results;\n  }\n\n  /**\n   * Get workouts by date range for microcycle week view\n   * @param userId The user's ID\n   * @param startDate Start date of the week\n   * @param endDate End date of the week\n   */\n  async getWorkoutsByDateRange(\n    userId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<WorkoutInstance[]> {\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .leftJoin('microcycles', 'workoutInstances.microcycleId', 'microcycles.id')\n      .select([\n        'workoutInstances.id',\n        'workoutInstances.clientId',\n        'workoutInstances.microcycleId',\n        'workoutInstances.date',\n        'workoutInstances.sessionType',\n        'workoutInstances.goal',\n        'workoutInstances.details',\n        'workoutInstances.structured',\n        'workoutInstances.description',\n        'workoutInstances.message',\n        'workoutInstances.completedAt',\n        'workoutInstances.createdAt',\n        'workoutInstances.updatedAt',\n        'microcycles.absoluteWeek'\n      ])\n      .where('workoutInstances.clientId', '=', userId)\n      .where('workoutInstances.date', '>=', startDate)\n      .where('workoutInstances.date', '<=', endDate)\n      .orderBy('workoutInstances.date', 'asc')\n      .execute();\n\n    return results as unknown as WorkoutInstance[];\n  }\n\n  /**\n   * Delete a workout instance by ID\n   * @param workoutId The workout's ID\n   */\n  async delete(workoutId: string): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom('workoutInstances')\n      .where('id', '=', workoutId)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows) > 0;\n  }\n\n  /**\n   * Find which users already have workouts for their respective \"today\"\n   * Used for catch-up logic to avoid sending duplicate daily messages\n   * @param userDatePairs Array of user IDs with their timezone-specific date ranges\n   * @returns Set of user IDs that already have workouts\n   */\n  async findUserIdsWithWorkoutsForUserDates(\n    userDatePairs: Array<{ userId: string; startOfDay: Date; endOfDay: Date }>\n  ): Promise<Set<string>> {\n    if (userDatePairs.length === 0) {\n      return new Set();\n    }\n\n    // Build OR conditions for each user/date pair\n    const results = await this.db\n      .selectFrom('workoutInstances')\n      .select('clientId')\n      .where((eb) => {\n        const conditions = userDatePairs.map(({ userId, startOfDay, endOfDay }) =>\n          eb.and([\n            eb('clientId', '=', userId),\n            eb('date', '>=', startOfDay),\n            eb('date', '<', endOfDay)\n          ])\n        );\n        return eb.or(conditions);\n      })\n      .execute();\n\n    return new Set(results.map(r => r.clientId));\n  }\n}\n","import { WorkoutInstanceRepository } from '@/server/repositories/workoutInstanceRepository';\nimport { postgresDb } from '@/server/connections/postgres/postgres';\nimport { workoutAgentService } from '@/server/services/agents/training';\nimport type { WorkoutInstanceUpdate, NewWorkoutInstance, WorkoutInstance } from '@/server/models/workout';\nimport type { UserWithProfile } from '@/server/models/user';\nimport type { ActivityType, Microcycle } from '@/server/models/microcycle';\nimport { FitnessPlanService } from './fitnessPlanService';\nimport { ProgressService } from './progressService';\nimport { MicrocycleService } from './microcycleService';\nimport { shortLinkService } from '../links/shortLinkService';\nimport { DateTime } from 'luxon';\nimport { getWeekday, getDayOfWeekName } from '@/shared/utils/date';\nimport { normalizeWhitespace } from '@/server/utils/formatters';\n\nexport class WorkoutInstanceService {\n  private static instance: WorkoutInstanceService;\n  private workoutRepo: WorkoutInstanceRepository;\n  private fitnessPlanService: FitnessPlanService;\n  private progressService: ProgressService;\n  private microcycleService: MicrocycleService;\n\n  private constructor() {\n    this.workoutRepo = new WorkoutInstanceRepository(postgresDb);\n    this.fitnessPlanService = FitnessPlanService.getInstance();\n    this.progressService = ProgressService.getInstance();\n    this.microcycleService = MicrocycleService.getInstance();\n  }\n\n  public static getInstance(): WorkoutInstanceService {\n    if (!WorkoutInstanceService.instance) {\n      WorkoutInstanceService.instance = new WorkoutInstanceService();\n    }\n    return WorkoutInstanceService.instance;\n  }\n\n  /**\n   * Get recent workouts for a user\n   */\n  public async getRecentWorkouts(userId: string, limit: number = 10) {\n    return await this.workoutRepo.getRecentWorkouts(userId, limit);\n  }\n\n  /**\n   * Get workouts by date range\n   */\n  public async getWorkoutsByDateRange(userId: string, startDate: Date, endDate: Date) {\n    return await this.workoutRepo.getWorkoutsByDateRange(userId, startDate, endDate);\n  }\n\n  /**\n   * Get a specific workout by ID and verify it belongs to the user\n   */\n  public async getWorkoutById(workoutId: string, userId: string) {\n    const workout = await this.workoutRepo.getWorkoutById(workoutId);\n\n    if (!workout || workout.clientId !== userId) {\n      return null;\n    }\n\n    return workout;\n  }\n\n  /**\n   * Get a workout by ID without authorization check\n   * For internal service-to-service use only\n   */\n  public async getWorkoutByIdInternal(workoutId: string): Promise<WorkoutInstance | undefined> {\n    return await this.workoutRepo.getWorkoutById(workoutId);\n  }\n\n  /**\n   * Get a workout by user ID and date\n   */\n  public async getWorkoutByUserIdAndDate(userId: string, date: Date) {\n    return await this.workoutRepo.findByClientIdAndDate(userId, date);\n  }\n\n  /**\n   * Update the message for a workout\n   */\n  public async updateWorkoutMessage(workoutId: string, message: string) {\n    return await this.workoutRepo.update(workoutId, { message });\n  }\n\n  /**\n   * Create a new workout instance\n   */\n  public async createWorkout(workout: NewWorkoutInstance) {\n    return await this.workoutRepo.create(workout);\n  }\n\n  /**\n   * Update a workout with new details, description, reasoning, and message\n   */\n  public async updateWorkout(workoutId: string, updates: WorkoutInstanceUpdate) {\n    return await this.workoutRepo.update(workoutId, updates);\n  }\n\n  /**\n   * Generate a workout for a specific date using AI\n   *\n   * This is the core business logic for workout generation:\n   * 1. Gets user's fitness plan and current progress\n   * 2. Determines day pattern from microcycle\n   * 3. Generates workout using AI agent\n   * 4. Saves workout with pre-generated message\n   * 5. Creates short link and appends to message\n   *\n   * @param user - User with profile\n   * @param targetDate - Date to generate workout for\n   * @param providedMicrocycle - Optional pre-loaded microcycle (avoids extra DB query)\n   * @returns Generated and saved workout instance\n   */\n  public async generateWorkoutForDate(\n    user: UserWithProfile,\n    targetDate: DateTime,\n    providedMicrocycle?: Microcycle\n  ): Promise<WorkoutInstance | null> {\n    try {\n      // Get fitness plan\n      const plan = await this.fitnessPlanService.getCurrentPlan(user.id);\n      if (!plan) {\n        console.log(`No fitness plan found for user ${user.id}`);\n        return null;\n      }\n\n      // Get current progress for the target date\n      const progress = await this.progressService.getProgressForDate(plan, targetDate.toJSDate(), user.timezone);\n      if (!progress) {\n        console.log(`No progress found for user ${user.id} on ${targetDate.toISODate()}`);\n        return null;\n      }\n\n      // Use provided microcycle or get/create one for the target date\n      let microcycle: Microcycle | null = providedMicrocycle ?? null;\n      if (!microcycle) {\n        const result = await this.progressService.getOrCreateMicrocycleForDate(\n          user.id,\n          plan,\n          targetDate.toJSDate(),\n          user.timezone\n        );\n        microcycle = result.microcycle;\n      }\n      if (!microcycle) {\n        console.log(`Could not get/create microcycle for user ${user.id}`);\n        return null;\n      }\n\n      // Get the day's overview from the microcycle\n      // getWeekday returns 1-7 (Mon-Sun), days array is 0-indexed (Mon=0, Sun=6)\n      const dayIndex = getWeekday(targetDate.toJSDate(), user.timezone) - 1;\n      const dayOverview = microcycle.days?.[dayIndex];\n\n      if (!dayOverview || typeof dayOverview !== 'string') {\n        console.log(`No overview found for day index ${dayIndex} in microcycle ${microcycle.id}`);\n        return null;\n      }\n\n      // Get activity type from structured microcycle data (if available)\n      const structuredDay = microcycle.structured?.days?.[dayIndex];\n      const activityType = structuredDay?.activityType as ActivityType | undefined;\n\n      // Get recent workouts for context (last 7 days)\n      // const recentWorkouts = await this.getRecentWorkouts(user.id, 7);\n\n      // Use AI agent service to generate workout with message\n      const { response: description, message, structure } = await workoutAgentService.generateWorkout(\n        user,\n        dayOverview,\n        microcycle.isDeload ?? false,\n        activityType\n      );\n\n      // Extract theme from structured data or use default\n      const theme = structure?.title || 'Workout';\n\n      const details = {\n        theme,  // Keep theme for quick access\n      };\n\n      // Convert to database format\n      const workout: NewWorkoutInstance = {\n        clientId: user.id,\n        microcycleId: microcycle.id,\n        date: targetDate.toJSDate(),\n        sessionType: 'workout', // Use generic session type since we don't have theme from day overview\n        goal: dayOverview.substring(0, 100), // Use first 100 chars of overview as goal\n        details: JSON.parse(JSON.stringify(details)),\n        description,\n        message,\n        structured: structure,\n        completedAt: null,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      // Save the workout to the database\n      const savedWorkout = await this.createWorkout(workout);\n      console.log(`Generated and saved workout for user ${user.id} on ${targetDate.toISODate()}`);\n\n      // Generate short link for the workout\n      try {\n        const shortLink = await shortLinkService.createWorkoutLink(user.id, savedWorkout.id);\n        const fullUrl = shortLinkService.getFullUrl(shortLink.code);\n        console.log(`Created short link for workout ${savedWorkout.id}: ${fullUrl}`);\n\n        // Append short link to message\n        if (savedWorkout.message) {\n          const dayOfWeekTitle = getDayOfWeekName(targetDate.toJSDate(), user.timezone); // Monday, Tuesday, etc.\n          savedWorkout.message = normalizeWhitespace(`${dayOfWeekTitle}\\n\\n${savedWorkout.message}\\n\\n(More details: ${fullUrl})`);\n          await this.updateWorkoutMessage(savedWorkout.id, savedWorkout.message);\n        }\n      } catch (error) {\n        console.error(`Failed to create short link for workout ${savedWorkout.id}:`, error);\n        // Continue without link - not critical\n      }\n\n      return savedWorkout;\n    } catch (error) {\n      console.error(`Error generating workout for user ${user.id}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Maps theme to session type for database storage\n   * Valid frontend types: run, lift, metcon, mobility, rest, other\n   */\n  private mapThemeToSessionType(theme: string): string {\n    const themeLower = theme.toLowerCase();\n\n    if (themeLower.includes('run') || themeLower.includes('running')) return 'run';\n    if (themeLower.includes('metcon') || themeLower.includes('hiit') ||\n        themeLower.includes('conditioning') || themeLower.includes('cardio')) return 'metcon';\n    if (themeLower.includes('lift') || themeLower.includes('strength') ||\n        themeLower.includes('upper') || themeLower.includes('lower') ||\n        themeLower.includes('push') || themeLower.includes('pull')) return 'lift';\n    if (themeLower.includes('mobility') || themeLower.includes('flexibility') ||\n        themeLower.includes('stretch')) return 'mobility';\n    if (themeLower.includes('rest') || themeLower.includes('recovery') ||\n        themeLower.includes('deload')) return 'rest';\n\n    return 'other';\n  }\n\n  /**\n   * Delete a workout instance\n   */\n  public async deleteWorkout(workoutId: string, userId: string): Promise<boolean> {\n    // First verify the workout belongs to the user\n    const workout = await this.workoutRepo.getWorkoutById(workoutId);\n\n    if (!workout || workout.clientId !== userId) {\n      return false;\n    }\n\n    // Delete the workout\n    return await this.workoutRepo.delete(workoutId);\n  }\n\n  /**\n   * Get workouts by microcycle ID\n   */\n  public async getWorkoutsByMicrocycle(userId: string, microcycleId: string): Promise<WorkoutInstance[]> {\n    return await this.workoutRepo.getWorkoutsByMicrocycle(userId, microcycleId);\n  }\n}\n\n// Export singleton instance\nexport const workoutInstanceService = WorkoutInstanceService.getInstance();","import { FitnessPlan } from '../../models/fitnessPlan';\nimport { Microcycle } from '../../models/microcycle';\nimport {\n  parseDate,\n  now,\n  startOfWeek,\n  endOfWeek,\n  diffInWeeks,\n  getWeekday,\n} from '@/shared/utils/date';\nimport { MicrocycleService } from './microcycleService';\n\n/**\n * Simplified ProgressInfo without mesocycle layer\n */\nexport interface ProgressInfo {\n  fitnessPlan: FitnessPlan;\n  microcycle: Microcycle | null;\n  absoluteWeek: number;          // Weeks since plan start (1-indexed)\n  dayOfWeek: number;             // Day of week (1-7, Luxon format: 1=Mon, 7=Sun)\n  weekStartDate: Date;           // Start of current week\n  weekEndDate: Date;             // End of current week\n}\n\n/**\n * Simplified ProgressService\n *\n * Calculates progress based on plan start date and absolute week number.\n * No mesocycle layer - deload logic is derived from plan description.\n */\nexport class ProgressService {\n  private static instance: ProgressService;\n  private microcycleService: MicrocycleService;\n\n  private constructor() {\n    this.microcycleService = MicrocycleService.getInstance();\n  }\n\n  public static getInstance(): ProgressService {\n    if (!ProgressService.instance) {\n      ProgressService.instance = new ProgressService();\n    }\n    return ProgressService.instance;\n  }\n\n  /**\n   * Calculate progress for a specific date based on the fitness plan\n   * Uses absolute week number from plan start - no mesocycle lookup needed\n   */\n  public async getProgressForDate(\n    plan: FitnessPlan,\n    targetDate: Date,\n    timezone: string = 'America/New_York'\n  ): Promise<ProgressInfo | null> {\n    if (!plan || !plan.id) {\n      return null;\n    }\n\n    // Parse the plan start date\n    const planStartDate = parseDate(plan.startDate);\n    if (!planStartDate) {\n      return null;\n    }\n\n    // Calculate absolute week number since plan start (1-indexed)\n    const planStart = startOfWeek(planStartDate, timezone);\n    const targetWeekStart = startOfWeek(targetDate, timezone);\n    const absoluteWeek = diffInWeeks(targetWeekStart, planStart, timezone) + 1;\n\n    // If before plan start, return null\n    if (absoluteWeek < 1) {\n      return null;\n    }\n\n    // Query for existing microcycle by date or absolute week\n    // Note: queries by clientId only, not fitnessPlanId, to handle plan modifications\n    let microcycle = await this.microcycleService.getMicrocycleByDate(\n      plan.clientId,\n      targetDate\n    );\n\n    // If not found by date, try by absolute week\n    if (!microcycle) {\n      microcycle = await this.microcycleService.getMicrocycleByAbsoluteWeek(\n        plan.clientId,\n        absoluteWeek\n      );\n    }\n\n    // Calculate date-related fields\n    const dayOfWeek = getWeekday(targetDate, timezone);\n    const weekStart = startOfWeek(targetDate, timezone);\n    const weekEnd = endOfWeek(targetDate, timezone);\n\n    return {\n      fitnessPlan: plan,\n      microcycle,\n      absoluteWeek,\n      dayOfWeek,\n      weekStartDate: weekStart,\n      weekEndDate: weekEnd,\n    };\n  }\n\n  /**\n   * Get progress for the current date in the user's timezone\n   */\n  public async getCurrentProgress(\n    plan: FitnessPlan,\n    timezone: string = 'America/New_York'\n  ): Promise<ProgressInfo | null> {\n    const currentDate = now(timezone).toJSDate();\n    return await this.getProgressForDate(plan, currentDate, timezone);\n  }\n\n  /**\n   * Get or create microcycle for a specific date\n   * This is the main entry point for ensuring a user has a microcycle for any given week\n   *\n   * @param forceCreate - When true, always creates new microcycle (for re-onboarding)\n   */\n  public async getOrCreateMicrocycleForDate(\n    userId: string,\n    plan: FitnessPlan,\n    targetDate: Date,\n    timezone: string = 'America/New_York',\n    forceCreate: boolean = false\n  ): Promise<{ microcycle: Microcycle; progress: ProgressInfo; wasCreated: boolean }> {\n    // Calculate progress for the target date\n    const progress = await this.getProgressForDate(plan, targetDate, timezone);\n    if (!progress) {\n      throw new Error(`Could not calculate progress for date ${targetDate}`);\n    }\n\n    // If microcycle already exists and not forcing creation, return it\n    if (progress.microcycle && !forceCreate) {\n      return { microcycle: progress.microcycle, progress, wasCreated: false };\n    }\n\n    // Microcycle doesn't exist (or forceCreate=true) - create it using MicrocycleService\n    const microcycle = await this.microcycleService.createMicrocycleFromProgress(\n      userId,\n      plan,\n      progress\n    );\n\n    // Update progress with new microcycle\n    const updatedProgress = { ...progress, microcycle };\n\n    return { microcycle, progress: updatedProgress, wasCreated: true };\n  }\n}\n\n// Export singleton instance\nexport const progressService = ProgressService.getInstance();\n","import { Kysely } from 'kysely';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DB } from '@/server/models/_types';\nimport { Microcycle, MicrocycleModel } from '@/server/models/microcycle';\n\n/**\n * Repository for microcycle database operations\n *\n * Microcycles now use:\n * - absoluteWeek: Week number from plan start (1-indexed)\n * - days: Ordered array of day descriptions\n * - No mesocycleIndex or weekNumber\n */\nexport class MicrocycleRepository {\n  constructor(private db: Kysely<DB>) {}\n\n  async createMicrocycle(microcycle: Omit<Microcycle, 'id' | 'createdAt' | 'updatedAt'>): Promise<Microcycle> {\n    const result = await this.db\n      .insertInto('microcycles')\n      .values({\n        id: uuidv4(),\n        clientId: microcycle.clientId,\n        absoluteWeek: microcycle.absoluteWeek,\n        days: microcycle.days,\n        description: microcycle.description,\n        isDeload: microcycle.isDeload,\n        message: microcycle.message,\n        structured: microcycle.structured ? JSON.stringify(microcycle.structured) : null,\n        startDate: microcycle.startDate,\n        endDate: microcycle.endDate,\n        isActive: microcycle.isActive,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return MicrocycleModel.fromDB(result as any);\n  }\n\n  async getActiveMicrocycle(clientId: string): Promise<Microcycle | null> {\n    const result = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .where('isActive', '=', true)\n      .orderBy('createdAt', 'desc')\n      .executeTakeFirst();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result ? MicrocycleModel.fromDB(result as any) : null;\n  }\n\n  /**\n   * Get microcycle by absolute week number\n   * Queries by clientId + absoluteWeek only (not fitnessPlanId)\n   * Returns most recently updated if duplicates exist\n   */\n  async getMicrocycleByAbsoluteWeek(\n    clientId: string,\n    absoluteWeek: number\n  ): Promise<Microcycle | null> {\n    const result = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .where('absoluteWeek', '=', absoluteWeek)\n      .orderBy('updatedAt', 'desc')\n      .executeTakeFirst();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result ? MicrocycleModel.fromDB(result as any) : null;\n  }\n\n  async deactivatePreviousMicrocycles(clientId: string): Promise<void> {\n    await this.db\n      .updateTable('microcycles')\n      .set({ isActive: false })\n      .where('clientId', '=', clientId)\n      .where('isActive', '=', true)\n      .execute();\n  }\n\n  async updateMicrocycle(id: string, updates: Partial<Omit<Microcycle, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Microcycle | null> {\n    const updateData: Record<string, unknown> = {};\n\n    if (updates.days !== undefined) {\n      updateData.days = updates.days;\n    }\n    if (updates.description !== undefined) {\n      updateData.description = updates.description;\n    }\n    if (updates.isDeload !== undefined) {\n      updateData.isDeload = updates.isDeload;\n    }\n    if (updates.message !== undefined) {\n      updateData.message = updates.message;\n    }\n    if (updates.structured !== undefined) {\n      updateData.structured = updates.structured ? JSON.stringify(updates.structured) : null;\n    }\n    if (updates.isActive !== undefined) {\n      updateData.isActive = updates.isActive;\n    }\n    if (updates.startDate !== undefined) {\n      updateData.startDate = updates.startDate;\n    }\n    if (updates.endDate !== undefined) {\n      updateData.endDate = updates.endDate;\n    }\n    if (updates.absoluteWeek !== undefined) {\n      updateData.absoluteWeek = updates.absoluteWeek;\n    }\n\n    if (Object.keys(updateData).length === 0) {\n      // No updates to perform\n      return this.getMicrocycleById(id);\n    }\n\n    const result = await this.db\n      .updateTable('microcycles')\n      .set({\n        ...updateData,\n        updatedAt: new Date(),\n      })\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirst();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result ? MicrocycleModel.fromDB(result as any) : null;\n  }\n\n  async getMicrocycleById(id: string): Promise<Microcycle | null> {\n    const result = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('id', '=', id)\n      .executeTakeFirst();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result ? MicrocycleModel.fromDB(result as any) : null;\n  }\n\n  async getRecentMicrocycles(clientId: string, limit: number = 5): Promise<Microcycle[]> {\n    const results = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .execute();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return results.map((r) => MicrocycleModel.fromDB(r as any));\n  }\n\n  async deleteMicrocycle(id: string): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom('microcycles')\n      .where('id', '=', id)\n      .executeTakeFirst();\n\n    return result.numDeletedRows > 0;\n  }\n\n  /**\n   * Get all microcycles for a client ordered by absolute week\n   */\n  async getAllMicrocycles(clientId: string): Promise<Microcycle[]> {\n    const results = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .orderBy('absoluteWeek', 'asc')\n      .execute();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return results.map((r) => MicrocycleModel.fromDB(r as any));\n  }\n\n  /**\n   * Get microcycle for a specific date\n   * Used for date-based progress tracking - finds the microcycle that contains the target date\n   * Queries by clientId + date range only (not fitnessPlanId)\n   * Returns most recently updated if duplicates exist\n   */\n  async getMicrocycleByDate(\n    clientId: string,\n    targetDate: Date\n  ): Promise<Microcycle | null> {\n    const result = await this.db\n      .selectFrom('microcycles')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .where('startDate', '<=', targetDate)\n      .where('endDate', '>=', targetDate)\n      .orderBy('updatedAt', 'desc')\n      .executeTakeFirst();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result ? MicrocycleModel.fromDB(result as any) : null;\n  }\n\n}\n","import { MicrocycleRepository } from '@/server/repositories/microcycleRepository';\nimport { postgresDb } from '@/server/connections/postgres/postgres';\nimport { now, startOfWeek, endOfWeek } from '@/shared/utils/date';\nimport { Microcycle, type MicrocycleStructure } from '@/server/models/microcycle';\nimport { FitnessPlan } from '@/server/models/fitnessPlan';\nimport { microcycleAgentService } from '@/server/services/agents/training';\nimport type { UserWithProfile } from '@/server/models/user';\nimport type { ProgressInfo } from './progressService';\nimport { UserService } from '../user/userService';\n\n/**\n * Simplified MicrocycleService\n *\n * Creates and manages microcycles. Now works directly with fitness plan text\n * instead of mesocycle overviews. Uses absoluteWeek and days array.\n */\nexport class MicrocycleService {\n  private static instance: MicrocycleService;\n  private microcycleRepo: MicrocycleRepository;\n  private userService: UserService;\n\n  private constructor() {\n    this.microcycleRepo = new MicrocycleRepository(postgresDb);\n    this.userService = UserService.getInstance();\n  }\n\n  public static getInstance(): MicrocycleService {\n    if (!MicrocycleService.instance) {\n      MicrocycleService.instance = new MicrocycleService();\n    }\n    return MicrocycleService.instance;\n  }\n\n  /**\n   * Get the active microcycle for a client (the one flagged as active in DB)\n   */\n  public async getActiveMicrocycle(clientId: string) {\n    return await this.microcycleRepo.getActiveMicrocycle(clientId);\n  }\n\n  /**\n   * Check if the active microcycle encompasses the current week in the client's timezone\n   */\n  public async isActiveMicrocycleCurrent(clientId: string, timezone: string = 'America/New_York'): Promise<boolean> {\n    const activeMicrocycle = await this.microcycleRepo.getActiveMicrocycle(clientId);\n    if (!activeMicrocycle) {\n      return false;\n    }\n\n    const { startDate: currentWeekStart } = this.calculateWeekDates(timezone);\n    const normalizedCurrentWeekStart = new Date(currentWeekStart);\n    normalizedCurrentWeekStart.setHours(0, 0, 0, 0);\n\n    const activeMicrocycleStart = new Date(activeMicrocycle.startDate);\n    activeMicrocycleStart.setHours(0, 0, 0, 0);\n\n    const activeMicrocycleEnd = new Date(activeMicrocycle.endDate);\n    activeMicrocycleEnd.setHours(0, 0, 0, 0);\n\n    // Check if current week falls within active microcycle's date range\n    return normalizedCurrentWeekStart >= activeMicrocycleStart && normalizedCurrentWeekStart <= activeMicrocycleEnd;\n  }\n\n  /**\n   * Get all microcycles for a client\n   */\n  public async getAllMicrocycles(clientId: string) {\n    return await this.microcycleRepo.getAllMicrocycles(clientId);\n  }\n\n  /**\n   * Get microcycle by absolute week number\n   * Queries by clientId + absoluteWeek only (not fitnessPlanId)\n   */\n  public async getMicrocycleByAbsoluteWeek(\n    clientId: string,\n    absoluteWeek: number\n  ): Promise<Microcycle | null> {\n    return await this.microcycleRepo.getMicrocycleByAbsoluteWeek(clientId, absoluteWeek);\n  }\n\n  /**\n   * Get microcycle for a specific date\n   * Used for date-based progress tracking - finds the microcycle that contains the target date\n   * Queries by clientId + date range only (not fitnessPlanId)\n   */\n  public async getMicrocycleByDate(\n    clientId: string,\n    targetDate: Date\n  ): Promise<Microcycle | null> {\n    return await this.microcycleRepo.getMicrocycleByDate(clientId, targetDate);\n  }\n\n  /**\n   * Get a microcycle by ID\n   */\n  public async getMicrocycleById(microcycleId: string): Promise<Microcycle | null> {\n    return await this.microcycleRepo.getMicrocycleById(microcycleId);\n  }\n\n  /**\n   * Update a microcycle's days array\n   */\n  public async updateMicrocycleDays(\n    microcycleId: string,\n    days: string[]\n  ): Promise<Microcycle | null> {\n    return await this.microcycleRepo.updateMicrocycle(microcycleId, { days });\n  }\n\n  /**\n   * Update a microcycle\n   */\n  public async updateMicrocycle(\n    microcycleId: string,\n    microcycle: Partial<Microcycle>\n  ): Promise<Microcycle | null> {\n    return await this.microcycleRepo.updateMicrocycle(microcycleId, microcycle);\n  }\n\n  /**\n   * Create a new microcycle from progress information\n   * Uses fitness plan text and user profile to generate the week\n   */\n  public async createMicrocycleFromProgress(\n    clientId: string,\n    plan: FitnessPlan,\n    progress: ProgressInfo\n  ): Promise<Microcycle> {\n    // Get user profile for context\n    const user = await this.userService.getUser(clientId);\n    if (!user) {\n      throw new Error(`Client not found: ${clientId}`);\n    }\n\n    // Generate microcycle using AI agent service\n    // Note: fitness plan and isDeload are determined by the agent via context service\n    const { days, description, isDeload, message, structure } = await this.generateMicrocycle(\n      user,\n      progress.absoluteWeek\n    );\n\n    // Create new microcycle\n    const microcycle = await this.microcycleRepo.createMicrocycle({\n      clientId,\n      absoluteWeek: progress.absoluteWeek,\n      days,\n      description,\n      isDeload,\n      message,\n      structured: structure,\n      startDate: progress.weekStartDate,\n      endDate: progress.weekEndDate,\n      isActive: false, // No longer using isActive flag - we query by dates instead\n    });\n\n    console.log(`[MicrocycleService] Created microcycle for client ${clientId}, week ${progress.absoluteWeek} (${progress.weekStartDate.toISOString()} - ${progress.weekEndDate.toISOString()})`);\n    return microcycle;\n  }\n\n  /**\n   * Generate a microcycle using AI agent service\n   * Fitness plan is auto-fetched by context service\n   * The agent determines isDeload based on the plan's Progression Strategy\n   */\n  private async generateMicrocycle(\n    user: UserWithProfile,\n    absoluteWeek: number\n  ): Promise<{\n    days: string[];\n    description: string;\n    isDeload: boolean;\n    message: string;\n    structure?: MicrocycleStructure;\n  }> {\n    try {\n      // Use AI agent service to generate the microcycle\n      const result = await microcycleAgentService.generateMicrocycle(\n        user,\n        absoluteWeek\n      );\n\n      console.log(`[MicrocycleService] Generated microcycle for week ${absoluteWeek}, isDeload=${result.isDeload}`);\n      return result;\n    } catch (error) {\n      console.error('[MicrocycleService] Failed to generate microcycle:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate week dates in a specific timezone\n   */\n  private calculateWeekDates(timezone: string = 'America/New_York'): { startDate: Date; endDate: Date } {\n    const currentDate = now(timezone).toJSDate();\n\n    return {\n      startDate: startOfWeek(currentDate, timezone),\n      endDate: endOfWeek(currentDate, timezone),\n    };\n  }\n\n  /**\n   * Delete a microcycle and all associated workouts\n   * Returns the count of deleted workouts along with success status\n   */\n  public async deleteMicrocycleWithWorkouts(\n    microcycleId: string\n  ): Promise<{ deleted: boolean; deletedWorkoutsCount: number }> {\n    // First, get the microcycle to verify it exists and get clientId\n    const microcycle = await this.microcycleRepo.getMicrocycleById(microcycleId);\n\n    if (!microcycle) {\n      return { deleted: false, deletedWorkoutsCount: 0 };\n    }\n\n    // Import workoutInstanceService dynamically to avoid circular dependency\n    const { workoutInstanceService } = await import('./workoutInstanceService');\n\n    // Get all workouts for this microcycle\n    const workouts = await workoutInstanceService.getWorkoutsByMicrocycle(\n      microcycle.clientId,\n      microcycleId\n    );\n\n    // Delete all associated workouts first\n    let deletedWorkoutsCount = 0;\n    for (const workout of workouts) {\n      const deleted = await workoutInstanceService.deleteWorkout(workout.id, microcycle.clientId);\n      if (deleted) {\n        deletedWorkoutsCount++;\n      }\n    }\n\n    // Then delete the microcycle\n    const deleted = await this.microcycleRepo.deleteMicrocycle(microcycleId);\n\n    return { deleted, deletedWorkoutsCount };\n  }\n}\n\n// Export singleton instance\nexport const microcycleService = MicrocycleService.getInstance();\n","import { BaseRepository } from './baseRepository';\nimport { ShortLink, NewShortLink } from '../models/shortLink';\nimport { sql } from 'kysely';\n\n/**\n * Repository for managing short links\n * Handles storage, retrieval, and cleanup of short link mappings\n */\nexport class ShortLinkRepository extends BaseRepository {\n  /**\n   * Generate a random 5-character alphanumeric code\n   * Uses uppercase, lowercase, and numbers (62 possible characters)\n   */\n  generateUniqueCode(): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let code = '';\n    for (let i = 0; i < 5; i++) {\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n  }\n\n  /**\n   * Create a new short link\n   * Uses upsert strategy: if code already exists, overwrites with new link\n   */\n  async createShortLink(link: NewShortLink): Promise<ShortLink> {\n    const result = await this.db\n      .insertInto('shortLinks')\n      .values({\n        code: link.code,\n        targetPath: link.targetPath,\n        clientId: link.clientId,\n        expiresAt: link.expiresAt,\n        createdAt: new Date(),\n        accessCount: 0,\n      })\n      .onConflict((oc) =>\n        oc.column('code').doUpdateSet({\n          targetPath: link.targetPath,\n          clientId: link.clientId,\n          expiresAt: link.expiresAt,\n          createdAt: new Date(),\n          accessCount: 0,\n          lastAccessedAt: null,\n        })\n      )\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Find a short link by code\n   * Returns the link if found, null otherwise\n   */\n  async findByCode(code: string): Promise<ShortLink | null> {\n    const result = await this.db\n      .selectFrom('shortLinks')\n      .selectAll()\n      .where('code', '=', code)\n      .executeTakeFirst();\n\n    return result || null;\n  }\n\n  /**\n   * Increment access count and update last accessed time\n   * Called when a short link is resolved\n   */\n  async incrementAccessCount(id: string): Promise<void> {\n    await this.db\n      .updateTable('shortLinks')\n      .set({\n        accessCount: sql`access_count + 1`,\n        lastAccessedAt: new Date(),\n      })\n      .where('id', '=', id)\n      .execute();\n  }\n\n  /**\n   * Delete expired short links\n   * Should be run periodically to clean up the database\n   */\n  async deleteExpiredLinks(): Promise<number> {\n    const result = await this.db\n      .deleteFrom('shortLinks')\n      .where('expiresAt', '<', new Date())\n      .where('expiresAt', 'is not', null)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows || 0);\n  }\n\n  /**\n   * Delete all short links for a client\n   * Useful for cleanup when a client is deleted\n   */\n  async deleteByClientId(clientId: string): Promise<number> {\n    const result = await this.db\n      .deleteFrom('shortLinks')\n      .where('clientId', '=', clientId)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows || 0);\n  }\n\n  /**\n   * Find all short links for a client\n   * Useful for admin views or user dashboards\n   */\n  async findByClientId(clientId: string): Promise<ShortLink[]> {\n    return await this.db\n      .selectFrom('shortLinks')\n      .selectAll()\n      .where('clientId', '=', clientId)\n      .orderBy('createdAt', 'desc')\n      .execute();\n  }\n}\n","import { ShortLinkRepository } from '@/server/repositories/shortLinkRepository';\nimport { ShortLink, CreateShortLinkOptions, ResolvedShortLink } from '@/server/models/shortLink';\nimport { getShortLinksConfig } from '@/shared/config';\n\n/**\n * Service for managing short links\n * Provides business logic for creating, resolving, and managing short links\n */\nexport class ShortLinkService {\n  private static instance: ShortLinkService;\n  private repository: ShortLinkRepository;\n\n  // Default expiration from config\n  private readonly DEFAULT_EXPIRY_DAYS = getShortLinksConfig().defaultExpiryDays;\n\n  private constructor() {\n    this.repository = new ShortLinkRepository();\n  }\n\n  public static getInstance(): ShortLinkService {\n    if (!ShortLinkService.instance) {\n      ShortLinkService.instance = new ShortLinkService();\n    }\n    return ShortLinkService.instance;\n  }\n\n  /**\n   * Create a short link\n   * Generates a unique code and stores the mapping\n   *\n   * @param clientId - Client ID to associate with the link\n   * @param targetPath - Path to redirect to (e.g., /me/program/workouts/123)\n   * @param options - Optional configuration (custom code, expiration)\n   * @returns The created short link\n   */\n  async createShortLink(\n    clientId: string,\n    targetPath: string,\n    options?: CreateShortLinkOptions\n  ): Promise<ShortLink> {\n    // Generate or use provided code\n    const code = options?.code || this.repository.generateUniqueCode();\n\n    // Calculate expiration date\n    const expiresAt =\n      options?.expiresAt ||\n      new Date(Date.now() + this.DEFAULT_EXPIRY_DAYS * 24 * 60 * 60 * 1000);\n\n    // Create the link (will upsert if code already exists)\n    const link = await this.repository.createShortLink({\n      code,\n      targetPath,\n      clientId,\n      expiresAt,\n    });\n\n    console.log(`[ShortLinkService] Created short link: ${code} -> ${targetPath}`);\n    return link;\n  }\n\n  /**\n   * Resolve a short link by code\n   * Returns the link and whether it's expired\n   * Increments access count if link is valid\n   *\n   * @param code - The short link code to resolve\n   * @returns ResolvedShortLink with link and expiration status, or null if not found\n   */\n  async resolveShortLink(code: string): Promise<ResolvedShortLink | null> {\n    const link = await this.repository.findByCode(code);\n\n    if (!link) {\n      console.log(`[ShortLinkService] Short link not found: ${code}`);\n      return null;\n    }\n\n    // Check if expired\n    const isExpired =\n      link.expiresAt !== null && new Date(link.expiresAt) < new Date();\n\n    if (isExpired) {\n      console.log(`[ShortLinkService] Short link expired: ${code}`);\n      return { link, isExpired: true };\n    }\n\n    // Increment access count asynchronously (don't wait)\n    this.repository.incrementAccessCount(link.id).catch((err) => {\n      console.error(`[ShortLinkService] Failed to increment access count for ${code}:`, err);\n    });\n\n    console.log(`[ShortLinkService] Resolved short link: ${code} -> ${link.targetPath}`);\n    return { link, isExpired: false };\n  }\n\n  /**\n   * Create a short link for a workout\n   * Convenience method for workout links\n   *\n   * @param userId - User ID\n   * @param workoutId - Workout ID\n   * @param options - Optional configuration\n   * @returns The created short link\n   */\n  async createWorkoutLink(\n    userId: string,\n    workoutId: string,\n    options?: CreateShortLinkOptions\n  ): Promise<ShortLink> {\n    const targetPath = `/me?workout=${workoutId}`;\n    return this.createShortLink(userId, targetPath, options);\n  }\n\n  /**\n   * Create a short link for a user's profile\n   * Convenience method for profile links\n   *\n   * @param userId - User ID\n   * @param options - Optional configuration\n   * @returns The created short link\n   */\n  async createProfileLink(\n    userId: string,\n    options?: CreateShortLinkOptions\n  ): Promise<ShortLink> {\n    const targetPath = '/me';\n    return this.createShortLink(userId, targetPath, options);\n  }\n\n  /**\n   * Get the full URL for a short link code\n   * Uses SHORT_LINK_DOMAIN environment variable\n   *\n   * @param code - The short link code\n   * @returns Full URL (e.g., https://gtxt.ai/l/aSxc2)\n   */\n  getFullUrl(code: string): string {\n    const domain = getShortLinksConfig().domain || 'https://gtxt.ai';\n    return `${domain}/l/${code}`;\n  }\n\n  /**\n   * Clean up expired short links\n   * Should be run periodically via cron job\n   *\n   * @returns Number of deleted links\n   */\n  async cleanupExpiredLinks(): Promise<number> {\n    try {\n      const deletedCount = await this.repository.deleteExpiredLinks();\n      console.log(`[ShortLinkService] Cleaned up ${deletedCount} expired short links`);\n      return deletedCount;\n    } catch (error) {\n      console.error('[ShortLinkService] Error cleaning up expired links:', error);\n      return 0;\n    }\n  }\n}\n\n// Export singleton instance\nexport const shortLinkService = ShortLinkService.getInstance();\n","/**\n * Microcycle Formatting Utilities\n *\n * Pure functions for formatting microcycle data into string representations\n * for use in prompts, messages, and other contexts.\n */\n\nimport type { MicrocyclePattern } from '@/server/models/microcycle';\n\n/**\n * Simple day input with day name and content\n */\ninterface DayInput {\n  day: string;    // Day name (e.g., \"MONDAY\")\n  content: string; // Day overview content\n}\n\n/**\n * Format a microcycle day into a string representation\n *\n * @param day - Day object with name and content\n * @returns Formatted string with day details\n */\nexport function formatMicrocycleDay(day: DayInput): string {\n  return `Day: ${day.day}\\n${day.content}`;\n}\n\n/**\n * Format all days of a microcycle into a summary\n *\n * @param days - Array of 7 day overview strings\n * @returns Formatted multi-line string with all days\n */\nexport function formatMicrocycleDays(days: string[]): string {\n  const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n\n  return days.map((content, index) => {\n    const dayName = dayNames[index] || `Day ${index + 1}`;\n    return `## ${dayName}\\n${content}`;\n  }).join('\\n\\n');\n}\n\n/**\n * Format a full microcycle pattern into a readable overview\n *\n * @param pattern - Complete microcycle pattern\n * @returns Formatted overview string\n */\nexport function formatMicrocyclePattern(pattern: MicrocyclePattern): string {\n  const sections: string[] = [];\n\n  // Overview\n  sections.push(`# Weekly Overview\\n${pattern.overview}`);\n\n  // Deload indicator\n  if (pattern.isDeload) {\n    sections.push('**Note: This is a DELOAD week**');\n  }\n\n  // Days\n  sections.push(formatMicrocycleDays(pattern.days));\n\n  return sections.join('\\n\\n');\n}\n","/**\n * Fitness Profile Formatting Utilities\n *\n * Pure functions for formatting user fitness profile data into string representations\n * for use in prompts, messages, and other contexts.\n */\n\nimport type { UserWithProfile } from \"@/server/models/user\";\n\n/**\n * Format a user's fitness profile into a structured string representation\n *\n * Returns the markdown profile with basic user demographics prepended.\n *\n * @param user - User object with profile data\n * @returns Formatted multi-line string with all available profile details\n *\n * @example\n * ```typescript\n * const formatted = formatFitnessProfile(user);\n * // Returns:\n * // CLIENT: John Doe\n * // AGE: 32\n * //\n * // [markdown profile content]\n * ```\n */\nexport function formatFitnessProfile(user: UserWithProfile): string {\n  const headerParts: string[] = [];\n\n  // Basic demographics - always include\n  headerParts.push(`CLIENT: ${user.name}`);\n  if (user.age) headerParts.push(`AGE: ${user.age}`);\n  if (user.gender) headerParts.push(`GENDER: ${user.gender}`);\n\n  const header = headerParts.join(' | ');\n\n  // Return minimal info if no profile\n  if (!user.profile) {\n    return header + '\\n\\nSTATUS: No fitness profile available';\n  }\n\n  // Return header + profile\n  return header + '\\n\\n' + user.profile;\n}\n","/**\n * Text Formatting Utilities\n *\n * Utilities for formatting and normalizing text content.\n */\n\n/**\n * Normalizes whitespace in text by:\n * - Replacing 2+ consecutive blank lines with a single blank line\n * - Trimming leading/trailing whitespace\n *\n * @param text - The text to normalize\n * @returns The normalized text\n */\nexport function normalizeWhitespace(text: string): string {\n  return text\n    .replace(/\\n{3,}/g, '\\n\\n') // Replace 3+ newlines with 2 (one blank line)\n    .trim();\n}\n"],"names":[],"mappings":"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"}