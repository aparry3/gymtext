module.exports=[806788,e=>{"use strict";let t,r;var n,s=e.i(553573),i=e.i(163459),a=e.i(342845),o=e.i(904973),l=e.i(818385),d=e.i(588303),u=e.i(583020),c=e.i(304941),g=e.i(370312),h=e.i(40504),p=e.i(802579),y=e.i(225915),f=e.i(150373),v=e.i(804342),m=e.i(259207),w=e.i(348684),S=e.i(193695);e.i(650048);var b=e.i(219407),k=e.i(58880),E=e.i(429459),I=e.i(693757),K=e.i(519930),R=e.i(84853),_=e.i(628424),P=e.i(506057),C=e.i(401608),x=e.i(879449),O=e.i(625941),U=e.i(335820);e.i(322093);var $=class{timings={};start(e,t){this.timings[e]||(this.timings[e]={description:t??"",timers:[]});let r=this.timings[e].timers.push({start:Date.now()})-1;return()=>{let t=this.timings[e];if(!t)return console.warn(`Timing "${e}" does not exist`);let n=t.timers[r];if(!n)return console.warn(`Timer ${r} for timing "${e}" does not exist`);n.end=Date.now()}}append(e,t){this.timings[e]={description:t,timers:[]}}async wrap(e,t,r){let n=this.start(e,r);try{return await (0,U.runAsPromise)(t)}finally{n()}}getHeader(){return Object.entries(this.timings).reduce((e,[t,{description:r,timers:n}])=>{if(!n.some(e=>e.end))return e;let s=n.reduce((e,{start:t,end:r})=>t&&r?e+(r-t):e,0);return[...e,[t,r?`desc="${r}"`:"",s?`dur=${s}`:""].filter(Boolean).join(";")]},[]).join(", ")}},T=e.i(250585);e.i(454188);var q=e.i(331612);let F=q.z.object({status:q.z.number().default(200),skipped:q.z.boolean().optional().default(!1),modified:q.z.boolean().optional().default(!1),error:q.z.string().default("Successfully registered")});var D=class{id;handler;inngestRegisterUrl;frameworkName;signingKey;signingKeyFallback;_mode;fetch;_serveHost;_servePath;logLevel;streaming;rawFns;client;fns={};env=(0,k.allProcessEnv)();allowExpiredSignatures;_options;skipSignatureValidation;constructor(e){if(this._options=e,Object.hasOwn(e,"eventKey"))throw Error(`${E.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);this.frameworkName=e.frameworkName,this.client=e.client,e.id&&console.warn(`${E.logPrefix} The \`id\` serve option is deprecated and will be removed in v4`),this.id=e.id||this.client.id,this.handler=e.handler,this.allowExpiredSignatures=!!arguments[0]?.__testingAllowExpiredSignatures,this.rawFns=e.functions.filter(Boolean),this.rawFns.length!==e.functions.length&&console.warn("Some functions passed to serve() are undefined and misconfigured.  Please check your imports."),this.fns=this.rawFns.reduce((e,t)=>{let r=t.getConfig({baseUrl:new URL("https://example.com"),appPrefix:this.id}),n=r.reduce((e,{id:r},n)=>({...e,[r]:{fn:t,onFailure:!!n}}),{});return r.forEach(({id:t})=>{if(e[t])throw Error(`Duplicate function ID "${t}"; please change a function's name or provide an explicit ID to avoid conflicts.`)}),{...e,...n}},{}),this.inngestRegisterUrl=new URL("/fn/register",this.apiBaseUrl),this.signingKey=e.signingKey,this.signingKeyFallback=e.signingKeyFallback,this._serveHost=e.serveHost||this.env[E.envKeys.InngestServeHost],this._servePath=e.servePath||this.env[E.envKeys.InngestServePath],this.skipSignatureValidation=e.skipSignatureValidation||!1;const t="info";this.logLevel=q.z.enum(P.logLevels).default(t).catch(e=>(this.log("warn",`Unknown log level passed: ${String(e.input)}; defaulting to ${t}`),t)).parse(e.logLevel||this.env[E.envKeys.InngestLogLevel]),"debug"===this.logLevel&&T.default.enable&&"function"==typeof T.default.enable&&T.default.enable(`${E.debugPrefix}:*`),this.streaming=q.z.union([q.z.enum(["allow","force"]),q.z.literal(!1)]).default(!1).catch(e=>(this.log("warn",`Unknown streaming option passed: ${String(e.input)}; defaulting to ${String(!1)}`),!1)).parse(e.streaming||this.env[E.envKeys.InngestStreaming]),this.fetch=e.fetch?(0,k.getFetch)(e.fetch):this.client.fetch}get apiBaseUrl(){return this._options.baseUrl||this.env[E.envKeys.InngestApiBaseUrl]||this.env[E.envKeys.InngestBaseUrl]||this.client.apiBaseUrl||E.defaultInngestApiBaseUrl}get eventApiBaseUrl(){return this._options.baseUrl||this.env[E.envKeys.InngestEventApiBaseUrl]||this.env[E.envKeys.InngestBaseUrl]||this.client.eventBaseUrl||E.defaultInngestEventBaseUrl}get serveHost(){return this._serveHost||this.env[E.envKeys.InngestServeHost]}get servePath(){return this._servePath||this.env[E.envKeys.InngestServePath]}get hashedEventKey(){if(this.client.eventKey&&this.client.eventKey!==E.dummyEventKey)return(0,K.hashEventKey)(this.client.eventKey)}get hashedSigningKey(){if(this.signingKey)return(0,K.hashSigningKey)(this.signingKey)}get hashedSigningKeyFallback(){if(this.signingKeyFallback)return(0,K.hashSigningKey)(this.signingKeyFallback)}async shouldStream(e){return await e.queryStringWithDefaults("testing for probe",E.queryKeys.Probe)===void 0&&!!e.transformStreamingResponse&&("force"===this.streaming||"allow"===this.streaming&&(0,k.platformSupportsStreaming)(this.frameworkName,this.env))}createHandler(){let e=async(...e)=>{let t=new $,r=e[e.length-1],n="object"==typeof r&&null!==r&&"actionOverrides"in r&&"object"==typeof r.actionOverrides&&null!==r.actionOverrides?r.actionOverrides:{},s={...Object.entries({...await t.wrap("handler",()=>this.handler(...e)).catch((0,_.rethrowError)("Serve handler failed to run")),...n}).reduce((e,[t,r])=>"function"!=typeof r?e:{...e,[t]:(e,...n)=>{let s=[`Failed calling \`${t}\` from serve handler`,e].filter(Boolean).join(" when ");return(0,U.runAsPromise)(()=>r(...n)).catch((0,_.rethrowError)(s)).catch(e=>{throw this.log("error",e),e})}},{}),queryStringWithDefaults:async(e,t)=>{let r=await s.url(e);return await s.queryString?.(e,t,r)||r.searchParams.get(t)||void 0},...n},[i,a]=await Promise.all([s.env?.("starting to handle request"),s.headers("checking expected server kind",E.headerKeys.InngestServerKind)]);this.env={...(0,k.allProcessEnv)(),...i};let o=()=>(0,k.inngestHeaders)({env:this.env,framework:this.frameworkName,client:this.client,expectedServerKind:a||void 0,extras:{"Server-Timing":t.getHeader()}}),l=(0,k.getMode)({env:this.env,client:this.client});if(l.isExplicit)this._mode=l;else{let e=await s.isProduction?.("starting to handle request");"boolean"==typeof e?this._mode=new k.Mode({type:e?"cloud":"dev",isExplicit:!1}):this._mode=l}this.upsertKeysFromEnv();let d=s.method("starting to handle request"),u=[E.headerKeys.TraceParent,E.headerKeys.TraceState].map(async e=>{let t=await s.headers(`fetching ${e} for forwarding`,e);return{header:e,value:t}}),c=await s.headers("checking signature for request",E.headerKeys.ContentLength).then(e=>{if(e)return Number.parseInt(e,10)}),[g,h,p]=await Promise.all([s.headers("checking signature for request",E.headerKeys.Signature).then(e=>e??void 0),d,d.then(e=>"POST"===e||"PUT"===e?c?s.body(`checking body for request signing as method is ${e}`):"":"")]),y=this.validateSignature(g,p),f=Promise.all(u).then(e=>e.reduce((e,{header:t,value:r})=>(r&&(e[t]=r),e),{})),v=t.wrap("action",()=>this.handleAction({actions:s,timer:t,getInngestHeaders:o,reqArgs:e,signatureValidation:y,body:p,method:h,headers:f})),m=async e=>{let t,r={...o(),...await f,...e.headers,...null===e.version?{}:{[E.headerKeys.RequestVersion]:(e.version??C.PREFERRED_EXECUTION_VERSION).toString()}};try{t=await y.then(t=>{if(t.success&&t.keyUsed)return this.getResponseSignature(t.keyUsed,e.body)})}catch(t){return{...e,headers:r,body:(0,K.stringify)((0,_.serializeError)(t)),status:500}}return t&&(r[E.headerKeys.Signature]=t),{...e,headers:r}};if(await this.shouldStream(s)&&await s.method("starting streaming response")==="POST"){var w;let e,r,n,i,{stream:a,finalize:l}=await (r=new Promise(t=>{e=t}),n=w?.interval??3e3,i=w?.value??" ",new Promise(async(t,s)=>{try{let s=new ReadableStream({start(t){let r=new TextEncoder,s=setInterval(()=>{t.enqueue(r.encode(i))},n);e(e=>{clearInterval(s),Promise.resolve(e).then(e=>{t.enqueue(r.encode((0,K.stringify)(e))),t.close()})})}});t({stream:s,finalize:await r})}catch(e){s(e)}}));return v.then(e=>l(m(e))),t.wrap("res",()=>s.transformStreamingResponse?.("starting streaming response",{status:201,headers:o(),body:a,version:null}))}return t.wrap("res",async()=>v.then(m).then(e=>s.transformResponse("sending back response",e)))};return Object.defineProperties(e,{name:{value:"InngestHandler"},length:{value:this.handler.length}}),e}get mode(){return this._mode}set mode(e){this._mode=e,e&&(this.client.mode=e)}async handleAction({actions:e,timer:t,getInngestHeaders:r,reqArgs:n,signatureValidation:s,body:i,method:a,headers:o}){let l=void 0===i;try{let d=await e.url("starting to handle request");if("POST"===a){if(l)return this.log("error","Missing body when executing, possibly due to missing request body middleware"),{status:500,headers:{"Content-Type":"application/json"},body:(0,K.stringify)((0,_.serializeError)(Error("Missing request body when executing, possibly due to missing request body middleware"))),version:void 0};let r=await s;if(!r.success)return{status:401,headers:{"Content-Type":"application/json"},body:(0,K.stringify)((0,_.serializeError)(r.err)),version:void 0};let a=await e.queryStringWithDefaults("testing for probe",E.queryKeys.Probe);if(a){let e=((e,t)=>{if(Object.values(e).includes(t))return t})(E.probe,a);if(!e)return{status:400,headers:{"Content-Type":"application/json"},body:(0,K.stringify)((0,_.serializeError)(Error(`Unknown probe "${a}"`))),version:void 0};return({[E.probe.Trust]:()=>({status:200,headers:{"Content-Type":"application/json"},body:"",version:void 0})})[e]()}let d=await e.queryStringWithDefaults("processing run request",E.queryKeys.FnId);if(!d)throw Error("No function ID found in request");let u=await e.queryStringWithDefaults("processing run request",E.queryKeys.StepId)||null,{version:c,result:g}=this.runStep({functionId:d,data:i,stepId:u,timer:t,reqArgs:n,headers:await o}),h=await g,p=e=>(e.data=(0,x.undefinedToNull)(e.data),e),y={"function-rejected":e=>({status:e.retriable?500:400,headers:{"Content-Type":"application/json",[E.headerKeys.NoRetry]:e.retriable?"false":"true",..."string"==typeof e.retriable?{[E.headerKeys.RetryAfter]:e.retriable}:{}},body:(0,K.stringify)((0,x.undefinedToNull)(e.error)),version:c}),"function-resolved":e=>({status:200,headers:{"Content-Type":"application/json"},body:(0,K.stringify)((0,x.undefinedToNull)(e.data)),version:c}),"step-not-found":e=>({status:500,headers:{"Content-Type":"application/json",[E.headerKeys.NoRetry]:"false"},body:(0,K.stringify)({error:`Could not find step "${e.step.displayName||e.step.id}" to run; timed out`}),version:c}),"step-ran":e=>{let t=p(e.step);return{status:206,headers:{"Content-Type":"application/json",...void 0!==e.retriable?{[E.headerKeys.NoRetry]:e.retriable?"false":"true",..."string"==typeof e.retriable?{[E.headerKeys.RetryAfter]:e.retriable}:{}}:{}},body:(0,K.stringify)([t]),version:c}},"steps-found":e=>{let t=e.steps.map(p);return{status:206,headers:{"Content-Type":"application/json"},body:(0,K.stringify)(t),version:c}}}[h.type];try{return await y(h)}catch(e){throw this.log("error","Error handling execution result",e),e}}let u=r()[E.headerKeys.Environment]??null;if("GET"===a)return{status:200,body:(0,K.stringify)(await this.introspectionBody({actions:e,env:u,signatureValidation:s,url:d})),headers:{"Content-Type":"application/json"},version:void 0};if("PUT"===a){let[t,n]=await Promise.all([e.queryStringWithDefaults("processing deployment request",E.queryKeys.DeployId).then(e=>"undefined"===e?void 0:e),Promise.resolve((0,k.parseAsBoolean)(this.env[E.envKeys.InngestAllowInBandSync])).then(t=>void 0===t||t?e.headers("processing deployment request",E.headerKeys.InngestSyncKind):E.syncKind.OutOfBand).then(e=>e===E.syncKind.InBand)]);if(n){if(l)return this.log("error","Missing body when syncing, possibly due to missing request body middleware"),{status:500,headers:{"Content-Type":"application/json"},body:(0,K.stringify)((0,_.serializeError)(Error("Missing request body when syncing, possibly due to missing request body middleware"))),version:void 0};if(!(await s).success)return{status:401,body:(0,K.stringify)({code:"sig_verification_failed"}),headers:{"Content-Type":"application/json"},version:void 0};let r=P.inBandSyncRequestBodySchema.safeParse(i);if(!r.success)return{status:400,body:(0,K.stringify)({code:"invalid_request",message:r.error.message}),headers:{"Content-Type":"application/json"},version:void 0};d=this.reqUrl(new URL(r.data.url));let n=await this.inBandRegisterBody({actions:e,deployId:t,env:u,signatureValidation:s,url:d});return{status:200,body:(0,K.stringify)(n),headers:{"Content-Type":"application/json",[E.headerKeys.InngestSyncKind]:E.syncKind.InBand},version:void 0}}let{status:a,message:o,modified:c}=await this.register(this.reqUrl(d),t,r);return{status:a,body:(0,K.stringify)({message:o,modified:c}),headers:{"Content-Type":"application/json",[E.headerKeys.InngestSyncKind]:E.syncKind.OutOfBand},version:void 0}}}catch(e){return{status:500,body:(0,K.stringify)({type:"internal",...(0,_.serializeError)(e)}),headers:{"Content-Type":"application/json"},version:void 0}}return{status:405,body:JSON.stringify({message:"No action found; request was likely not POST, PUT, or GET",mode:this._mode}),headers:{},version:void 0}}runStep({functionId:e,stepId:t,data:r,timer:n,reqArgs:s,headers:i}){let a=this.fns[e];if(!a)throw Error(`Could not find function with ID "${e}"`);let o=(0,x.parseFnData)(r),{version:l}=o;l===E.ExecutionVersion.V1&&a.fn.shouldOptimizeParallelism?.()&&(l=E.ExecutionVersion.V2);let d=(0,U.runAsPromise)(async()=>{let e=await (0,x.fetchAllFnData)({data:o,api:this.client.inngestApi,version:l});if(!e.ok)throw Error(e.error);let r=await ({[E.ExecutionVersion.V0]:({event:e,events:r,steps:o,ctx:l,version:d})=>{let u=Object.entries(o??{}).reduce((e,[t,r])=>({...e,[t]:{id:t,data:r}}),{});return{version:d,partialOptions:{client:this.client,runId:l?.run_id||"",data:{event:e,events:r,runId:l?.run_id||"",attempt:l?.attempt??0},stepState:u,requestedRunStep:"step"===t?void 0:t||void 0,timer:n,isFailureHandler:a.onFailure,stepCompletionOrder:l?.stack?.stack??[],reqArgs:s,headers:i}}},[E.ExecutionVersion.V1]:({event:e,events:r,steps:o,ctx:l,version:d})=>{let u=Object.entries(o??{}).reduce((e,[t,r])=>({...e,[t]:"data"===r.type?{id:t,data:r.data}:"input"===r.type?{id:t,input:r.input}:{id:t,error:r.error}}),{});return{version:d,partialOptions:{client:this.client,runId:l?.run_id||"",data:{event:e,events:r,runId:l?.run_id||"",attempt:l?.attempt??0,maxAttempts:l?.max_attempts},stepState:u,requestedRunStep:"step"===t?void 0:t||void 0,timer:n,isFailureHandler:a.onFailure,disableImmediateExecution:l?.disable_immediate_execution,stepCompletionOrder:l?.stack?.stack??[],reqArgs:s,headers:i}}},[E.ExecutionVersion.V2]:({event:e,events:r,steps:o,ctx:l,version:d})=>{let u=Object.entries(o??{}).reduce((e,[t,r])=>({...e,[t]:"data"===r.type?{id:t,data:r.data}:"input"===r.type?{id:t,input:r.input}:{id:t,error:r.error}}),{});return{version:d,partialOptions:{client:this.client,runId:l?.run_id||"",data:{event:e,events:r,runId:l?.run_id||"",attempt:l?.attempt??0,maxAttempts:l?.max_attempts},stepState:u,requestedRunStep:"step"===t?void 0:t||void 0,timer:n,isFailureHandler:a.onFailure,disableImmediateExecution:l?.disable_immediate_execution,stepCompletionOrder:l?.stack?.stack??[],reqArgs:s,headers:i}}}})[l](e.value);return a.fn.createExecution(r).start()});return{version:l,result:d}}configs(e){let t=Object.values(this.rawFns).reduce((t,r)=>[...t,...r.getConfig({baseUrl:e,appPrefix:this.id})],[]);for(let e of t){let t=P.functionConfigSchema.safeParse(e);if(!t.success){let r=t.error.errors.map(e=>e.message).join("; ");this.log("warn",`Config invalid for function "${e.id}" : ${r}`)}}return t}reqUrl(e){let t=new URL(e),r=this.serveHost||this.env[E.envKeys.InngestServeHost],n=this.servePath||this.env[E.envKeys.InngestServePath];return n&&(t.pathname=n),r&&(t=new URL(t.pathname+t.search,r)),t}registerBody({url:e,deployId:t}){return{url:e.href,deployType:"ping",framework:this.frameworkName,appName:this.id,functions:this.configs(e),sdk:`js:v${I.version}`,v:"0.1",deployId:t||void 0,capabilities:{trust_probe:"v1",connect:"v1"},appVersion:this.client.appVersion}}async inBandRegisterBody({actions:e,deployId:t,env:r,signatureValidation:n,url:s}){let i=this.registerBody({deployId:t,url:s}),a=await this.introspectionBody({actions:e,env:r,signatureValidation:n,url:s}),o={app_id:this.id,appVersion:this.client.appVersion,capabilities:i.capabilities,env:r,framework:i.framework,functions:i.functions,inspection:a,platform:(0,k.getPlatformName)({...(0,k.allProcessEnv)(),...this.env}),sdk_author:"inngest",sdk_language:"",sdk_version:"",sdk:i.sdk,url:i.url};return a.authentication_succeeded&&(o.sdk_language=a.sdk_language,o.sdk_version=a.sdk_version),o}async introspectionBody({actions:e,env:t,signatureValidation:r,url:n}){let s=this.registerBody({url:this.reqUrl(n),deployId:null});if(!this._mode)throw Error("No mode set; cannot introspect without mode");let i={authentication_succeeded:null,extra:{is_mode_explicit:this._mode.isExplicit},has_event_key:this.client.eventKeySet(),has_signing_key:!!this.signingKey,function_count:s.functions.length,mode:this._mode.type,schema_version:"2024-05-24"};if("cloud"===this._mode.type)try{if(!(await r).success)throw Error("Signature validation failed");i={...i,authentication_succeeded:!0,api_origin:this.apiBaseUrl,app_id:this.id,capabilities:{trust_probe:"v1",connect:"v1"},env:t,event_api_origin:this.eventApiBaseUrl,event_key_hash:this.hashedEventKey??null,extra:{...i.extra,is_streaming:await this.shouldStream(e)},framework:this.frameworkName,sdk_language:"js",sdk_version:I.version,serve_origin:this.serveHost??null,serve_path:this.servePath??null,signing_key_fallback_hash:this.hashedSigningKeyFallback??null,signing_key_hash:this.hashedSigningKey??null}}catch{i={...i,authentication_succeeded:!1}}return i}async register(e,t,r){let n,s,i,a,o,l=this.registerBody({url:e,deployId:t}),d=new URL(this.inngestRegisterUrl.href);if(this._mode&&this._mode.isInferred&&this._mode.isDev){let e=(0,k.devServerHost)(this.env);await (0,R.devServerAvailable)(e,this.fetch)&&(d=(0,R.devServerUrl)(e,"/fn/register"))}else this._mode?.explicitDevUrl&&(d=(0,R.devServerUrl)(this._mode.explicitDevUrl.href,"/fn/register"));t&&d.searchParams.set(E.queryKeys.DeployId,t);try{n=await (0,O.fetchWithAuthFallback)({authToken:this.hashedSigningKey,authTokenFallback:this.hashedSigningKeyFallback,fetch:this.fetch,url:d.href,options:{method:"POST",body:(0,K.stringify)(l),headers:{...r(),[E.headerKeys.InngestSyncKind]:E.syncKind.OutOfBand},redirect:"follow"}})}catch(e){return this.log("error",e),{status:500,message:`Failed to register${e instanceof Error?`; ${e.message}`:""}`,modified:!1}}let u=await n.text(),c={};try{c=JSON.parse(u)}catch(t){this.log("warn","Couldn't unpack register response:",t);let e="Failed to register";return t instanceof Error&&(e+=`; ${t.message}`),{status:500,message:e+=`; status code: ${n.status}`,modified:!1}}try{({status:s,error:i,skipped:a,modified:o}=F.parse(c))}catch(t){this.log("warn","Invalid register response schema:",t);let e="Failed to register";return t instanceof Error&&(e+=`; ${t.message}`),{status:500,message:e+=`; status code: ${n.status}`,modified:!1}}return a||this.log("debug","registered inngest functions:",n.status,n.statusText,c),{status:s,message:i,modified:o}}upsertKeysFromEnv(){this.env[E.envKeys.InngestSigningKey]&&(this.signingKey||(this.signingKey=String(this.env[E.envKeys.InngestSigningKey])),this.client.inngestApi.setSigningKey(this.signingKey)),this.env[E.envKeys.InngestSigningKeyFallback]&&(this.signingKeyFallback||(this.signingKeyFallback=String(this.env[E.envKeys.InngestSigningKeyFallback])),this.client.inngestApi.setSigningKeyFallback(this.signingKeyFallback)),!this.client.eventKeySet()&&this.env[E.envKeys.InngestEventKey]&&this.client.setEventKey(String(this.env[E.envKeys.InngestEventKey])),this.env[E.envKeys.InngestDevServerUrl]&&this.log("warn",`Use of ${E.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${E.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`)}async validateSignature(e,t){try{if(this.skipSignatureValidation||this._mode&&!this._mode.isCloud)return{success:!0,keyUsed:""};if(!this.signingKey)throw Error(`No signing key found in client options or ${E.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);if(!e)throw Error(`No ${E.headerKeys.Signature} provided`);return{success:!0,keyUsed:new A(e).verifySignature({body:t,allowExpiredSignatures:this.allowExpiredSignatures,signingKey:this.signingKey,signingKeyFallback:this.signingKeyFallback})}}catch(e){return{success:!1,err:e}}}getResponseSignature(e,t){let r=Date.now(),n=(0,O.signDataWithKey)(t,e,r.toString());return`t=${r}&s=${n}`}log(e,...t){let r=["debug","info","warn","error","fatal","silent"],n=r.indexOf(this.logLevel);if(r.indexOf(e)>=n){let r=console.log;Object.hasOwn(console,e)&&(r=console[e]),r(`${E.logPrefix} ${e} -`,...t)}}},A=class{timestamp;signature;constructor(e){const t=new URLSearchParams(e);if(this.timestamp=t.get("t")||"",this.signature=t.get("s")||"",!this.timestamp||!this.signature)throw Error(`Invalid ${E.headerKeys.Signature} provided`)}hasExpired(e){return!e&&Date.now()-new Date(1e3*Number.parseInt(this.timestamp)).valueOf()>3e5}#e({body:e,signingKey:t,allowExpiredSignatures:r}){if(this.hasExpired(r))throw Error("Signature has expired");if((0,O.signDataWithKey)(e,t,this.timestamp)!==this.signature)throw Error("Invalid signature")}verifySignature({body:e,signingKey:t,signingKeyFallback:r,allowExpiredSignatures:n}){try{return this.#e({body:e,signingKey:t,allowExpiredSignatures:n}),t}catch(t){if(!r)throw t;return this.#e({body:e,signingKey:r,allowExpiredSignatures:n}),r}}},M=e.i(187070);e.i(180256);var N=e.i(80643),j=e.i(11206),B=e.i(565431);let H=M.inngest.createFunction({id:"process-message",name:"Process Inbound Message",retries:3,debounce:{period:"10s",key:"event.data.userId"}},{event:"message/received"},async({event:e,step:t})=>{let{userId:r}=e.data,n=await t.run("generate-response",async()=>{console.log("[Inngest] Loading user and generating response:",r);let e=await B.userService.getUser(r);if(!e)throw Error(`User ${r} not found`);let t=await j.ChatService.handleIncomingMessage(e);return console.log("[Inngest] Response(s) generated, count:",t.length),t});if(!n||0===n.length)return{success:!0,messageIds:[],messageCount:0};let s=await t.run("send-messages",async()=>{console.log("[Inngest] Loading user and sending messages:",r);let e=await B.userService.getUser(r);if(!e)throw Error(`User ${r} not found`);let t=[];for(let r of n){let n=await N.messageService.sendMessage(e,r);t.push(n)}return t});return console.log("[Inngest] Message processing complete:",{userId:r,messageCount:s.length,messageIds:s.map(e=>e.id)}),{success:!0,messageIds:s.map(e=>e.id),messageCount:s.length}});var L=e.i(172709);let V=M.inngest.createFunction({id:"send-daily-workout",name:"Send Daily Workout Message",retries:3},{event:"workout/scheduled"},async({event:e,step:t})=>{let{userId:r,targetDate:n}=e.data,s=await t.run("send-daily-workout",async()=>{console.log("[Inngest] Sending daily workout:",{userId:r,targetDate:n});let e=await B.userService.getUser(r);if(!e)throw Error(`User ${r} not found`);let t=await L.dailyMessageService.sendDailyMessage(e);return console.log("[Inngest] Daily workout sent:",{userId:r,success:t.success,messageId:t.messageId}),t});if(!s.success)throw Error(`Failed to send daily workout: ${s.error}`);return{success:!0,userId:r,messageId:s.messageId,targetDate:n}});var z=e.i(534821);let W=M.inngest.createFunction({id:"send-weekly-message",name:"Send Weekly Check-in Message",retries:3},{event:"weekly/scheduled"},async({event:e,step:t})=>{let{userId:r}=e.data,n=await t.run("send-weekly-message",async()=>{console.log("[Inngest] Sending weekly message:",{userId:r});let e=await B.userService.getUser(r);if(!e)throw Error(`User ${r} not found`);let t=await z.weeklyMessageService.sendWeeklyMessage(e);return console.log("[Inngest] Weekly message sent:",{userId:r,success:t.success,messageIds:t.messageIds}),t});if(!n.success)throw Error(`Failed to send weekly message: ${n.error}`);return{success:!0,userId:r,messageIds:n.messageIds}});var G=e.i(23250),Q=e.i(306312),J=e.i(201236),X=e.i(108436),Y=e.i(125720),Z=e.i(994766),ee=e.i(823525);let et={async loadData(e){console.log(`[Onboarding] Step 1: Loading user and signup data for ${e}`);let t=await B.userService.getUser(e);if(!t)throw Error(`User ${e} not found`);let r=await G.onboardingDataService.getSignupData(e);if(!r)throw Error(`No signup data found for user ${e}`);return{user:t,signupData:r}},async getOrCreateProfile(e,t,r=!1){if(!r&&await Q.fitnessProfileService.getCurrentProfile(e.id))return console.log(`[Onboarding] Step 2: Profile already exists for ${e.id}`),{user:e,wasCreated:!1};console.log(`[Onboarding] Step 2: Creating profile for ${e.id} (LLM)${r?" [forceCreate]":""}`),await Q.fitnessProfileService.createFitnessProfile(e,t);let n=await B.userService.getUser(e.id);if(!n)throw Error(`User ${e.id} not found after profile creation`);return{user:n,wasCreated:!0}},async getOrCreatePlan(e,t=!1){if(!t){let t=await J.fitnessPlanService.getCurrentPlan(e.id);if(t)return console.log(`[Onboarding] Step 3: Plan already exists for ${e.id}`),{plan:t,wasCreated:!1}}return console.log(`[Onboarding] Step 3: Creating plan for ${e.id} (LLM)${t?" [forceCreate]":""}`),{plan:await J.fitnessPlanService.createFitnessPlan(e),wasCreated:!0}},async getOrCreateMicrocycle(e,t,r=!1){let n=(0,ee.now)(e.timezone).toJSDate(),{microcycle:s,wasCreated:i}=await X.progressService.getOrCreateMicrocycleForDate(e.id,t,n,e.timezone,r);if(!s)throw Error(`Could not get/create microcycle for user ${e.id}`);return console.log(`[Onboarding] Step 4: Microcycle ${i?"created":"already exists"} for ${e.id}${r?" [forceCreate]":""}`),{microcycle:s,wasCreated:i}},async getOrCreateWorkout(e,t,r=!1){let n=(0,ee.now)(e.timezone).startOf("day");if(!r){let t=await Y.workoutInstanceService.getWorkoutByUserIdAndDate(e.id,n.toJSDate());if(t)return console.log(`[Onboarding] Step 5: Workout already exists for ${e.id}`),{workout:t,wasCreated:!1}}console.log(`[Onboarding] Step 5: Creating workout for ${e.id} (LLM)${r?" [forceCreate]":""}`);let s=await Y.workoutInstanceService.generateWorkoutForDate(e,n,t);if(!s)throw Error(`Failed to generate workout for user ${e.id}`);return{workout:s,wasCreated:!0}},async markCompleted(e){console.log(`[Onboarding] Step 6: Marking onboarding as completed for ${e}`),await G.onboardingDataService.markCompleted(e)},async sendMessages(e){console.log(`[Onboarding] Step 7: Sending onboarding messages for ${e}`);try{let t=await Z.onboardingCoordinator.sendOnboardingMessages(e);return t?console.log(`[Onboarding] Onboarding messages sent to ${e}`):console.log(`[Onboarding] Waiting for payment to complete for ${e}`),t}catch(t){return console.error(`[Onboarding] Failed to send messages for ${e}:`,t),!1}}},er=M.inngest.createFunction({id:"onboard-user",name:"Onboard New User",retries:2},{event:"user/onboarding.requested"},async({event:e,step:t})=>{let{userId:r,forceCreate:n=!1}=e.data;try{await t.run("mark-started",()=>G.onboardingDataService.markStarted(r));let{user:e,signupData:s}=await t.run("step-1-load-data",()=>et.loadData(r)),{user:i}=await t.run("step-2-profile",()=>et.getOrCreateProfile(e,s,n)),{plan:a}=await t.run("step-3-plan",()=>et.getOrCreatePlan(i,n)),{microcycle:o}=await t.run("step-4-microcycle",()=>et.getOrCreateMicrocycle(i,a,n));await t.run("step-5-workout",()=>et.getOrCreateWorkout(i,o,n)),await t.run("step-6-complete",()=>et.markCompleted(r));let l=await t.run("step-7-messages",()=>et.sendMessages(r));return console.log(`[Inngest] Onboarding complete for user ${r}`),{success:!0,userId:r,messagesSent:l}}catch(e){console.error(`[Inngest] Onboarding failed for user ${r}:`,e);try{await G.onboardingDataService.updateStatus(r,"failed",e instanceof Error?e.message:"Unknown error during onboarding")}catch(e){console.error(`[Inngest] Failed to update onboarding status for ${r}:`,e)}throw e}});var en=e.i(38330);let es=M.inngest.createFunction({id:"process-next-queued-message",name:"Process Next Queued Message",retries:2},{event:"message-queue/process-next"},async({event:e,step:t})=>{let{clientId:r,queueName:n}=e.data;return await t.run("process-next-message",async()=>{console.log("[Inngest] Processing next queued message:",{clientId:r,queueName:n}),await en.messageQueueService.processNextMessage(r,n)}),{success:!0,clientId:r,queueName:n}}),ei=M.inngest.createFunction({id:"send-queued-message",name:"Send Queued Message",retries:3},{event:"message-queue/send-message"},async({event:e,step:t})=>{let{queueEntryId:r,clientId:n,queueName:s}=e.data;return{success:!0,messageId:(await t.run("send-message",async()=>(console.log("[Inngest] Sending queued message:",{queueEntryId:r,clientId:n,queueName:s}),await en.messageQueueService.sendQueuedMessage(r)))).id,queueEntryId:r}});e.i(46308),e.i(986904),e.i(297934);var ea=e.i(501261);e.i(670864),e.i(840936),e.i(517670),e.i(881640),e.i(961691),e.i(13423),e.i(221078),e.i(649815),e.i(94510),e.i(52396),e.i(166194),e.i(139765),e.i(310752),e.i(332062),e.i(650654),e.i(733897),e.i(968387);var eo=e.i(363690),el=e.i(36480);let ed=[0,300,1800],eu=M.inngest.createFunction({id:"retry-failed-message",name:"Retry Failed Message Delivery",retries:0},{event:"message/delivery-failed"},async({event:e,step:t})=>{let{messageId:r,userId:n,error:s}=e.data;console.log("[Inngest Retry] Starting retry process:",{messageId:r,userId:n,error:s});let i=await t.run("check-message",async()=>{let e=new ea.MessageRepository(el.postgresDb),t=await e.findById(r);if(!t)throw Error(`Message ${r} not found`);let n=t.deliveryAttempts||1;return console.log("[Inngest Retry] Message check:",{messageId:r,attempts:n,maxAttempts:4}),{message:t,attempts:n,shouldRetry:n<4}});if(!i.shouldRetry)return console.error("[Inngest Retry] Max attempts reached, giving up:",{messageId:r,attempts:i.attempts,maxAttempts:4}),{success:!1,reason:"max_attempts_reached",attempts:i.attempts};let a=i.attempts,o=a-1;if(o>0&&o<ed.length){let e=ed[o];if(e>0){let n=new Date(Date.now()+1e3*e);console.log("[Inngest Retry] Sleeping before retry:",{messageId:r,attempt:a,delaySeconds:e,resumeAt:n.toISOString()}),await t.sleepUntil("wait-before-retry",n),console.log("[Inngest Retry] Resuming after sleep:",{messageId:r,attempt:a})}}return await t.run("retry-send-message",async()=>{let e=new ea.MessageRepository(el.postgresDb),t=await B.userService.getUser(n);if(!t)throw Error(`User ${n} not found`);let s=i.message;console.log("[Inngest Retry] Retrying message send:",{messageId:r,userId:n,attempt:a+1});try{let n=await eo.messagingClient.sendMessage(t,s.content);return await e.incrementDeliveryAttempts(r),n.messageId&&await e.updateProviderMessageId(r,n.messageId),await e.updateDeliveryStatus(r,"queued"),console.log("[Inngest Retry] Message retry successful:",{messageId:r,providerMessageId:n.messageId,attempt:a+1}),{success:!0,providerMessageId:n.messageId,attempt:a+1}}catch(n){console.error("[Inngest Retry] Retry send failed:",{messageId:r,attempt:a+1,error:n}),await e.incrementDeliveryAttempts(r);let t=n instanceof Error?n.message:"Unknown error";throw await e.updateDeliveryStatus(r,"failed",t),n}})}),{GET:ec,POST:eg,PUT:eh}=(Object.defineProperty(r=(t=new D({frameworkName:"nextjs",...n={client:M.inngest,functions:[H,eu,V,W,er,es,ei]},handler:(e,...t)=>{let[r,s]=t,i=e=>{let t="function"==typeof r.headers.get?r.headers.get(e):r.headers[e];return Array.isArray(t)?t[0]:t};return{body:()=>"function"==typeof r.json?r.json():r.body,headers:i,method:()=>e||r.method||"",isProduction:()=>{try{return!0}catch(e){}},queryString:(e,t)=>{let n=r.query?.[e]||t.searchParams.get(e);return Array.isArray(n)?n[0]:n},url:()=>{let e;try{e=new URL(r.url)}catch{}if(e){let t=n.serveHost||i("host");if(t){let r=new URL(t.includes("://")?t:`${e.protocol}//${t}`);e.protocol=r.protocol,e.host=r.host,e.port=r.port,e.username=r.username,e.password=r.password}return e}let t=n.serveHost||i("host")||"";return new URL(r.url,`https://${t}`)},transformResponse:({body:e,headers:t,status:r})=>{if((e=>"object"==typeof e&&null!==e&&"function"==typeof e.setHeader&&"function"==typeof e.status&&"function"==typeof e.send)(s)){for(let[e,r]of Object.entries(t))s.setHeader(e,r);s.status(r),s.send(e);return}return new((0,k.getResponse)())(e,{status:r,headers:t})},transformStreamingResponse:({body:e,headers:t,status:r})=>new Response(e,{status:r,headers:t})}}}).createHandler()).bind(null,void 0),"length",{value:1}),Object.defineProperties(r,{GET:{value:t.bind(null,"GET")},POST:{value:t.bind(null,"POST")},PUT:{value:t.bind(null,"PUT")}}));e.s(["GET",0,ec,"POST",0,eg,"PUT",0,eh],415451);var ep=e.i(415451);let ey=new s.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/inngest/route",pathname:"/api/inngest",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/apps/web/src/app/api/inngest/route.ts",nextConfigOutput:"",userland:ep}),{workAsyncStorage:ef,workUnitAsyncStorage:ev,serverHooks:em}=ey;function ew(){return(0,a.patchFetch)({workAsyncStorage:ef,workUnitAsyncStorage:ev})}async function eS(e,t,r){ey.isDev&&(0,o.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let n="/api/inngest/route";n=n.replace(/\/index$/,"")||"/";let s=await ey.prepare(e,t,{srcPage:n,multiZoneDraftMode:!1});if(!s)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:a,params:k,nextConfig:E,parsedUrl:I,isDraftMode:K,prerenderManifest:R,routerServerContext:_,isOnDemandRevalidate:P,revalidateOnlyGenerated:C,resolvedPathname:x,clientReferenceManifest:O,serverActionsManifest:U}=s,$=(0,c.normalizeAppPath)(n),T=!!(R.dynamicRoutes[$]||R.routes[x]),q=async()=>((null==_?void 0:_.render404)?await _.render404(e,t,I,!1):t.end("This page could not be found"),null);if(T&&!K){let e=!!R.routes[x],t=R.dynamicRoutes[$];if(t&&!1===t.fallback&&!e){if(E.experimental.adapterPath)return await q();throw new S.NoFallbackError}}let F=null;!T||ey.isDev||K||(F="/index"===(F=x)?"/":F);let D=!0===ey.isDev||!T,A=T&&!D;U&&O&&(0,d.setReferenceManifestsSingleton)({page:n,clientReferenceManifest:O,serverActionsManifest:U,serverModuleMap:(0,u.createServerModuleMap)({serverActionsManifest:U})});let M=e.method||"GET",N=(0,l.getTracer)(),j=N.getActiveScopeSpan(),B={params:k,prerenderManifest:R,renderOpts:{experimental:{authInterrupts:!!E.experimental.authInterrupts},cacheComponents:!!E.cacheComponents,supportsDynamicResponse:D,incrementalCache:(0,o.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:E.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,n)=>ey.onRequestError(e,t,n,_)},sharedContext:{buildId:a}},H=new g.NodeNextRequest(e),L=new g.NodeNextResponse(t),V=h.NextRequestAdapter.fromNodeNextRequest(H,(0,h.signalFromNodeResponse)(t));try{let s=async e=>ey.handle(V,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=N.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==p.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let s=r.get("next.route");if(s){let t=`${M} ${s}`;e.setAttributes({"next.route":s,"http.route":s,"next.span_name":t}),e.updateName(t)}else e.updateName(`${M} ${n}`)}),a=!!(0,o.getRequestMeta)(e,"minimalMode"),d=async o=>{var l,d;let u=async({previousCacheEntry:i})=>{try{if(!a&&P&&C&&!i)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await s(o);e.fetchMetrics=B.renderOpts.fetchMetrics;let l=B.renderOpts.pendingWaitUntil;l&&r.waitUntil&&(r.waitUntil(l),l=void 0);let d=B.renderOpts.collectedTags;if(!T)return await (0,f.sendResponse)(H,L,n,B.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,v.toNodeOutgoingHttpHeaders)(n.headers);d&&(t[w.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=w.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,s=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=w.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:b.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:s}}}}catch(t){throw(null==i?void 0:i.isStale)&&await ey.onRequestError(e,t,{routerKind:"App Router",routePath:n,routeType:"route",revalidateReason:(0,y.getRevalidateReason)({isStaticGeneration:A,isOnDemandRevalidate:P})},_),t}},c=await ey.handleResponse({req:e,nextConfig:E,cacheKey:F,routeKind:i.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:R,isRoutePPREnabled:!1,isOnDemandRevalidate:P,revalidateOnlyGenerated:C,responseGenerator:u,waitUntil:r.waitUntil,isMinimalMode:a});if(!T)return null;if((null==c||null==(l=c.value)?void 0:l.kind)!==b.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(d=c.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});a||t.setHeader("x-nextjs-cache",P?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),K&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let g=(0,v.fromNodeOutgoingHttpHeaders)(c.value.headers);return a&&T||g.delete(w.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||g.get("Cache-Control")||g.set("Cache-Control",(0,m.getCacheControlHeader)(c.cacheControl)),await (0,f.sendResponse)(H,L,new Response(c.value.body,{headers:g,status:c.value.status||200})),null};j?await d(j):await N.withPropagatedContext(e.headers,()=>N.trace(p.BaseServerSpan.handleRequest,{spanName:`${M} ${n}`,kind:l.SpanKind.SERVER,attributes:{"http.method":M,"http.target":e.url}},d))}catch(t){if(t instanceof S.NoFallbackError||await ey.onRequestError(e,t,{routerKind:"App Router",routePath:$,routeType:"route",revalidateReason:(0,y.getRevalidateReason)({isStaticGeneration:A,isOnDemandRevalidate:P})}),T)throw t;return await (0,f.sendResponse)(H,L,new Response(null,{status:500})),null}}e.s(["handler",()=>eS,"patchFetch",()=>ew,"routeModule",()=>ey,"serverHooks",()=>em,"workAsyncStorage",()=>ef,"workUnitAsyncStorage",()=>ev],806788)}];

//# sourceMappingURL=708d8_next_dist_esm_build_templates_app-route_7e5e0ad5.js.map