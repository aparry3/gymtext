{"version":3,"sources":["../../../../../node_modules/.pnpm/next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/dist/esm/build/templates/app-route.js","../../../../../packages/shared/src/server/repositories/index.ts","../../../../../node_modules/.pnpm/inngest%403.44.2_next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1_aqryshwx65ukc2vlnvytyvdbs4/node_modules/src/helpers/enum.ts","../../../../../node_modules/.pnpm/next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/src/build/templates/app-route.ts","../../../../../node_modules/.pnpm/inngest%403.44.2_next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1_aqryshwx65ukc2vlnvytyvdbs4/node_modules/src/next.ts","../../../../../node_modules/.pnpm/inngest%403.44.2_next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1_aqryshwx65ukc2vlnvytyvdbs4/node_modules/src/helpers/stream.ts","../../../../../node_modules/.pnpm/inngest%403.44.2_next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1_aqryshwx65ukc2vlnvytyvdbs4/node_modules/src/helpers/ServerTiming.ts","../../../../../packages/shared/src/server/inngest/functions/processQueuedMessage.ts","../../../../../packages/shared/src/server/inngest/functions/processMessage.ts","../../../../../packages/shared/src/server/inngest/functions/sendDailyWorkout.ts","../../../../../packages/shared/src/server/inngest/functions/sendWeeklyMessage.ts","../../../../../packages/shared/src/server/inngest/functions/retryMessage.ts","../../../../../node_modules/.pnpm/inngest%403.44.2_next%4016.0.7_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1_aqryshwx65ukc2vlnvytyvdbs4/node_modules/src/components/InngestCommHandler.ts","../../../../../packages/shared/src/server/services/orchestration/onboardingSteps.ts","../../../../../apps/web/src/app/api/inngest/route.ts","../../../../../packages/shared/src/server/inngest/functions/onboardUser.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/inngest/route\",\n        pathname: \"/api/inngest\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/apps/web/src/app/api/inngest/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/inngest/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","// Base repository\nexport * from './baseRepository';\n\n// Repository factory (for environment context)\nexport * from './factory';\n\n// Individual repositories\nexport * from './userRepository';\nexport * from './messageRepository';\nexport * from './profileRepository';\nexport * from './fitnessPlanRepository';\nexport * from './workoutInstanceRepository';\nexport * from './microcycleRepository';\nexport * from './subscriptionRepository';\nexport * from './onboardingRepository';\nexport * from './promptRepository';\nexport * from './dayConfigRepository';\nexport * from './messageQueueRepository';\nexport * from './shortLinkRepository';\nexport * from './referralRepository';\nexport * from './pageVisitRepository';\nexport * from './adminActivityLogRepository';\nexport * from './uploadedImageRepository';\nexport * from './profileUpdateRepository';\nexport * from './userAuthRepository';","/**\n * Returns the value of an enum from a string value.\n *\n * If the value given is not a value from the enum, `undefined` is returned.\n */\nexport const enumFromValue = <T extends Record<string, unknown>>(\n  enumType: T,\n  value: unknown,\n): T[keyof T] | undefined => {\n  if (Object.values(enumType).includes(value)) {\n    return value as T[keyof T];\n  }\n\n  return;\n};\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","/**\n * An adapter for Next.js to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @module\n */\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport type { NextRequest } from \"next/server\";\nimport {\n  InngestCommHandler,\n  type ServeHandlerOptions,\n} from \"./components/InngestCommHandler.ts\";\nimport { getResponse } from \"./helpers/env.ts\";\nimport type { Either } from \"./helpers/types.ts\";\nimport type { SupportedFrameworkName } from \"./types.ts\";\n\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexport const frameworkName: SupportedFrameworkName = \"nextjs\";\n\n/**\n * The shape of a request handler, supporting Next.js 12+.\n *\n * We are intentionally abstract with the arguments here, as Next.js's type\n * checking when building varies wildly between major versions; specifying\n * different types (even optional types) here can cause issues with the build.\n *\n * This change was initially made for Next.js 15, which specifies the second\n * argument as `RouteContext`, whereas Next.js 13 and 14 omit it and Next.js 12\n * provides a `NextApiResponse`, which is varies based on the execution\n * environment used (edge vs serverless).\n */\nexport type RequestHandler = (\n  expectedReq: NextRequest,\n  res: unknown,\n) => Promise<Response>;\n\nconst isRecord = (val: unknown): val is Record<string, unknown> => {\n  return typeof val === \"object\" && val !== null;\n};\n\nconst isFunction = (val: unknown): val is (...args: unknown[]) => unknown => {\n  return typeof val === \"function\";\n};\n\nconst isNext12ApiResponse = (val: unknown): val is NextApiResponse => {\n  return (\n    isRecord(val) &&\n    isFunction(val.setHeader) &&\n    isFunction(val.status) &&\n    isFunction(val.send)\n  );\n};\n\n/**\n * In Next.js, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nexport const serve = (\n  options: ServeHandlerOptions,\n): RequestHandler & {\n  GET: RequestHandler;\n  POST: RequestHandler;\n  PUT: RequestHandler;\n} => {\n  const handler = new InngestCommHandler({\n    frameworkName,\n    ...options,\n    handler: (\n      reqMethod: \"GET\" | \"POST\" | \"PUT\" | undefined,\n      ...args: Parameters<RequestHandler>\n    ) => {\n      const [expectedReq, res] = args;\n      const req = expectedReq as Either<NextApiRequest, NextRequest>;\n\n      const getHeader = (key: string): string | null | undefined => {\n        const header =\n          typeof req.headers.get === \"function\"\n            ? req.headers.get(key)\n            : req.headers[key];\n\n        return Array.isArray(header) ? header[0] : header;\n      };\n\n      return {\n        body: () => (typeof req.json === \"function\" ? req.json() : req.body),\n        headers: getHeader,\n        method: () => {\n          /**\n           * `req.method`, though types say otherwise, is not available in Next.js\n           * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.\n           *\n           * Therefore, we must try to set the method ourselves where we know it.\n           */\n          const method = reqMethod || req.method || \"\";\n          return method;\n        },\n        isProduction: () => {\n          /**\n           * Vercel Edge Functions do not allow dynamic access to environment\n           * variables, so we'll manage production checks directly here.\n           *\n           * We try/catch to avoid situations where Next.js is being used in\n           * environments where `process.env` is not accessible or polyfilled.\n           */\n          try {\n            const isProd = process.env.NODE_ENV === \"production\";\n            return isProd;\n          } catch (_err) {\n            // no-op\n          }\n\n          return;\n        },\n        queryString: (key, url) => {\n          const qs = req.query?.[key] || url.searchParams.get(key);\n          return Array.isArray(qs) ? qs[0] : qs;\n        },\n\n        url: () => {\n          let absoluteUrl: URL | undefined;\n          try {\n            absoluteUrl = new URL(req.url as string);\n          } catch {\n            // no-op\n          }\n\n          if (absoluteUrl) {\n            /**\n             * `req.url` here should may be the full URL, including query string.\n             * There are some caveats, however, where Next.js will obfuscate\n             * the host. For example, in the case of `host.docker.internal`,\n             * Next.js will instead set the host here to `localhost`.\n             *\n             * To avoid this, we'll try to parse the URL from `req.url`, but\n             * also use the `host` header if it's available.\n             */\n            const host = options.serveHost || getHeader(\"host\");\n            if (host) {\n              const hostWithProtocol = new URL(\n                host.includes(\"://\")\n                  ? host\n                  : `${absoluteUrl.protocol}//${host}`,\n              );\n\n              absoluteUrl.protocol = hostWithProtocol.protocol;\n              absoluteUrl.host = hostWithProtocol.host;\n              absoluteUrl.port = hostWithProtocol.port;\n              absoluteUrl.username = hostWithProtocol.username;\n              absoluteUrl.password = hostWithProtocol.password;\n            }\n\n            return absoluteUrl;\n          }\n\n          let scheme: \"http\" | \"https\" = \"https\";\n          const host = options.serveHost || getHeader(\"host\") || \"\";\n\n          try {\n            if (process.env.NODE_ENV === \"development\") {\n              scheme = \"http\";\n            }\n          } catch (_err) {\n            // no-op\n          }\n\n          const url = new URL(req.url as string, `${scheme}://${host}`);\n\n          return url;\n        },\n        transformResponse: ({ body, headers, status }): Response => {\n          /**\n           * Carefully attempt to set headers and data on the response object\n           * for Next.js 12 support.\n           *\n           * This also assumes that we're not using Next.js 15, where the `res`\n           * object is repopulated as a `RouteContext` object. We expect these\n           * methods to NOT be defined in Next.js 15.\n           *\n           * We could likely use `instanceof ServerResponse` to better check the\n           * type of this, though Next.js 12 had issues with this due to not\n           * instantiating the response correctly.\n           */\n          if (isNext12ApiResponse(res)) {\n            for (const [key, value] of Object.entries(headers)) {\n              res.setHeader(key, value);\n            }\n\n            res.status(status);\n            res.send(body);\n\n            /**\n             * If we're here, we're in a serverless endpoint (not edge), so\n             * we've correctly sent the response and can return `undefined`.\n             *\n             * Next.js 13 edge requires that the return value is typed as\n             * `Response`, so we still enforce that as we cannot dynamically\n             * adjust typing based on the environment.\n             */\n            return undefined as unknown as Response;\n          }\n\n          /**\n           * If we're here, we're in an edge environment and need to return a\n           * `Response` object.\n           *\n           * We also don't know if the current environment has a native\n           * `Response` object, so we'll grab that first.\n           */\n          const Res = getResponse();\n          return new Res(body, { status, headers });\n        },\n        transformStreamingResponse: ({ body, headers, status }) => {\n          return new Response(body, { status, headers });\n        },\n      };\n    },\n  });\n\n  /**\n   * Next.js 13 uses\n   * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n   * to declare API routes instead of a generic catch-all method that was\n   * available using the `pages/api` directory.\n   *\n   * This means that users must now export a function for each method supported\n   * by the endpoint. For us, this means requiring a user explicitly exports\n   * `GET`, `POST`, and `PUT` functions.\n   *\n   * Because of this, we'll add circular references to those property names of\n   * the returned handler, meaning we can write some succinct code to export\n   * them. Thanks, @goodoldneon.\n   *\n   * @example\n   * ```ts\n   * export const { GET, POST, PUT } = serve(...);\n   * ```\n   *\n   * See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n   */\n  const baseFn = handler.createHandler();\n\n  const fn = baseFn.bind(null, undefined);\n\n  /**\n   * Ensure we have a non-variadic length to avoid issues with forced type\n   * checking.\n   */\n  Object.defineProperty(fn, \"length\", { value: 1 });\n\n  type Fn = typeof fn;\n\n  const handlerFn = Object.defineProperties(fn, {\n    GET: { value: baseFn.bind(null, \"GET\") },\n    POST: { value: baseFn.bind(null, \"POST\") },\n    PUT: { value: baseFn.bind(null, \"PUT\") },\n  }) as Fn & {\n    GET: Fn;\n    POST: Fn;\n    PUT: Fn;\n  };\n\n  return handlerFn;\n};\n","import { stringify } from \"./strings.ts\";\n\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nexport const createStream = (opts?: {\n  /**\n   * The interval in milliseconds to send a heartbeat.\n   *\n   * Defaults to `3000`.\n   */\n  interval?: number;\n\n  /**\n   * The value to send as a heartbeat.\n   *\n   * Defaults to `\" \"`.\n   */\n  value?: string;\n}): Promise<{ finalize: (data: unknown) => void; stream: ReadableStream }> => {\n  /**\n   * We need to resolve this promise with both the stream and the `finalize`\n   * function, but having them both instantiated synchronously is difficult, as\n   * we need access to the stream's internals too.\n   *\n   * We create this cheeky deferred promise to grab the internal `finalize`\n   * value. Be warned that simpler solutions may appear to compile, but fail at\n   * runtime due to variables not being assigned; make sure to test your code!\n   */\n  let passFinalize: (value: (data: unknown) => void) => void;\n\n  const finalizeP = new Promise<(data: unknown) => void>((resolve) => {\n    passFinalize = resolve;\n  });\n\n  const interval = opts?.interval ?? 3000;\n  const value = opts?.value ?? \" \";\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      const stream = new ReadableStream({\n        start(controller) {\n          const encoder = new TextEncoder();\n\n          const heartbeat = setInterval(() => {\n            controller.enqueue(encoder.encode(value));\n          }, interval);\n\n          const finalize = (data: unknown) => {\n            clearInterval(heartbeat);\n\n            // `data` may be a `Promise`. If it is, we need to wait for it to\n            // resolve before sending it. To support this elegantly we'll always\n            // assume it's a promise and handle that case.\n            void Promise.resolve(data).then((resolvedData) => {\n              controller.enqueue(encoder.encode(stringify(resolvedData)));\n              controller.close();\n            });\n          };\n\n          passFinalize(finalize);\n        },\n      });\n\n      resolve({ stream, finalize: await finalizeP });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n","import { runAsPromise } from \"./promises.ts\";\n\ninterface Timing {\n  description: string;\n  timers: {\n    start?: number;\n    end?: number;\n  }[];\n}\n\n/**\n * A class to manage timing functions and arbitrary periods of time before\n * generating a `Server-Timing` header for use in HTTP responses.\n *\n * This is a very simple implementation that does not support nested timings or\n * fractions of a millisecond.\n */\nexport class ServerTiming {\n  private timings: Record<string, Timing> = {};\n\n  /**\n   * Start a timing. Returns a function that, when called, will stop the timing\n   * and add it to the header.\n   */\n  public start(name: string, description?: string): () => void {\n    if (!this.timings[name]) {\n      this.timings[name] = {\n        description: description ?? \"\",\n        timers: [],\n      };\n    }\n\n    const index = this.timings[name].timers.push({ start: Date.now() }) - 1;\n\n    return (): void => {\n      const target = this.timings[name];\n      if (!target) {\n        return console.warn(`Timing \"${name}\" does not exist`);\n      }\n\n      const timer = target.timers[index];\n      if (!timer) {\n        return console.warn(\n          `Timer ${index} for timing \"${name}\" does not exist`,\n        );\n      }\n\n      timer.end = Date.now();\n    };\n  }\n\n  /**\n   * Add a piece of arbitrary, untimed information to the header. Common use\n   * cases would be cache misses.\n   *\n   * @example\n   * ```\n   * timer.append(\"cache\", \"miss\");\n   * ```\n   */\n  public append(key: string, value: string): void {\n    this.timings[key] = {\n      description: value,\n      timers: [],\n    };\n  }\n\n  /**\n   * Wrap a function in a timing. The timing will be stopped and added to the\n   * header when the function resolves or rejects.\n   *\n   * The return value of the function will be returned from this function.\n   */\n  public async wrap<T extends (...args: unknown[]) => unknown>(\n    name: string,\n    fn: T,\n    description?: string,\n  ): Promise<Awaited<ReturnType<T>>> {\n    const stop = this.start(name, description);\n\n    try {\n      return (await runAsPromise(fn)) as Awaited<ReturnType<T>>;\n    } finally {\n      stop();\n    }\n  }\n\n  /**\n   * Generate the `Server-Timing` header.\n   */\n  public getHeader(): string {\n    const entries = Object.entries(this.timings).reduce<string[]>(\n      (acc, [name, { description, timers }]) => {\n        /**\n         * Ignore timers that had no end.\n         */\n        const hasTimersWithEnd = timers.some((timer) => timer.end);\n        if (!hasTimersWithEnd) {\n          return acc;\n        }\n\n        const dur = timers.reduce((acc, { start, end }) => {\n          if (!start || !end) return acc;\n          return acc + (end - start);\n        }, 0);\n\n        const entry = [\n          name,\n          description ? `desc=\"${description}\"` : \"\",\n          dur ? `dur=${dur}` : \"\",\n        ]\n          .filter(Boolean)\n          .join(\";\");\n\n        return [...acc, entry];\n      },\n      [],\n    );\n\n    return entries.join(\", \");\n  }\n}\n","/**\n * Process Queued Message Function (Inngest)\n *\n * Handles ordered message delivery from message queues.\n * Triggered by queue events to send the next message in sequence.\n *\n * Events:\n * - 'message-queue/process-next': Find and trigger next pending message\n * - 'message-queue/send-message': Send a specific queued message\n *\n * Flow:\n * 1. Receive event with clientId and queueName\n * 2. Load next pending message from queue\n * 3. Send message via MessageQueueService\n * 4. Wait for Twilio webhook to trigger next message\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { messageQueueService } from '@/server/services/messaging/messageQueueService';\n\n/**\n * Process next message in queue\n */\nexport const processNextQueuedMessageFunction = inngest.createFunction(\n  {\n    id: 'process-next-queued-message',\n    name: 'Process Next Queued Message',\n    retries: 2,\n  },\n  { event: 'message-queue/process-next' },\n  async ({ event, step }) => {\n    const { clientId, queueName } = event.data;\n\n    await step.run('process-next-message', async () => {\n      console.log('[Inngest] Processing next queued message:', { clientId, queueName });\n      await messageQueueService.processNextMessage(clientId, queueName);\n    });\n\n    return {\n      success: true,\n      clientId,\n      queueName,\n    };\n  }\n);\n\n/**\n * Send a specific queued message\n */\nexport const sendQueuedMessageFunction = inngest.createFunction(\n  {\n    id: 'send-queued-message',\n    name: 'Send Queued Message',\n    retries: 3,\n  },\n  { event: 'message-queue/send-message' },\n  async ({ event, step }) => {\n    const { queueEntryId, clientId, queueName } = event.data;\n\n    const message = await step.run('send-message', async () => {\n      console.log('[Inngest] Sending queued message:', { queueEntryId, clientId, queueName });\n      return await messageQueueService.sendQueuedMessage(queueEntryId);\n    });\n\n    return {\n      success: true,\n      messageId: message.id,\n      queueEntryId,\n    };\n  }\n);\n","/**\n * Process Message Function (Inngest)\n *\n * Async function that processes inbound messages and generates responses.\n * Triggered by the 'message/received' event from the SMS webhook.\n *\n * Flow:\n * 1. Load user with profile\n * 2. Generate response using ChatService (can be slow)\n * 3. Send response via MessageService\n *\n * Benefits:\n * - Runs async (doesn't block webhook)\n * - Automatic retries on failure\n * - Step-by-step execution tracking\n * - Can send multiple messages over time\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { messageService, ChatService } from '@/server/services';\nimport { userService } from '@/server/services/user/userService';\n\nexport const processMessageFunction = inngest.createFunction(\n  {\n    id: 'process-message',\n    name: 'Process Inbound Message',\n    retries: 3, // Retry up to 3 times on failure\n    debounce: {\n      period: '10s',\n      key: 'event.data.userId',\n    },\n  },\n  { event: 'message/received' },\n  async ({ event, step }) => {\n    const { userId } = event.data;\n\n    // Step 1: Generate response(s) (can be slow - LLM call)\n    // Load user fresh in this step to avoid serialization issues\n    // ChatService handles fetching pending messages and splitting context internally\n    const messages = await step.run('generate-response', async () => {\n      console.log('[Inngest] Loading user and generating response:', userId);\n      const user = await userService.getUser(userId);\n\n      if (!user) {\n        throw new Error(`User ${userId} not found`);\n      }\n\n      // ChatService now handles:\n      // - Fetching recent messages (single DB call)\n      // - Splitting into pending vs context\n      // - Aggregating pending message content\n      // - Early return if no pending messages\n      const chatMessages = await ChatService.handleIncomingMessage(user);\n      console.log('[Inngest] Response(s) generated, count:', chatMessages.length);\n      return chatMessages;\n    });\n\n    // If no messages to send, we're done\n    if (!messages || messages.length === 0) {\n      return {\n        success: true,\n        messageIds: [],\n        messageCount: 0,\n      };\n    }\n\n    // Step 2: Send messages sequentially\n    // Load user fresh again to avoid serialization issues\n    const messageResults = await step.run('send-messages', async () => {\n      console.log('[Inngest] Loading user and sending messages:', userId);\n      const user = await userService.getUser(userId);\n\n      if (!user) {\n        throw new Error(`User ${userId} not found`);\n      }\n\n      // Send each message sequentially\n      const results = [];\n      for (const message of messages) {\n        const result = await messageService.sendMessage(user, message);\n        results.push(result);\n      }\n\n      return results;\n    });\n\n    console.log('[Inngest] Message processing complete:', {\n      userId,\n      messageCount: messageResults.length,\n      messageIds: messageResults.map(r => r.id),\n    });\n\n    return {\n      success: true,\n      messageIds: messageResults.map(r => r.id),\n      messageCount: messageResults.length,\n    };\n  }\n);\n","/**\n * Send Daily Workout Function (Inngest)\n *\n * Async function that generates and sends daily workout messages to users.\n * Triggered by the 'workout/scheduled' event from the cron job.\n *\n * Flow:\n * 1. Load user with profile\n * 2. Generate workout (if needed) and message via DailyMessageService\n * 3. Send message via MessageService\n *\n * Benefits:\n * - Runs async (doesn't block cron)\n * - Automatic retries on failure (3 attempts)\n * - Step-by-step execution tracking\n * - Individual user isolation (one failure doesn't affect others)\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { dailyMessageService } from '@/server/services';\nimport { userService } from '@/server/services/user/userService';\n\nexport const sendDailyWorkoutFunction = inngest.createFunction(\n  {\n    id: 'send-daily-workout',\n    name: 'Send Daily Workout Message',\n    retries: 3, // Retry up to 3 times on failure\n  },\n  { event: 'workout/scheduled' },\n  async ({ event, step }) => {\n    const { userId, targetDate } = event.data;\n\n    // Step 1: Load user and send daily message\n    // This includes workout generation (if needed) and message sending\n    const result = await step.run('send-daily-workout', async () => {\n      console.log('[Inngest] Sending daily workout:', { userId, targetDate });\n\n      const user = await userService.getUser(userId);\n\n      if (!user) {\n        throw new Error(`User ${userId} not found`);\n      }\n\n      // Use the existing DailyMessageService which handles:\n      // 1. Getting or generating today's workout\n      // 2. Generating the message\n      // 3. Sending via MessageService\n      const messageResult = await dailyMessageService.sendDailyMessage(user);\n\n      console.log('[Inngest] Daily workout sent:', {\n        userId,\n        success: messageResult.success,\n        messageId: messageResult.messageId,\n      });\n\n      return messageResult;\n    });\n\n    if (!result.success) {\n      throw new Error(`Failed to send daily workout: ${result.error}`);\n    }\n\n    return {\n      success: true,\n      userId,\n      messageId: result.messageId,\n      targetDate,\n    };\n  }\n);\n","/**\n * Send Weekly Message Function (Inngest)\n *\n * Async function that sends weekly check-in messages to users.\n * Triggered by the 'weekly/scheduled' event from the cron job.\n *\n * Flow:\n * 1. Load user with profile\n * 2. Advance user's progress to next week\n * 3. Generate next week's microcycle pattern\n * 4. Generate and send messages via WeeklyMessageService\n *\n * Benefits:\n * - Runs async (doesn't block cron)\n * - Automatic retries on failure (3 attempts)\n * - Step-by-step execution tracking\n * - Individual user isolation (one failure doesn't affect others)\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { weeklyMessageService } from '@/server/services';\nimport { userService } from '@/server/services/user/userService';\n\nexport const sendWeeklyMessageFunction = inngest.createFunction(\n  {\n    id: 'send-weekly-message',\n    name: 'Send Weekly Check-in Message',\n    retries: 3, // Retry up to 3 times on failure\n  },\n  { event: 'weekly/scheduled' },\n  async ({ event, step }) => {\n    const { userId } = event.data;\n\n    // Step 1: Load user and send weekly message\n    // This includes:\n    // - Advancing progress to next week\n    // - Generating next week's microcycle\n    // - Generating and sending both messages\n    const result = await step.run('send-weekly-message', async () => {\n      console.log('[Inngest] Sending weekly message:', { userId });\n\n      const user = await userService.getUser(userId);\n\n      if (!user) {\n        throw new Error(`User ${userId} not found`);\n      }\n\n      // Use the WeeklyMessageService which handles:\n      // 1. Advancing to next week\n      // 2. Getting/creating next week's microcycle\n      // 3. Checking for mesocycle transitions\n      // 4. Generating messages with AI\n      // 5. Sending both messages\n      const messageResult = await weeklyMessageService.sendWeeklyMessage(user);\n\n      console.log('[Inngest] Weekly message sent:', {\n        userId,\n        success: messageResult.success,\n        messageIds: messageResult.messageIds,\n      });\n\n      return messageResult;\n    });\n\n    if (!result.success) {\n      throw new Error(`Failed to send weekly message: ${result.error}`);\n    }\n\n    return {\n      success: true,\n      userId,\n      messageIds: result.messageIds,\n    };\n  }\n);\n","/**\n * Retry Message Function (Inngest)\n *\n * Async function that retries failed message deliveries with exponential backoff.\n * Triggered by the 'message/delivery-failed' event from the status callback.\n *\n * Flow:\n * 1. Check delivery attempts (max 4)\n * 2. Wait using step.sleepUntil() with backoff (immediate, 5min, 30min)\n * 3. Retry sending the message\n * 4. Increment delivery attempts\n *\n * Benefits:\n * - Non-blocking sleep (no server capacity used)\n * - Custom backoff schedule\n * - Automatic tracking of attempts\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { MessageRepository } from '@/server/repositories';\nimport { userService } from '@/server/services/user/userService';\nimport { messagingClient } from '@/server/connections/messaging';\nimport { postgresDb } from '@/server/connections/postgres/postgres';\n\n// Retry delays in seconds: [immediate, 5min, 30min]\nconst RETRY_DELAYS = [0, 300, 1800];\nconst MAX_ATTEMPTS = 4; // Initial + 3 retries\n\nexport const retryMessageFunction = inngest.createFunction(\n  {\n    id: 'retry-failed-message',\n    name: 'Retry Failed Message Delivery',\n    retries: 0, // We handle retries manually\n  },\n  { event: 'message/delivery-failed' },\n  async ({ event, step }) => {\n    const { messageId, userId, error } = event.data;\n\n    console.log('[Inngest Retry] Starting retry process:', {\n      messageId,\n      userId,\n      error,\n    });\n\n    // Step 1: Load message and check attempts\n    const messageCheck = await step.run('check-message', async () => {\n      const messageRepo = new MessageRepository(postgresDb);\n      const message = await messageRepo.findById(messageId);\n\n      if (!message) {\n        throw new Error(`Message ${messageId} not found`);\n      }\n\n      const attempts = message.deliveryAttempts || 1;\n\n      console.log('[Inngest Retry] Message check:', {\n        messageId,\n        attempts,\n        maxAttempts: MAX_ATTEMPTS,\n      });\n\n      return {\n        message,\n        attempts,\n        shouldRetry: attempts < MAX_ATTEMPTS,\n      };\n    });\n\n    // If max attempts reached, log and exit\n    if (!messageCheck.shouldRetry) {\n      console.error('[Inngest Retry] Max attempts reached, giving up:', {\n        messageId,\n        attempts: messageCheck.attempts,\n        maxAttempts: MAX_ATTEMPTS,\n      });\n\n      return {\n        success: false,\n        reason: 'max_attempts_reached',\n        attempts: messageCheck.attempts,\n      };\n    }\n\n    // Step 2: Wait with backoff (if not first retry)\n    const currentAttempt = messageCheck.attempts;\n    const retryIndex = currentAttempt - 1; // 0-based index for RETRY_DELAYS\n\n    if (retryIndex > 0 && retryIndex < RETRY_DELAYS.length) {\n      const delaySeconds = RETRY_DELAYS[retryIndex];\n\n      if (delaySeconds > 0) {\n        const resumeAt = new Date(Date.now() + delaySeconds * 1000);\n\n        console.log('[Inngest Retry] Sleeping before retry:', {\n          messageId,\n          attempt: currentAttempt,\n          delaySeconds,\n          resumeAt: resumeAt.toISOString(),\n        });\n\n        await step.sleepUntil('wait-before-retry', resumeAt);\n\n        console.log('[Inngest Retry] Resuming after sleep:', {\n          messageId,\n          attempt: currentAttempt,\n        });\n      }\n    }\n\n    // Step 3: Load user and retry sending\n    const retryResult = await step.run('retry-send-message', async () => {\n      const messageRepo = new MessageRepository(postgresDb);\n\n      const user = await userService.getUser(userId);\n      if (!user) {\n        throw new Error(`User ${userId} not found`);\n      }\n\n      const message = messageCheck.message;\n\n      console.log('[Inngest Retry] Retrying message send:', {\n        messageId,\n        userId,\n        attempt: currentAttempt + 1,\n      });\n\n      try {\n        // Retry sending via messaging client\n        const result = await messagingClient.sendMessage(user, message.content);\n\n        // Update message with new provider message ID and increment attempts\n        await messageRepo.incrementDeliveryAttempts(messageId);\n\n        if (result.messageId) {\n          await messageRepo.updateProviderMessageId(messageId, result.messageId);\n        }\n\n        // Update delivery status to queued (will be updated by status callback)\n        await messageRepo.updateDeliveryStatus(messageId, 'queued');\n\n        console.log('[Inngest Retry] Message retry successful:', {\n          messageId,\n          providerMessageId: result.messageId,\n          attempt: currentAttempt + 1,\n        });\n\n        return {\n          success: true,\n          providerMessageId: result.messageId,\n          attempt: currentAttempt + 1,\n        };\n      } catch (error) {\n        console.error('[Inngest Retry] Retry send failed:', {\n          messageId,\n          attempt: currentAttempt + 1,\n          error,\n        });\n\n        // Increment attempts even on failure\n        await messageRepo.incrementDeliveryAttempts(messageId);\n\n        // Update delivery status with error\n        const errorMessage =\n          error instanceof Error ? error.message : 'Unknown error';\n        await messageRepo.updateDeliveryStatus(messageId, 'failed', errorMessage);\n\n        throw error;\n      }\n    });\n\n    return retryResult;\n  }\n);\n","import debug from \"debug\";\nimport { z } from \"zod/v3\";\nimport {\n  debugPrefix,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  dummyEventKey,\n  ExecutionVersion,\n  envKeys,\n  headerKeys,\n  logPrefix,\n  probe as probeEnum,\n  queryKeys,\n  syncKind,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport { enumFromValue } from \"../helpers/enum.ts\";\nimport {\n  allProcessEnv,\n  devServerHost,\n  type Env,\n  getFetch,\n  getMode,\n  getPlatformName,\n  inngestHeaders,\n  Mode,\n  parseAsBoolean,\n  platformSupportsStreaming,\n} from \"../helpers/env.ts\";\nimport { rethrowError, serializeError } from \"../helpers/errors.ts\";\nimport {\n  type FnData,\n  fetchAllFnData,\n  parseFnData,\n  undefinedToNull,\n} from \"../helpers/functions.ts\";\nimport { fetchWithAuthFallback, signDataWithKey } from \"../helpers/net.ts\";\nimport { runAsPromise } from \"../helpers/promises.ts\";\nimport { ServerTiming } from \"../helpers/ServerTiming.ts\";\nimport { createStream } from \"../helpers/stream.ts\";\nimport { hashEventKey, hashSigningKey, stringify } from \"../helpers/strings.ts\";\nimport type { MaybePromise } from \"../helpers/types.ts\";\nimport {\n  type AuthenticatedIntrospection,\n  type EventPayload,\n  type FunctionConfig,\n  functionConfigSchema,\n  type InBandRegisterRequest,\n  inBandSyncRequestBodySchema,\n  type LogLevel,\n  logLevels,\n  type OutgoingOp,\n  type RegisterOptions,\n  type RegisterRequest,\n  type SupportedFrameworkName,\n  type UnauthenticatedIntrospection,\n} from \"../types.ts\";\nimport { version } from \"../version.ts\";\nimport {\n  type ExecutionResult,\n  type ExecutionResultHandler,\n  type ExecutionResultHandlers,\n  type InngestExecutionOptions,\n  PREFERRED_EXECUTION_VERSION,\n} from \"./execution/InngestExecution.ts\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport type {\n  CreateExecutionOptions,\n  InngestFunction,\n} from \"./InngestFunction.ts\";\n\n/**\n * A set of options that can be passed to a serve handler, intended to be used\n * by internal and custom serve handlers to provide a consistent interface.\n *\n * @public\n */\nexport interface ServeHandlerOptions extends RegisterOptions {\n  /**\n   * The `Inngest` instance used to declare all functions.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions: readonly InngestFunction.Like[];\n}\n\nexport interface InternalServeHandlerOptions extends ServeHandlerOptions {\n  /**\n   * Can be used to override the framework name given to a particular serve\n   * handler.\n   */\n  frameworkName?: string;\n}\n\ninterface InngestCommHandlerOptions<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> extends RegisterOptions {\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   *\n   * This should never be defined by the user; a {@link ServeHandler} should\n   * abstract this.\n   */\n  frameworkName: string;\n\n  /**\n   * The name of this serve handler, e.g. `\"My App\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   *\n   * This can also be an `Inngest` client, in which case the name given when\n   * instantiating the client is used. This is useful if you're sending and\n   * receiving events from the same service, as you can reuse a single\n   * definition of Inngest.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions: readonly InngestFunction.Like[];\n\n  /**\n   * The `handler` is the function that will be called with your framework's\n   * request arguments and returns a set of functions that the SDK will use to\n   * access various parts of the request, such as the body, headers, and query\n   * string parameters.\n   *\n   * It also defines how to transform a response from the SDK into a response\n   * that your framework can understand, ensuring headers, status codes, and\n   * body are all set correctly.\n   *\n   * @example\n   * ```ts\n   * function handler (req: Request, res: Response) {\n   *   return {\n   *     method: () => req.method,\n   *     body: () => req.json(),\n   *     headers: (key) => req.headers.get(key),\n   *     url: () => req.url,\n   *     transformResponse: ({ body, headers, status }) => {\n   *       return new Response(body, { status, headers });\n   *     },\n   *   };\n   * };\n   * ```\n   *\n   * See any existing handler for a full example.\n   */\n  handler: Handler<Input, Output, StreamOutput>;\n\n  skipSignatureValidation?: boolean;\n}\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = z.object({\n  status: z.number().default(200),\n  skipped: z.boolean().optional().default(false),\n  modified: z.boolean().optional().default(false),\n  error: z.string().default(\"Successfully registered\"),\n});\n\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nexport class InngestCommHandler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> {\n  /**\n   * The ID of this serve handler, e.g. `\"my-app\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   */\n  public readonly id: string;\n\n  /**\n   * The handler specified during instantiation of the class.\n   */\n  public readonly handler: Handler;\n\n  /**\n   * The URL of the Inngest function registration endpoint.\n   */\n  private readonly inngestRegisterUrl: URL;\n\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   */\n  protected readonly frameworkName: string;\n\n  /**\n   * The signing key used to validate requests from Inngest. This is\n   * intentionally mutable so that we can pick up the signing key from the\n   * environment during execution if needed.\n   */\n  protected signingKey: string | undefined;\n\n  /**\n   * The same as signingKey, except used as a fallback when auth fails using the\n   * primary signing key.\n   */\n  protected signingKeyFallback: string | undefined;\n\n  /**\n   * A property that can be set to indicate whether we believe we are in\n   * production mode.\n   *\n   * Should be set every time a request is received.\n   */\n  protected _mode: Mode | undefined;\n\n  /**\n   * The localized `fetch` implementation used by this handler.\n   */\n  private readonly fetch: FetchT;\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  private readonly _serveHost: string | undefined;\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   */\n  private readonly _servePath: string | undefined;\n\n  /**\n   * The minimum level to log from the Inngest serve handler.\n   */\n  protected readonly logLevel: LogLevel;\n\n  protected readonly streaming: RegisterOptions[\"streaming\"];\n\n  /**\n   * A private collection of just Inngest functions, as they have been passed\n   * when instantiating the class.\n   */\n  private readonly rawFns: InngestFunction.Any[];\n\n  private readonly client: Inngest.Any;\n\n  /**\n   * A private collection of functions that are being served. This map is used\n   * to find and register functions when interacting with Inngest Cloud.\n   */\n  private readonly fns: Record<\n    string,\n    { fn: InngestFunction.Any; onFailure: boolean }\n  > = {};\n\n  private env: Env = allProcessEnv();\n\n  private allowExpiredSignatures: boolean;\n\n  private readonly _options: InngestCommHandlerOptions<\n    Input,\n    Output,\n    StreamOutput\n  >;\n\n  private readonly skipSignatureValidation: boolean;\n\n  constructor(options: InngestCommHandlerOptions<Input, Output, StreamOutput>) {\n    // Set input options directly so we can reference them later\n    this._options = options;\n\n    /**\n     * v2 -> v3 migration error.\n     *\n     * If a serve handler is passed a client as the first argument, it'll be\n     * spread in to these options. We should be able to detect this by picking\n     * up a unique property on the object.\n     */\n    if (Object.hasOwn(options, \"eventKey\")) {\n      throw new Error(\n        `${logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    this.frameworkName = options.frameworkName;\n    this.client = options.client as Inngest.Any;\n\n    if (options.id) {\n      console.warn(\n        `${logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`,\n      );\n    }\n    this.id = options.id || this.client.id;\n\n    this.handler = options.handler as Handler;\n\n    /**\n     * Provide a hidden option to allow expired signatures to be accepted during\n     * testing.\n     */\n    this.allowExpiredSignatures = Boolean(\n      // biome-ignore lint/complexity/noArguments: <explanation>\n      arguments[\"0\"]?.__testingAllowExpiredSignatures,\n    );\n\n    // Ensure we filter any undefined functions in case of missing imports.\n    this.rawFns = options.functions.filter(Boolean) as InngestFunction.Any[];\n\n    if (this.rawFns.length !== options.functions.length) {\n      // TODO PrettyError\n      console.warn(\n        `Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`,\n      );\n    }\n\n    this.fns = this.rawFns.reduce<\n      Record<string, { fn: InngestFunction.Any; onFailure: boolean }>\n    >((acc, fn) => {\n      const configs = fn[\"getConfig\"]({\n        baseUrl: new URL(\"https://example.com\"),\n        appPrefix: this.id,\n      });\n\n      const fns = configs.reduce((acc, { id }, index) => {\n        return { ...acc, [id]: { fn, onFailure: Boolean(index) } };\n      }, {});\n\n      // biome-ignore lint/complexity/noForEach: <explanation>\n      configs.forEach(({ id }) => {\n        if (acc[id]) {\n          // TODO PrettyError\n          throw new Error(\n            `Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`,\n          );\n        }\n      });\n\n      return {\n        ...acc,\n        ...fns,\n      };\n    }, {});\n\n    this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n\n    this.signingKey = options.signingKey;\n    this.signingKeyFallback = options.signingKeyFallback;\n    this._serveHost = options.serveHost || this.env[envKeys.InngestServeHost];\n    this._servePath = options.servePath || this.env[envKeys.InngestServePath];\n\n    this.skipSignatureValidation = options.skipSignatureValidation || false;\n\n    const defaultLogLevel: typeof this.logLevel = \"info\";\n    this.logLevel = z\n      .enum(logLevels)\n      .default(defaultLogLevel)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown log level passed: ${String(\n            ctx.input,\n          )}; defaulting to ${defaultLogLevel}`,\n        );\n\n        return defaultLogLevel;\n      })\n      .parse(options.logLevel || this.env[envKeys.InngestLogLevel]);\n\n    if (this.logLevel === \"debug\") {\n      /**\n       * `debug` is an old library; sometimes its runtime detection doesn't work\n       * for newer pairings of framework/runtime.\n       *\n       * One silly symptom of this is that `Debug()` returns an anonymous\n       * function with no extra properties instead of a `Debugger` instance if\n       * the wrong code is consumed following a bad detection. This results in\n       * the following `.enable()` call failing, so we just try carefully to\n       * enable it here.\n       */\n      if (debug.enable && typeof debug.enable === \"function\") {\n        debug.enable(`${debugPrefix}:*`);\n      }\n    }\n\n    const defaultStreamingOption: typeof this.streaming = false;\n    this.streaming = z\n      .union([z.enum([\"allow\", \"force\"]), z.literal(false)])\n      .default(defaultStreamingOption)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown streaming option passed: ${String(\n            ctx.input,\n          )}; defaulting to ${String(defaultStreamingOption)}`,\n        );\n\n        return defaultStreamingOption;\n      })\n      .parse(options.streaming || this.env[envKeys.InngestStreaming]);\n\n    this.fetch = options.fetch ? getFetch(options.fetch) : this.client[\"fetch\"];\n  }\n\n  /**\n   * Get the API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the API base URL\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get apiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.apiBaseUrl ||\n      defaultInngestApiBaseUrl\n    );\n  }\n\n  /**\n   * Get the event API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the event API\n   * base URL each time it's accessed, as it may change during execution.\n   */\n  protected get eventApiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestEventApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.eventBaseUrl ||\n      defaultInngestEventBaseUrl\n    );\n  }\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  protected get serveHost(): string | undefined {\n    return this._serveHost || this.env[envKeys.InngestServeHost];\n  }\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   *\n   * This is a getter to encourage checking the environment for the serve path\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get servePath(): string | undefined {\n    return this._servePath || this.env[envKeys.InngestServePath];\n  }\n\n  private get hashedEventKey(): string | undefined {\n    if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === dummyEventKey) {\n      return undefined;\n    }\n    return hashEventKey(this.client[\"eventKey\"]);\n  }\n\n  // hashedSigningKey creates a sha256 checksum of the signing key with the\n  // same signing key prefix.\n  private get hashedSigningKey(): string | undefined {\n    if (!this.signingKey) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedSigningKeyFallback(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  /**\n   * Returns a `boolean` representing whether this handler will stream responses\n   * or not. Takes into account the user's preference and the platform's\n   * capabilities.\n   */\n  private async shouldStream(\n    actions: HandlerResponseWithErrors,\n  ): Promise<boolean> {\n    const rawProbe = await actions.queryStringWithDefaults(\n      \"testing for probe\",\n      queryKeys.Probe,\n    );\n    if (rawProbe !== undefined) {\n      return false;\n    }\n\n    // We must be able to stream responses to continue.\n    if (!actions.transformStreamingResponse) {\n      return false;\n    }\n\n    // If the user has forced streaming, we should always stream.\n    if (this.streaming === \"force\") {\n      return true;\n    }\n\n    // If the user has allowed streaming, we should stream if the platform\n    // supports it.\n    return (\n      this.streaming === \"allow\" &&\n      platformSupportsStreaming(\n        this.frameworkName as SupportedFrameworkName,\n        this.env,\n      )\n    );\n  }\n\n  /**\n   * `createHandler` should be used to return a type-equivalent version of the\n   * `handler` specified during instantiation.\n   *\n   * @example\n   * ```\n   * // my-custom-handler.ts\n   * import {\n   *   InngestCommHandler,\n   *   type ServeHandlerOptions,\n   * } from \"./components/InngestCommHandler\";\n   *\n   * export const serve = (options: ServeHandlerOptions) => {\n   *   const handler = new InngestCommHandler({\n   *     frameworkName: \"my-custom-handler\",\n   *     ...options,\n   *     handler: (req: Request) => {\n   *       return {\n   *         body: () => req.json(),\n   *         headers: (key) => req.headers.get(key),\n   *         method: () => req.method,\n   *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n   *         transformResponse: ({ body, status, headers }) => {\n   *           return new Response(body, { status, headers });\n   *         },\n   *       };\n   *     },\n   *   });\n   *\n   *   return handler.createHandler();\n   * };\n   * ```\n   */\n  public createHandler(): (...args: Input) => Promise<Awaited<Output>> {\n    const handler = async (...args: Input) => {\n      const timer = new ServerTiming();\n\n      /**\n       * Used for testing, allow setting action overrides externally when\n       * calling the handler. Always search the final argument.\n       */\n      const lastArg = args[args.length - 1] as unknown;\n      const actionOverrides =\n        typeof lastArg === \"object\" &&\n        lastArg !== null &&\n        \"actionOverrides\" in lastArg &&\n        typeof lastArg[\"actionOverrides\"] === \"object\" &&\n        lastArg[\"actionOverrides\"] !== null\n          ? lastArg[\"actionOverrides\"]\n          : {};\n\n      /**\n       * We purposefully `await` the handler, as it could be either sync or\n       * async.\n       */\n      const rawActions = {\n        ...(await timer\n          .wrap(\"handler\", () => this.handler(...args))\n          .catch(rethrowError(\"Serve handler failed to run\"))),\n        ...actionOverrides,\n      };\n\n      /**\n       * Map over every `action` in `rawActions` and create a new `actions`\n       * object where each function is safely promisified with each access\n       * requiring a reason.\n       *\n       * This helps us provide high quality errors about what's going wrong for\n       * each access without having to wrap every access in a try/catch.\n       */\n      const promisifiedActions: ActionHandlerResponseWithErrors =\n        Object.entries(rawActions).reduce((acc, [key, value]) => {\n          if (typeof value !== \"function\") {\n            return acc;\n          }\n\n          return {\n            ...acc,\n            [key]: (reason: string, ...args: unknown[]) => {\n              const errMessage = [\n                `Failed calling \\`${key}\\` from serve handler`,\n                reason,\n              ]\n                .filter(Boolean)\n                .join(\" when \");\n\n              const fn = () =>\n                (value as (...args: unknown[]) => unknown)(...args);\n\n              return runAsPromise(fn)\n                .catch(rethrowError(errMessage))\n                .catch((err) => {\n                  this.log(\"error\", err);\n                  throw err;\n                });\n            },\n          };\n        }, {} as ActionHandlerResponseWithErrors);\n\n      /**\n       * Mapped promisified handlers from userland `serve()` function mixed in\n       * with some helpers.\n       */\n      const actions: HandlerResponseWithErrors = {\n        ...promisifiedActions,\n        queryStringWithDefaults: async (\n          reason: string,\n          key: string,\n        ): Promise<string | undefined> => {\n          const url = await actions.url(reason);\n\n          const ret =\n            (await actions.queryString?.(reason, key, url)) ||\n            url.searchParams.get(key) ||\n            undefined;\n\n          return ret;\n        },\n        ...actionOverrides,\n      };\n\n      const [env, expectedServerKind] = await Promise.all([\n        actions.env?.(\"starting to handle request\"),\n        actions.headers(\n          \"checking expected server kind\",\n          headerKeys.InngestServerKind,\n        ),\n      ]);\n\n      // Always make sure to merge whatever env we've been given with\n      // `process.env`; some platforms may not provide all the necessary\n      // environment variables or may use two sources.\n      this.env = {\n        ...allProcessEnv(),\n        ...env,\n      };\n\n      const getInngestHeaders = (): Record<string, string> =>\n        inngestHeaders({\n          env: this.env,\n          framework: this.frameworkName,\n          client: this.client,\n          expectedServerKind: expectedServerKind || undefined,\n          extras: {\n            \"Server-Timing\": timer.getHeader(),\n          },\n        });\n\n      const assumedMode = getMode({ env: this.env, client: this.client });\n\n      if (assumedMode.isExplicit) {\n        this._mode = assumedMode;\n      } else {\n        const serveIsProd = await actions.isProduction?.(\n          \"starting to handle request\",\n        );\n        if (typeof serveIsProd === \"boolean\") {\n          this._mode = new Mode({\n            type: serveIsProd ? \"cloud\" : \"dev\",\n            isExplicit: false,\n          });\n        } else {\n          this._mode = assumedMode;\n        }\n      }\n\n      this.upsertKeysFromEnv();\n\n      const methodP = actions.method(\"starting to handle request\");\n\n      const headerPromises = [\n        headerKeys.TraceParent,\n        headerKeys.TraceState,\n      ].map(async (header) => {\n        const value = await actions.headers(\n          `fetching ${header} for forwarding`,\n          header,\n        );\n\n        return { header, value };\n      });\n\n      const contentLength = await actions\n        .headers(\"checking signature for request\", headerKeys.ContentLength)\n        .then((value) => {\n          if (!value) {\n            return undefined;\n          }\n          return Number.parseInt(value, 10);\n        });\n\n      const [signature, method, body] = await Promise.all([\n        actions\n          .headers(\"checking signature for request\", headerKeys.Signature)\n          .then((headerSignature) => {\n            return headerSignature ?? undefined;\n          }),\n        methodP,\n        methodP.then((method) => {\n          if (method === \"POST\" || method === \"PUT\") {\n            if (!contentLength) {\n              // Return empty string because req.json() will throw an error.\n              return \"\";\n            }\n\n            return actions.body(\n              `checking body for request signing as method is ${method}`,\n            );\n          }\n\n          return \"\";\n        }),\n      ]);\n\n      const signatureValidation = this.validateSignature(signature, body);\n\n      const headersToForwardP = Promise.all(headerPromises).then(\n        (fetchedHeaders) => {\n          return fetchedHeaders.reduce<Record<string, string>>(\n            (acc, { header, value }) => {\n              if (value) {\n                acc[header] = value;\n              }\n\n              return acc;\n            },\n            {},\n          );\n        },\n      );\n\n      const actionRes = timer.wrap(\"action\", () =>\n        this.handleAction({\n          actions,\n          timer,\n          getInngestHeaders,\n          reqArgs: args,\n          signatureValidation,\n\n          body,\n          method,\n          headers: headersToForwardP,\n        }),\n      );\n\n      /**\n       * Prepares an action response by merging returned data to provide\n       * trailing information such as `Server-Timing` headers.\n       *\n       * It should always prioritize the headers returned by the action, as they\n       * may contain important information such as `Content-Type`.\n       */\n      const prepareActionRes = async (\n        res: ActionResponse,\n      ): Promise<ActionResponse> => {\n        const headers: Record<string, string> = {\n          ...getInngestHeaders(),\n          ...(await headersToForwardP),\n          ...res.headers,\n          ...(res.version === null\n            ? {}\n            : {\n                [headerKeys.RequestVersion]: (\n                  res.version ?? PREFERRED_EXECUTION_VERSION\n                ).toString(),\n              }),\n        };\n\n        let signature: string | undefined;\n\n        try {\n          signature = await signatureValidation.then((result) => {\n            if (!result.success || !result.keyUsed) {\n              return undefined;\n            }\n\n            return this.getResponseSignature(result.keyUsed, res.body);\n          });\n        } catch (err) {\n          // If we fail to sign, retun a 500 with the error.\n          return {\n            ...res,\n            headers,\n            body: stringify(serializeError(err)),\n            status: 500,\n          };\n        }\n\n        if (signature) {\n          headers[headerKeys.Signature] = signature;\n        }\n\n        return {\n          ...res,\n          headers,\n        };\n      };\n\n      if (await this.shouldStream(actions)) {\n        const method = await actions.method(\"starting streaming response\");\n\n        if (method === \"POST\") {\n          const { stream, finalize } = await createStream();\n\n          /**\n           * Errors are handled by `handleAction` here to ensure that an\n           * appropriate response is always given.\n           */\n          void actionRes.then((res) => {\n            return finalize(prepareActionRes(res));\n          });\n\n          return timer.wrap(\"res\", () => {\n            return actions.transformStreamingResponse?.(\n              \"starting streaming response\",\n              {\n                status: 201,\n                headers: getInngestHeaders(),\n                body: stream,\n                version: null,\n              },\n            );\n          });\n        }\n      }\n\n      return timer.wrap(\"res\", async () => {\n        return actionRes.then(prepareActionRes).then((actionRes) => {\n          return actions.transformResponse(\"sending back response\", actionRes);\n        });\n      });\n    };\n\n    /**\n     * Some platforms check (at runtime) the length of the function being used\n     * to handle an endpoint. If this is a variadic function, it will fail that\n     * check.\n     *\n     * Therefore, we expect the arguments accepted to be the same length as the\n     * `handler` function passed internally.\n     *\n     * We also set a name to avoid a common useless name in tracing such as\n     * `\"anonymous\"` or `\"bound function\"`.\n     *\n     * https://github.com/getsentry/sentry-javascript/issues/3284\n     */\n    Object.defineProperties(handler, {\n      name: {\n        value: \"InngestHandler\",\n      },\n      length: {\n        value: this.handler.length,\n      },\n    });\n\n    return handler;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private get mode(): Mode | undefined {\n    return this._mode;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private set mode(m) {\n    this._mode = m;\n\n    if (m) {\n      this.client[\"mode\"] = m;\n    }\n  }\n\n  /**\n   * Given a set of functions to check if an action is available from the\n   * instance's handler, enact any action that is found.\n   *\n   * This method can fetch varying payloads of data, but ultimately is the place\n   * where _decisions_ are made regarding functionality.\n   *\n   * For example, if we find that we should be viewing the UI, this function\n   * will decide whether the UI should be visible based on the payload it has\n   * found (e.g. env vars, options, etc).\n   */\n  private async handleAction({\n    actions,\n    timer,\n    getInngestHeaders,\n    reqArgs,\n    signatureValidation,\n    body,\n    method,\n    headers,\n  }: {\n    actions: HandlerResponseWithErrors;\n    timer: ServerTiming;\n    getInngestHeaders: () => Record<string, string>;\n    reqArgs: unknown[];\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    body: any;\n    method: string;\n    headers: Promise<Record<string, string>>;\n  }): Promise<ActionResponse> {\n    // This is when the request body is completely missing; it does not\n    // include an empty body. This commonly happens when the HTTP framework\n    // doesn't have body parsing middleware.\n    const isMissingBody = body === undefined;\n\n    try {\n      let url = await actions.url(\"starting to handle request\");\n\n      if (method === \"POST\") {\n        if (isMissingBody) {\n          this.log(\n            \"error\",\n            \"Missing body when executing, possibly due to missing request body middleware\",\n          );\n\n          return {\n            status: 500,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(\n              serializeError(\n                new Error(\n                  \"Missing request body when executing, possibly due to missing request body middleware\",\n                ),\n              ),\n            ),\n            version: undefined,\n          };\n        }\n\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          return {\n            status: 401,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(serializeError(validationResult.err)),\n            version: undefined,\n          };\n        }\n\n        const rawProbe = await actions.queryStringWithDefaults(\n          \"testing for probe\",\n          queryKeys.Probe,\n        );\n        if (rawProbe) {\n          const probe = enumFromValue(probeEnum, rawProbe);\n          if (!probe) {\n            // If we're here, we've received a probe that we don't recognize.\n            // Fail.\n            return {\n              status: 400,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(\n                serializeError(new Error(`Unknown probe \"${rawProbe}\"`)),\n              ),\n              version: undefined,\n            };\n          }\n\n          // Provide actions for every probe available.\n          const probeActions: Record<\n            probeEnum,\n            () => MaybePromise<ActionResponse>\n          > = {\n            [probeEnum.Trust]: () => ({\n              status: 200,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: \"\",\n              version: undefined,\n            }),\n          };\n\n          return probeActions[probe]();\n        }\n\n        const fnId = await actions.queryStringWithDefaults(\n          \"processing run request\",\n          queryKeys.FnId,\n        );\n        if (!fnId) {\n          // TODO PrettyError\n          throw new Error(\"No function ID found in request\");\n        }\n\n        const stepId =\n          (await actions.queryStringWithDefaults(\n            \"processing run request\",\n            queryKeys.StepId,\n          )) || null;\n\n        const { version, result } = this.runStep({\n          functionId: fnId,\n          data: body,\n          stepId,\n          timer,\n          reqArgs,\n          headers: await headers,\n        });\n        const stepOutput = await result;\n\n        /**\n         * Functions can return `undefined`, but we'll always convert this to\n         * `null`, as this is appropriately serializable by JSON.\n         */\n        const opDataUndefinedToNull = (op: OutgoingOp) => {\n          op.data = undefinedToNull(op.data);\n          return op;\n        };\n\n        const resultHandlers: ExecutionResultHandlers<ActionResponse> = {\n          \"function-rejected\": (result) => {\n            return {\n              status: result.retriable ? 500 : 400,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                ...(typeof result.retriable === \"string\"\n                  ? { [headerKeys.RetryAfter]: result.retriable }\n                  : {}),\n              },\n              body: stringify(undefinedToNull(result.error)),\n              version,\n            };\n          },\n          \"function-resolved\": (result) => {\n            return {\n              status: 200,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(undefinedToNull(result.data)),\n              version,\n            };\n          },\n          \"step-not-found\": (result) => {\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: \"false\",\n              },\n              body: stringify({\n                error: `Could not find step \"${\n                  result.step.displayName || result.step.id\n                }\" to run; timed out`,\n              }),\n              version,\n            };\n          },\n          \"step-ran\": (result) => {\n            const step = opDataUndefinedToNull(result.step);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                ...(typeof result.retriable !== \"undefined\"\n                  ? {\n                      [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                      ...(typeof result.retriable === \"string\"\n                        ? { [headerKeys.RetryAfter]: result.retriable }\n                        : {}),\n                    }\n                  : {}),\n              },\n              body: stringify([step]),\n              version,\n            };\n          },\n          \"steps-found\": (result) => {\n            const steps = result.steps.map(opDataUndefinedToNull);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(steps),\n              version,\n            };\n          },\n        };\n\n        const handler = resultHandlers[\n          stepOutput.type\n        ] as ExecutionResultHandler<ActionResponse>;\n\n        try {\n          return await handler(stepOutput);\n        } catch (err) {\n          this.log(\"error\", \"Error handling execution result\", err);\n          throw err;\n        }\n      }\n\n      // TODO: This feels hacky, so we should probably make it not hacky.\n      const env = getInngestHeaders()[headerKeys.Environment] ?? null;\n\n      if (method === \"GET\") {\n        return {\n          status: 200,\n          body: stringify(\n            await this.introspectionBody({\n              actions,\n              env,\n              signatureValidation,\n              url,\n            }),\n          ),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          version: undefined,\n        };\n      }\n\n      if (method === \"PUT\") {\n        const [deployId, inBandSyncRequested] = await Promise.all([\n          actions\n            .queryStringWithDefaults(\n              \"processing deployment request\",\n              queryKeys.DeployId,\n            )\n            .then((deployId) => {\n              return deployId === \"undefined\" ? undefined : deployId;\n            }),\n\n          Promise.resolve(\n            parseAsBoolean(this.env[envKeys.InngestAllowInBandSync]),\n          )\n            .then((allowInBandSync) => {\n              if (allowInBandSync !== undefined && !allowInBandSync) {\n                return syncKind.OutOfBand;\n              }\n\n              return actions.headers(\n                \"processing deployment request\",\n                headerKeys.InngestSyncKind,\n              );\n            })\n            .then((kind) => {\n              return kind === syncKind.InBand;\n            }),\n        ]);\n\n        if (inBandSyncRequested) {\n          if (isMissingBody) {\n            this.log(\n              \"error\",\n              \"Missing body when syncing, possibly due to missing request body middleware\",\n            );\n\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(\n                serializeError(\n                  new Error(\n                    \"Missing request body when syncing, possibly due to missing request body middleware\",\n                  ),\n                ),\n              ),\n              version: undefined,\n            };\n          }\n\n          // Validation can be successful if we're in dev mode and did not\n          // actually validate a key. In this case, also check that we did indeed\n          // use a particular key to validate.\n          const sigCheck = await signatureValidation;\n\n          if (!sigCheck.success) {\n            return {\n              status: 401,\n              body: stringify({\n                code: \"sig_verification_failed\",\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          const res = inBandSyncRequestBodySchema.safeParse(body);\n          if (!res.success) {\n            return {\n              status: 400,\n              body: stringify({\n                code: \"invalid_request\",\n                message: res.error.message,\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          // We can trust the URL here because it's coming from\n          // signature-verified request.\n          url = this.reqUrl(new URL(res.data.url));\n\n          // This should be an in-band sync\n          const respBody = await this.inBandRegisterBody({\n            actions,\n            deployId,\n            env,\n            signatureValidation,\n            url,\n          });\n\n          return {\n            status: 200,\n            body: stringify(respBody),\n            headers: {\n              \"Content-Type\": \"application/json\",\n              [headerKeys.InngestSyncKind]: syncKind.InBand,\n            },\n            version: undefined,\n          };\n        }\n\n        // If we're here, this is a legacy out-of-band sync\n        const { status, message, modified } = await this.register(\n          this.reqUrl(url),\n          deployId,\n          getInngestHeaders,\n        );\n\n        return {\n          status,\n          body: stringify({ message, modified }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          version: undefined,\n        };\n      }\n    } catch (err) {\n      return {\n        status: 500,\n        body: stringify({\n          type: \"internal\",\n          ...serializeError(err as Error),\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        version: undefined,\n      };\n    }\n\n    return {\n      status: 405,\n      body: JSON.stringify({\n        message: \"No action found; request was likely not POST, PUT, or GET\",\n        mode: this._mode,\n      }),\n      headers: {},\n      version: undefined,\n    };\n  }\n\n  protected runStep({\n    functionId,\n    stepId,\n    data,\n    timer,\n    reqArgs,\n    headers,\n  }: {\n    functionId: string;\n    stepId: string | null;\n    data: unknown;\n    timer: ServerTiming;\n    reqArgs: unknown[];\n    headers: Record<string, string>;\n  }): { version: ExecutionVersion; result: Promise<ExecutionResult> } {\n    const fn = this.fns[functionId];\n    if (!fn) {\n      // TODO PrettyError\n      throw new Error(`Could not find function with ID \"${functionId}\"`);\n    }\n\n    const immediateFnData = parseFnData(data);\n    let { version } = immediateFnData;\n\n    // Handle opting in to optimized parallelism in v3.\n    if (\n      version === ExecutionVersion.V1 &&\n      fn.fn[\"shouldOptimizeParallelism\"]?.()\n    ) {\n      version = ExecutionVersion.V2;\n    }\n\n    const result = runAsPromise(async () => {\n      const anyFnData = await fetchAllFnData({\n        data: immediateFnData,\n        api: this.client[\"inngestApi\"],\n        version,\n      });\n      if (!anyFnData.ok) {\n        throw new Error(anyFnData.error);\n      }\n\n      type ExecutionStarter<V> = (\n        fnData: V extends ExecutionVersion\n          ? Extract<FnData, { version: V }>\n          : FnData,\n      ) => MaybePromise<CreateExecutionOptions>;\n\n      type GenericExecutionStarters = Record<\n        ExecutionVersion,\n        ExecutionStarter<unknown>\n      >;\n\n      type ExecutionStarters = {\n        [V in ExecutionVersion]: ExecutionStarter<V>;\n      };\n\n      const executionStarters = ((s: ExecutionStarters) =>\n        s as GenericExecutionStarters)({\n        [ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, data]) => {\n            return {\n              ...acc,\n\n              [id]: { id, data },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n        [ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n                maxAttempts: ctx?.max_attempts,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n        [ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n                maxAttempts: ctx?.max_attempts,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n      });\n\n      const executionOptions = await executionStarters[version](\n        anyFnData.value,\n      );\n\n      return fn.fn[\"createExecution\"](executionOptions).start();\n    });\n\n    return { version, result };\n  }\n\n  protected configs(url: URL): FunctionConfig[] {\n    const configs = Object.values(this.rawFns).reduce<FunctionConfig[]>(\n      (acc, fn) => [\n        ...acc,\n        ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n      ],\n      [],\n    );\n\n    for (const config of configs) {\n      const check = functionConfigSchema.safeParse(config);\n      if (!check.success) {\n        const errors = check.error.errors.map((err) => err.message).join(\"; \");\n\n        this.log(\n          \"warn\",\n          `Config invalid for function \"${config.id}\" : ${errors}`,\n        );\n      }\n    }\n\n    return configs;\n  }\n\n  /**\n   * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n   *\n   * Will automatically use the `serveHost` and `servePath` if they have been\n   * set when registering.\n   */\n  protected reqUrl(url: URL): URL {\n    let ret = new URL(url);\n\n    const serveHost = this.serveHost || this.env[envKeys.InngestServeHost];\n    const servePath = this.servePath || this.env[envKeys.InngestServePath];\n\n    if (servePath) {\n      ret.pathname = servePath;\n    }\n\n    if (serveHost) {\n      ret = new URL(ret.pathname + ret.search, serveHost);\n    }\n\n    return ret;\n  }\n\n  protected registerBody({\n    url,\n    deployId,\n  }: {\n    url: URL;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n  }): RegisterRequest {\n    const body: RegisterRequest = {\n      url: url.href,\n      deployType: \"ping\",\n      framework: this.frameworkName,\n      appName: this.id,\n      functions: this.configs(url),\n      sdk: `js:v${version}`,\n      v: \"0.1\",\n      deployId: deployId || undefined,\n      capabilities: {\n        trust_probe: \"v1\",\n        connect: \"v1\",\n      },\n      appVersion: this.client.appVersion,\n    };\n\n    return body;\n  }\n\n  protected async inBandRegisterBody({\n    actions,\n    deployId,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n\n    url: URL;\n  }): Promise<InBandRegisterRequest> {\n    const registerBody = this.registerBody({ deployId, url });\n    const introspectionBody = await this.introspectionBody({\n      actions,\n      env,\n      signatureValidation,\n      url,\n    });\n\n    const body: InBandRegisterRequest = {\n      app_id: this.id,\n      appVersion: this.client.appVersion,\n      capabilities: registerBody.capabilities,\n      env,\n      framework: registerBody.framework,\n      functions: registerBody.functions,\n      inspection: introspectionBody,\n      platform: getPlatformName({\n        ...allProcessEnv(),\n        ...this.env,\n      }),\n      sdk_author: \"inngest\",\n      sdk_language: \"\",\n      sdk_version: \"\",\n      sdk: registerBody.sdk,\n      url: registerBody.url,\n    };\n\n    if (introspectionBody.authentication_succeeded) {\n      body.sdk_language = introspectionBody.sdk_language;\n      body.sdk_version = introspectionBody.sdk_version;\n    }\n\n    return body;\n  }\n\n  protected async introspectionBody({\n    actions,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    url: URL;\n  }): Promise<UnauthenticatedIntrospection | AuthenticatedIntrospection> {\n    const registerBody = this.registerBody({\n      url: this.reqUrl(url),\n      deployId: null,\n    });\n\n    if (!this._mode) {\n      throw new Error(\"No mode set; cannot introspect without mode\");\n    }\n\n    let introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection = {\n      authentication_succeeded: null,\n      extra: {\n        is_mode_explicit: this._mode.isExplicit,\n      },\n      has_event_key: this.client[\"eventKeySet\"](),\n      has_signing_key: Boolean(this.signingKey),\n      function_count: registerBody.functions.length,\n      mode: this._mode.type,\n      schema_version: \"2024-05-24\",\n    } satisfies UnauthenticatedIntrospection;\n\n    // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n    // signature validation\n    if (this._mode.type === \"cloud\") {\n      try {\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          throw new Error(\"Signature validation failed\");\n        }\n\n        introspection = {\n          ...introspection,\n          authentication_succeeded: true,\n          api_origin: this.apiBaseUrl,\n          app_id: this.id,\n          capabilities: {\n            trust_probe: \"v1\",\n            connect: \"v1\",\n          },\n          env,\n          event_api_origin: this.eventApiBaseUrl,\n          event_key_hash: this.hashedEventKey ?? null,\n          extra: {\n            ...introspection.extra,\n            is_streaming: await this.shouldStream(actions),\n          },\n          framework: this.frameworkName,\n          sdk_language: \"js\",\n          sdk_version: version,\n          serve_origin: this.serveHost ?? null,\n          serve_path: this.servePath ?? null,\n          signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,\n          signing_key_hash: this.hashedSigningKey ?? null,\n        } satisfies AuthenticatedIntrospection;\n      } catch {\n        // Swallow signature validation error since we'll just return the\n        // unauthenticated introspection\n        introspection = {\n          ...introspection,\n          authentication_succeeded: false,\n        } satisfies UnauthenticatedIntrospection;\n      }\n    }\n\n    return introspection;\n  }\n\n  protected async register(\n    url: URL,\n    deployId: string | undefined | null,\n    getHeaders: () => Record<string, string>,\n  ): Promise<{ status: number; message: string; modified: boolean }> {\n    const body = this.registerBody({ url, deployId });\n\n    let res: globalThis.Response;\n\n    // Whenever we register, we check to see if the dev server is up.  This\n    // is a noop and returns false in production. Clone the URL object to avoid\n    // mutating the property between requests.\n    let registerURL = new URL(this.inngestRegisterUrl.href);\n\n    const inferredDevMode =\n      this._mode && this._mode.isInferred && this._mode.isDev;\n\n    if (inferredDevMode) {\n      const host = devServerHost(this.env);\n      const hasDevServer = await devServerAvailable(host, this.fetch);\n      if (hasDevServer) {\n        registerURL = devServerUrl(host, \"/fn/register\");\n      }\n    } else if (this._mode?.explicitDevUrl) {\n      registerURL = devServerUrl(\n        this._mode.explicitDevUrl.href,\n        \"/fn/register\",\n      );\n    }\n\n    if (deployId) {\n      registerURL.searchParams.set(queryKeys.DeployId, deployId);\n    }\n\n    try {\n      res = await fetchWithAuthFallback({\n        authToken: this.hashedSigningKey,\n        authTokenFallback: this.hashedSigningKeyFallback,\n        fetch: this.fetch,\n        url: registerURL.href,\n        options: {\n          method: \"POST\",\n          body: stringify(body),\n          headers: {\n            ...getHeaders(),\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          redirect: \"follow\",\n        },\n      });\n    } catch (err: unknown) {\n      this.log(\"error\", err);\n\n      return {\n        status: 500,\n        message: `Failed to register${\n          err instanceof Error ? `; ${err.message}` : \"\"\n        }`,\n        modified: false,\n      };\n    }\n\n    const raw = await res.text();\n\n    let data: z.input<typeof registerResSchema> = {};\n\n    try {\n      data = JSON.parse(raw);\n    } catch (err) {\n      this.log(\"warn\", \"Couldn't unpack register response:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    let status: number;\n    let error: string;\n    let skipped: boolean;\n    let modified: boolean;\n    try {\n      ({ status, error, skipped, modified } = registerResSchema.parse(data));\n    } catch (err) {\n      this.log(\"warn\", \"Invalid register response schema:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    // The dev server polls this endpoint to register functions every few\n    // seconds, but we only want to log that we've registered functions if\n    // the function definitions change.  Therefore, we compare the body sent\n    // during registration with the body of the current functions and refuse\n    // to register if the functions are the same.\n    if (!skipped) {\n      this.log(\n        \"debug\",\n        \"registered inngest functions:\",\n        res.status,\n        res.statusText,\n        data,\n      );\n    }\n\n    return { status, message: error, modified };\n  }\n\n  /**\n   * Given an environment, upsert any missing keys. This is useful in\n   * situations where environment variables are passed directly to handlers or\n   * are otherwise difficult to access during initialization.\n   */\n  private upsertKeysFromEnv() {\n    if (this.env[envKeys.InngestSigningKey]) {\n      if (!this.signingKey) {\n        this.signingKey = String(this.env[envKeys.InngestSigningKey]);\n      }\n\n      this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n    }\n\n    if (this.env[envKeys.InngestSigningKeyFallback]) {\n      if (!this.signingKeyFallback) {\n        this.signingKeyFallback = String(\n          this.env[envKeys.InngestSigningKeyFallback],\n        );\n      }\n\n      this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n    }\n\n    if (!this.client[\"eventKeySet\"]() && this.env[envKeys.InngestEventKey]) {\n      this.client.setEventKey(String(this.env[envKeys.InngestEventKey]));\n    }\n\n    // v2 -> v3 migration warnings\n    if (this.env[envKeys.InngestDevServerUrl]) {\n      this.log(\n        \"warn\",\n        `Use of ${envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n  }\n\n  /**\n   * Validate the signature of a request and return the signing key used to\n   * validate it.\n   */\n\n  protected async validateSignature(\n    sig: string | undefined,\n    body: unknown,\n  ): Promise<\n    { success: true; keyUsed: string } | { success: false; err: Error }\n  > {\n    try {\n      // Skip signature validation if requested (used by connect)\n      if (this.skipSignatureValidation) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // Never validate signatures outside of prod. Make sure to check the mode\n      // exists here instead of using nullish coalescing to confirm that the check\n      // has been completed.\n      if (this._mode && !this._mode.isCloud) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // If we're here, we're in production; lack of a signing key is an error.\n      if (!this.signingKey) {\n        // TODO PrettyError\n        throw new Error(\n          `No signing key found in client options or ${envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`,\n        );\n      }\n\n      // If we're here, we're in production; lack of a req signature is an error.\n      if (!sig) {\n        // TODO PrettyError\n        throw new Error(`No ${headerKeys.Signature} provided`);\n      }\n\n      // Validate the signature\n      return {\n        success: true,\n        keyUsed: new RequestSignature(sig).verifySignature({\n          body,\n          allowExpiredSignatures: this.allowExpiredSignatures,\n          signingKey: this.signingKey,\n          signingKeyFallback: this.signingKeyFallback,\n        }),\n      };\n    } catch (err) {\n      return { success: false, err: err as Error };\n    }\n  }\n\n  protected getResponseSignature(key: string, body: string): string {\n    const now = Date.now();\n    const mac = signDataWithKey(body, key, now.toString());\n\n    return `t=${now}&s=${mac}`;\n  }\n\n  /**\n   * Log to stdout/stderr if the log level is set to include the given level.\n   * The default log level is `\"info\"`.\n   *\n   * This is an abstraction over `console.log` and will try to use the correct\n   * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n   * call `console.error(\"foo\")`.\n   */\n  protected log(level: LogLevel, ...args: unknown[]) {\n    const logLevels: LogLevel[] = [\n      \"debug\",\n      \"info\",\n      \"warn\",\n      \"error\",\n      \"fatal\",\n      \"silent\",\n    ];\n\n    const logLevelSetting = logLevels.indexOf(this.logLevel);\n    const currentLevel = logLevels.indexOf(level);\n\n    if (currentLevel >= logLevelSetting) {\n      let logger = console.log;\n\n      if (Object.hasOwn(console, level)) {\n        logger = console[level as keyof typeof console] as typeof logger;\n      }\n\n      logger(`${logPrefix} ${level as string} -`, ...args);\n    }\n  }\n}\n\nclass RequestSignature {\n  public timestamp: string;\n  public signature: string;\n\n  constructor(sig: string) {\n    const params = new URLSearchParams(sig);\n    this.timestamp = params.get(\"t\") || \"\";\n    this.signature = params.get(\"s\") || \"\";\n\n    if (!this.timestamp || !this.signature) {\n      // TODO PrettyError\n      throw new Error(`Invalid ${headerKeys.Signature} provided`);\n    }\n  }\n\n  private hasExpired(allowExpiredSignatures?: boolean) {\n    if (allowExpiredSignatures) {\n      return false;\n    }\n\n    const delta =\n      Date.now() - new Date(Number.parseInt(this.timestamp) * 1000).valueOf();\n    return delta > 1000 * 60 * 5;\n  }\n\n  #verifySignature({\n    body,\n    signingKey,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    allowExpiredSignatures: boolean;\n  }): void {\n    if (this.hasExpired(allowExpiredSignatures)) {\n      // TODO PrettyError\n      throw new Error(\"Signature has expired\");\n    }\n\n    const mac = signDataWithKey(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n      // TODO PrettyError\n      throw new Error(\"Invalid signature\");\n    }\n  }\n\n  public verifySignature({\n    body,\n    signingKey,\n    signingKeyFallback,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    allowExpiredSignatures: boolean;\n  }): string {\n    try {\n      this.#verifySignature({ body, signingKey, allowExpiredSignatures });\n\n      return signingKey;\n    } catch (err) {\n      if (!signingKeyFallback) {\n        throw err;\n      }\n\n      this.#verifySignature({\n        body,\n        signingKey: signingKeyFallback,\n        allowExpiredSignatures,\n      });\n\n      return signingKeyFallback;\n    }\n  }\n}\n\n/**\n * The broad definition of a handler passed when instantiating an\n * {@link InngestCommHandler} instance.\n */\nexport type Handler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> = (...args: Input) => HandlerResponse<Output, StreamOutput>;\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport type HandlerResponse<Output = any, StreamOutput = any> = {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  body: () => MaybePromise<any>;\n  env?: () => MaybePromise<Env | undefined>;\n  headers: (key: string) => MaybePromise<string | null | undefined>;\n\n  /**\n   * Whether the current environment is production. This is used to determine\n   * some functionality like whether to connect to the dev server or whether to\n   * show debug logging.\n   *\n   * If this is not provided--or is provided and returns `undefined`--we'll try\n   * to automatically detect whether we're in production by checking various\n   * environment variables.\n   */\n  isProduction?: () => MaybePromise<boolean | undefined>;\n  method: () => MaybePromise<string>;\n  queryString?: (\n    key: string,\n    url: URL,\n  ) => MaybePromise<string | null | undefined>;\n  url: () => MaybePromise<URL>;\n\n  /**\n   * The `transformResponse` function receives the output of the Inngest SDK and\n   * can decide how to package up that information to appropriately return the\n   * information to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and a stringified `body`. This ensures\n   * you can appropriately handle the response, including use of any required\n   * parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformResponse: (res: ActionResponse<string>) => Output;\n\n  /**\n   * The `transformStreamingResponse` function, if defined, declares that this\n   * handler supports streaming responses back to Inngest. This is useful for\n   * functions that are expected to take a long time, as edge streaming can\n   * often circumvent restrictive request timeouts and other limitations.\n   *\n   * If your handler does not support streaming, do not define this function.\n   *\n   * It receives the output of the Inngest SDK and can decide how to package\n   * up that information to appropriately return the information in a stream\n   * to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and `body`, a `ReadableStream`. This\n   * ensures you can appropriately handle the response, including use of any\n   * required parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformStreamingResponse?: (\n    res: ActionResponse<ReadableStream>,\n  ) => StreamOutput;\n};\n\n/**\n * The response from the Inngest SDK before it is transformed in to a\n * framework-compatible response by an {@link InngestCommHandler} instance.\n */\nexport interface ActionResponse<\n  TBody extends string | ReadableStream = string,\n> {\n  /**\n   * The HTTP status code to return.\n   */\n  status: number;\n\n  /**\n   * The headers to return in the response.\n   */\n  headers: Record<string, string>;\n\n  /**\n   * A stringified body to return.\n   */\n  body: TBody;\n\n  /**\n   * The version of the execution engine that was used to run this action.\n   *\n   * If the action didn't use the execution engine (for example, a GET request\n   * as a health check) or would have but errored before reaching it, this will\n   * be `undefined`.\n   *\n   * If the version should be entirely omitted from the response (for example,\n   * when sending preliminary headers when streaming), this will be `null`.\n   */\n  version: ExecutionVersion | null | undefined;\n}\n\n/**\n * A version of {@link HandlerResponse} where each function is safely\n * promisified and requires a reason for each access.\n *\n * This enables us to provide accurate errors for each access without having to\n * wrap every access in a try/catch.\n */\nexport type ActionHandlerResponseWithErrors = {\n  [K in keyof HandlerResponse]: NonNullable<HandlerResponse[K]> extends (\n    ...args: infer Args\n  ) => infer R\n    ? R extends MaybePromise<infer PR>\n      ? (errMessage: string, ...args: Args) => Promise<PR>\n      : (errMessage: string, ...args: Args) => Promise<R>\n    : HandlerResponse[K];\n};\n\n/**\n * A version of {@link ActionHandlerResponseWithErrors} that includes helper\n * functions that provide sensible defaults on top of the direct access given\n * from the bare response.\n */\nexport interface HandlerResponseWithErrors\n  extends ActionHandlerResponseWithErrors {\n  /**\n   * Fetch a query string value from the request. If no `querystring` action has\n   * been provided by the `serve()` handler, this will fall back to using the\n   * provided URL present in the request to parse the query string from instead.\n   */\n  queryStringWithDefaults: (\n    reason: string,\n    key: string,\n  ) => Promise<string | undefined>;\n}\n","/**\n * Onboarding Steps Service\n *\n * Idempotent step execution logic for user onboarding.\n * Each step uses a \"get or create\" pattern - checks if data exists,\n * returns it if so, otherwise creates via LLM.\n *\n * When forceCreate=true (for re-onboarding subscribed users):\n * - Skips the \"get existing\" check\n * - Always creates new data\n * - Old data is preserved for history\n *\n * This makes the onboarding flow:\n * - Truly idempotent - running multiple times produces same result\n * - Resumable - if data exists, it's returned without re-creation\n * - Testable - each step has clear inputs and outputs\n *\n * Used by the Inngest onboardUser function.\n */\n\nimport { userService } from '@/server/services/user/userService';\nimport { onboardingDataService } from '@/server/services/user/onboardingDataService';\nimport { fitnessProfileService } from '@/server/services/user/fitnessProfileService';\nimport { fitnessPlanService } from '@/server/services/training/fitnessPlanService';\nimport { progressService } from '@/server/services/training/progressService';\nimport { workoutInstanceService } from '@/server/services/training/workoutInstanceService';\nimport { onboardingCoordinator } from '@/server/services/orchestration/onboardingCoordinator';\nimport { now } from '@/shared/utils/date';\nimport type { SignupData } from '@/server/repositories/onboardingRepository';\nimport type { UserWithProfile } from '@/server/models/user';\nimport type { FitnessPlan } from '@/server/models/fitnessPlan';\nimport type { Microcycle } from '@/server/models/microcycle';\nimport type { WorkoutInstance } from '@/server/models/workout';\n\n// Return types for each step\nexport interface LoadDataResult {\n  user: UserWithProfile;\n  signupData: SignupData;\n}\n\nexport interface ProfileResult {\n  user: UserWithProfile;\n  wasCreated: boolean;\n}\n\nexport interface PlanResult {\n  plan: FitnessPlan;\n  wasCreated: boolean;\n}\n\nexport interface MicrocycleResult {\n  microcycle: Microcycle;\n  wasCreated: boolean;\n}\n\nexport interface WorkoutResult {\n  workout: WorkoutInstance;\n  wasCreated: boolean;\n}\n\nexport const onboardingSteps = {\n  /**\n   * Step 1: Load user and signup data\n   * Returns user to be passed to all subsequent steps\n   */\n  async loadData(userId: string): Promise<LoadDataResult> {\n    console.log(`[Onboarding] Step 1: Loading user and signup data for ${userId}`);\n\n    const user = await userService.getUser(userId);\n    if (!user) {\n      throw new Error(`User ${userId} not found`);\n    }\n\n    const signupData = await onboardingDataService.getSignupData(userId);\n    if (!signupData) {\n      throw new Error(`No signup data found for user ${userId}`);\n    }\n\n    return { user, signupData };\n  },\n\n  /**\n   * Step 2: Get or create fitness profile\n   * Returns updated user with profile for subsequent steps\n   *\n   * @param forceCreate - When true, always creates new profile (for re-onboarding)\n   */\n  async getOrCreateProfile(\n    user: UserWithProfile,\n    signupData: SignupData,\n    forceCreate = false\n  ): Promise<ProfileResult> {\n    // Only check for existing profile if not forcing creation\n    if (!forceCreate) {\n      const existingProfile = await fitnessProfileService.getCurrentProfile(user.id);\n      if (existingProfile) {\n        console.log(`[Onboarding] Step 2: Profile already exists for ${user.id}`);\n        return { user, wasCreated: false };\n      }\n    }\n\n    console.log(`[Onboarding] Step 2: Creating profile for ${user.id} (LLM)${forceCreate ? ' [forceCreate]' : ''}`);\n    await fitnessProfileService.createFitnessProfile(user, signupData);\n\n    // Re-fetch user to get updated profile\n    const updatedUser = await userService.getUser(user.id);\n    if (!updatedUser) {\n      throw new Error(`User ${user.id} not found after profile creation`);\n    }\n\n    return { user: updatedUser, wasCreated: true };\n  },\n\n  /**\n   * Step 3: Get or create fitness plan\n   *\n   * @param forceCreate - When true, always creates new plan (for re-onboarding)\n   */\n  async getOrCreatePlan(user: UserWithProfile, forceCreate = false): Promise<PlanResult> {\n    // Only check for existing plan if not forcing creation\n    if (!forceCreate) {\n      const existingPlan = await fitnessPlanService.getCurrentPlan(user.id);\n      if (existingPlan) {\n        console.log(`[Onboarding] Step 3: Plan already exists for ${user.id}`);\n        return { plan: existingPlan, wasCreated: false };\n      }\n    }\n\n    console.log(`[Onboarding] Step 3: Creating plan for ${user.id} (LLM)${forceCreate ? ' [forceCreate]' : ''}`);\n    const plan = await fitnessPlanService.createFitnessPlan(user);\n    return { plan, wasCreated: true };\n  },\n\n  /**\n   * Step 4: Get or create microcycle\n   * Needs plan for week calculation\n   *\n   * @param forceCreate - When true, always creates new microcycle (for re-onboarding)\n   */\n  async getOrCreateMicrocycle(\n    user: UserWithProfile,\n    plan: FitnessPlan,\n    forceCreate = false\n  ): Promise<MicrocycleResult> {\n    const currentDate = now(user.timezone).toJSDate();\n    const { microcycle, wasCreated } = await progressService.getOrCreateMicrocycleForDate(\n      user.id,\n      plan,\n      currentDate,\n      user.timezone,\n      forceCreate\n    );\n\n    if (!microcycle) {\n      throw new Error(`Could not get/create microcycle for user ${user.id}`);\n    }\n\n    console.log(`[Onboarding] Step 4: Microcycle ${wasCreated ? 'created' : 'already exists'} for ${user.id}${forceCreate ? ' [forceCreate]' : ''}`);\n    return { microcycle, wasCreated };\n  },\n\n  /**\n   * Step 5: Get or create workout\n   * Needs microcycle for day pattern and isDeload flag\n   *\n   * @param forceCreate - When true, always creates new workout (for re-onboarding)\n   */\n  async getOrCreateWorkout(\n    user: UserWithProfile,\n    microcycle: Microcycle,\n    forceCreate = false\n  ): Promise<WorkoutResult> {\n    const targetDate = now(user.timezone).startOf('day');\n\n    // Only check for existing workout if not forcing creation\n    if (!forceCreate) {\n      const existingWorkout = await workoutInstanceService.getWorkoutByUserIdAndDate(user.id, targetDate.toJSDate());\n      if (existingWorkout) {\n        console.log(`[Onboarding] Step 5: Workout already exists for ${user.id}`);\n        return { workout: existingWorkout, wasCreated: false };\n      }\n    }\n\n    console.log(`[Onboarding] Step 5: Creating workout for ${user.id} (LLM)${forceCreate ? ' [forceCreate]' : ''}`);\n    const workout = await workoutInstanceService.generateWorkoutForDate(user, targetDate, microcycle);\n    if (!workout) {\n      throw new Error(`Failed to generate workout for user ${user.id}`);\n    }\n\n    return { workout, wasCreated: true };\n  },\n\n  /**\n   * Step 6: Mark completed (idempotent)\n   */\n  async markCompleted(userId: string): Promise<void> {\n    console.log(`[Onboarding] Step 6: Marking onboarding as completed for ${userId}`);\n    await onboardingDataService.markCompleted(userId);\n  },\n\n  /**\n   * Step 7: Send messages (idempotent - coordinator checks if already sent)\n   */\n  async sendMessages(userId: string): Promise<boolean> {\n    console.log(`[Onboarding] Step 7: Sending onboarding messages for ${userId}`);\n\n    try {\n      const sent = await onboardingCoordinator.sendOnboardingMessages(userId);\n      if (sent) {\n        console.log(`[Onboarding] Onboarding messages sent to ${userId}`);\n      } else {\n        console.log(`[Onboarding] Waiting for payment to complete for ${userId}`);\n      }\n      return sent;\n    } catch (error) {\n      // Don't fail the whole onboarding if message sending fails\n      // Webhook will retry when payment completes\n      console.error(`[Onboarding] Failed to send messages for ${userId}:`, error);\n      return false;\n    }\n  },\n};\n","/**\n * Inngest API Route\n *\n * This endpoint is auto-discovered by Inngest and serves as the gateway\n * for all serverless function execution.\n *\n * Inngest will:\n * - Register all functions defined here\n * - Send events to trigger function execution\n * - Handle retries and error tracking\n * - Provide observability dashboard\n *\n * Local Development:\n * 1. Run: npx inngest-cli@latest dev\n * 2. Visit: http://localhost:8288\n * 3. Functions are auto-detected and ready to test\n *\n * Production:\n * - Vercel auto-detects this route\n * - Set INNGEST_EVENT_KEY and INNGEST_SIGNING_KEY in env vars\n * - Functions are automatically registered\n */\n\nimport { serve } from 'inngest/next';\nimport { inngest } from '@/server/connections/inngest/client';\nimport {\n  processMessageFunction,\n  sendDailyWorkoutFunction,\n  sendWeeklyMessageFunction,\n  onboardUserFunction,\n  processNextQueuedMessageFunction,\n  sendQueuedMessageFunction,\n} from '@/server/inngest/functions';\nimport { retryMessageFunction } from '@/server/inngest/functions/retryMessage';\n\nexport const { GET, POST, PUT } = serve({\n  client: inngest,\n  functions: [\n    processMessageFunction,\n    retryMessageFunction,\n    sendDailyWorkoutFunction,\n    sendWeeklyMessageFunction,\n    onboardUserFunction,\n    processNextQueuedMessageFunction,\n    sendQueuedMessageFunction,\n  ],\n});\n","/**\n * Onboard User Function (Inngest)\n *\n * Async function that processes user onboarding after signup.\n * Triggered by 'user/onboarding.requested' event from signup API.\n *\n * Uses a \"get or create\" pattern for each step:\n * - If data exists, returns it immediately (cached by Inngest)\n * - If not, creates it via LLM\n *\n * When forceCreate=true (for re-onboarding subscribed users):\n * - Always creates new profile, plan, microcycle, workout\n * - Old data is preserved for history\n *\n * This makes the flow idempotent - running multiple times produces same result.\n *\n * Data Flow:\n * Step 1 (loadData)  { initialUser, signupData }\n * Step 2 (profile)   { user } (with profile)\n * Step 3 (plan)      { plan }\n * Step 4 (microcycle)  { microcycle }\n * Step 5 (workout)   { workout }\n * Step 6 (markCompleted)\n * Step 7 (sendMessages)\n */\n\nimport { inngest } from '@/server/connections/inngest/client';\nimport { onboardingDataService } from '@/server/services/user/onboardingDataService';\nimport { onboardingSteps } from '@/server/services/orchestration/onboardingSteps';\nimport type { UserWithProfile } from '@/server/models/user';\nimport type { FitnessPlan } from '@/server/models/fitnessPlan';\nimport type { Microcycle } from '@/server/models/microcycle';\nimport type { SignupData } from '@/server/repositories/onboardingRepository';\n\nexport const onboardUserFunction = inngest.createFunction(\n  {\n    id: 'onboard-user',\n    name: 'Onboard New User',\n    retries: 2,\n  },\n  { event: 'user/onboarding.requested' },\n  async ({ event, step }) => {\n    const { userId, forceCreate = false } = event.data;\n\n    try {\n      // Mark as started\n      await step.run('mark-started', () => onboardingDataService.markStarted(userId));\n\n      // Step 1: Load user + signup data (cached by Inngest)\n      // Note: Inngest serializes data between steps, so Date objects become strings.\n      // We use type assertions to satisfy TypeScript - the underlying data works fine at runtime.\n      const { user: initialUser, signupData } = await step.run('step-1-load-data', () =>\n        onboardingSteps.loadData(userId)\n      ) as unknown as { user: UserWithProfile; signupData: SignupData };\n\n      // Step 2: Get or create profile (returns updated user)\n      // forceCreate=true will always create new profile even if one exists\n      const { user } = await step.run('step-2-profile', () =>\n        onboardingSteps.getOrCreateProfile(initialUser, signupData, forceCreate)\n      ) as unknown as { user: UserWithProfile; wasCreated: boolean };\n\n      // Step 3: Get or create plan (uses user with profile)\n      // forceCreate=true will always create new plan even if one exists\n      const { plan } = await step.run('step-3-plan', () =>\n        onboardingSteps.getOrCreatePlan(user, forceCreate)\n      ) as unknown as { plan: FitnessPlan; wasCreated: boolean };\n\n      // Step 4: Get or create microcycle (needs plan)\n      // forceCreate=true will always create new microcycle even if one exists\n      const { microcycle } = await step.run('step-4-microcycle', () =>\n        onboardingSteps.getOrCreateMicrocycle(user, plan, forceCreate)\n      ) as unknown as { microcycle: Microcycle; wasCreated: boolean };\n\n      // Step 5: Get or create workout (needs microcycle)\n      // forceCreate=true will always create new workout even if one exists\n      await step.run('step-5-workout', () =>\n        onboardingSteps.getOrCreateWorkout(user, microcycle, forceCreate)\n      );\n\n      // Step 6: Mark completed\n      await step.run('step-6-complete', () =>\n        onboardingSteps.markCompleted(userId)\n      );\n\n      // Step 7: Send messages\n      const messagesSent = await step.run('step-7-messages', () =>\n        onboardingSteps.sendMessages(userId)\n      );\n\n      console.log(`[Inngest] Onboarding complete for user ${userId}`);\n\n      return { success: true, userId, messagesSent };\n    } catch (error) {\n      // Mark onboarding as failed\n      console.error(`[Inngest] Onboarding failed for user ${userId}:`, error);\n\n      try {\n        await onboardingDataService.updateStatus(\n          userId,\n          'failed',\n          error instanceof Error ? error.message : 'Unknown error during onboarding'\n        );\n      } catch (updateError) {\n        console.error(`[Inngest] Failed to update onboarding status for ${userId}:`, updateError);\n      }\n\n      // Re-throw to let Inngest handle retries\n      throw error;\n    }\n  }\n);\n"],"names":["createServerModuleMap","normalizeAppPath","frameworkName: SupportedFrameworkName","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","userland","passFinalize: (value: (data: unknown) => void) => void","acc","absoluteUrl: URL | undefined","host","scheme: \"http\" | \"https\"","defaultLogLevel: typeof this.logLevel","defaultStreamingOption: typeof this.streaming","actions: HandlerResponseWithErrors","args","method","headers: Record<string, string>","signature: string | undefined","signature","actionRes","probe","probeEnum","result","deployId","version","data","body: InBandRegisterRequest","introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection","res: globalThis.Response","err: unknown","data: z.input<typeof registerResSchema>","status: number","error: string","skipped: boolean","modified: boolean","logLevels: LogLevel[]","logLevels","#verifySignature"],"mappings":"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","ignoreList":[0,2,3,4,5,6,12]}