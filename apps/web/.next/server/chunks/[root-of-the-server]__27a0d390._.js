module.exports=[918622,(e,s,t)=>{s.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},556704,(e,s,t)=>{s.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},832319,(e,s,t)=>{s.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},324725,(e,s,t)=>{s.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},224361,(e,s,t)=>{s.exports=e.x("util",()=>require("util"))},814747,(e,s,t)=>{s.exports=e.x("path",()=>require("path"))},193695,(e,s,t)=>{s.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},875559,452130,e=>{"use strict";e.i(454188);var s=e.i(331612);let t=s.z.object({messageHistoryLimit:s.z.number().int().positive().default(5),includeSystemMessages:s.z.boolean().default(!0),maxContextTokens:s.z.number().int().positive().default(1e3),reserveTokensForResponse:s.z.number().int().positive().default(1500),conversationGapMinutes:s.z.number().int().positive().default(30),enableCaching:s.z.boolean().default(!0),cacheTTLSeconds:s.z.number().int().nonnegative().default(600)}),a=s.z.object({smsMaxLength:s.z.number().int().positive().default(1600),contextMinutes:s.z.number().int().positive().default(10)}),n=s.z.enum(["twilio","local"]),i=s.z.object({provider:n.default("twilio")}),r=s.z.object({agentLogging:s.z.boolean().default(!1),enableConversationStorage:s.z.boolean().default(!0)}),u=s.z.object({timeoutMinutes:s.z.number().int().positive().default(30),maxLength:s.z.number().int().positive().default(100),inactiveThresholdDays:s.z.number().int().positive().default(7)}),o=s.z.object({defaultExpiryDays:s.z.number().int().positive().default(7),domain:s.z.string().optional()}),l=s.z.object({priceId:s.z.string().min(1)}),d=s.z.object({phoneNumbers:s.z.array(s.z.string()).default([]),maxRequestsPerWindow:s.z.number().int().positive().default(3),rateLimitWindowMinutes:s.z.number().int().positive().default(15),codeExpiryMinutes:s.z.number().int().positive().default(10),codeLength:s.z.number().int().positive().default(6),devBypassCode:s.z.string().optional()}),g=s.z.object({baseUrl:s.z.string().optional(),publicBaseUrl:s.z.string().optional()}),c=s.z.object({environment:s.z.enum(["development","staging","production"]),context:t,chat:a,messaging:i,features:r,conversation:u,shortLinks:o,stripe:l,admin:d,urls:g});function m(e){if(!e)return;let s=parseInt(e,10);return isNaN(s)?void 0:s}function p(e){if(void 0!==e)return"true"===e}let v=null;function h(){return v||(v=function(){var e;let s="staging"===process.env.APP_ENV?"staging":"production",t={environment:s,context:{messageHistoryLimit:m(process.env.CONTEXT_MESSAGE_HISTORY_LIMIT),includeSystemMessages:p(process.env.CONTEXT_INCLUDE_SYSTEM_MESSAGES),maxContextTokens:m(process.env.CONTEXT_MAX_TOKENS),reserveTokensForResponse:m(process.env.CONTEXT_RESERVE_TOKENS),conversationGapMinutes:m(process.env.CONTEXT_CONVERSATION_GAP_MINUTES),enableCaching:p(process.env.CONTEXT_ENABLE_CACHING),cacheTTLSeconds:m(process.env.CONTEXT_CACHE_TTL)},chat:{smsMaxLength:m(process.env.SMS_MAX_LENGTH),contextMinutes:m(process.env.CHAT_CONTEXT_MINUTES)},messaging:{provider:process.env.MESSAGING_PROVIDER},features:{agentLogging:p(process.env.AGENT_LOGGING),enableConversationStorage:p(process.env.ENABLE_CONVERSATION_STORAGE)},conversation:{timeoutMinutes:m(process.env.CONVERSATION_TIMEOUT_MINUTES),maxLength:m(process.env.MAX_CONVERSATION_LENGTH),inactiveThresholdDays:m(process.env.INACTIVE_THRESHOLD_DAYS)},shortLinks:{defaultExpiryDays:m(process.env.SHORT_LINK_DEFAULT_EXPIRY_DAYS),domain:process.env.SHORT_LINK_DOMAIN},stripe:{priceId:process.env.STRIPE_PRICE_ID},admin:{phoneNumbers:process.env.ADMIN_PHONE_NUMBERS?(e=process.env.ADMIN_PHONE_NUMBERS)?e.split(",").map(e=>e.trim()).filter(e=>e.length>0):[]:void 0,devBypassCode:process.env.DEV_BYPASS_CODE},urls:{baseUrl:process.env.BASE_URL,publicBaseUrl:"http://localhost:3000"}},a=c.safeParse(t);if(!a.success){let e=a.error.errors.map(e=>`  - ${e.path.join(".")}: ${e.message}`).join("\n");throw Error(`Configuration validation failed:
${e}

Environment: ${s}
Check your environment variables.`)}return a.data}()),v}function f(){return!0}s.z.object({NEXT_PUBLIC_BASE_URL:s.z.string().optional(),NEXT_PUBLIC_ANALYTICS_WRITE_KEY:s.z.string().optional(),NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:s.z.string().optional()}),e.s(["isProductionEnvironment",()=>f],452130);let w=null;function S(){return h().chat}function M(){return h().messaging}function I(){return h().features}function Q(){return h().shortLinks}function x(){return h().stripe}function N(){return h().admin}function y(){return h().urls}new Proxy({},{get:(e,s)=>(!w&&(w=h()),w)[s]}),e.s(["getAdminConfig",()=>N,"getChatConfig",()=>S,"getFeatureFlags",()=>I,"getMessagingConfig",()=>M,"getShortLinksConfig",()=>Q,"getStripeConfig",()=>x,"getUrlsConfig",()=>y],875559)},38330,94510,e=>{"use strict";var s=e.i(46308);class t extends s.BaseRepository{async create(e){return await this.db.insertInto("messageQueues").values(e).returningAll().executeTakeFirstOrThrow()}async createMany(e){return 0===e.length?[]:await this.db.insertInto("messageQueues").values(e).returningAll().execute()}async findById(e){return await this.db.selectFrom("messageQueues").selectAll().where("id","=",e).executeTakeFirst()}async findByMessageId(e){return await this.db.selectFrom("messageQueues").selectAll().where("messageId","=",e).executeTakeFirst()}async findPendingByClient(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").execute()}async findAllPending(e){let s=this.db.selectFrom("messageQueues").selectAll().where("status","=","pending");return e.clientId&&(s=s.where("clientId","=",e.clientId)),await s.orderBy("createdAt","desc").limit(e.limit||100).offset(e.offset||0).execute()}async findAllPendingWithUserInfo(e){let s=this.db.selectFrom("messageQueues").innerJoin("users","users.id","messageQueues.clientId").select(["messageQueues.id","messageQueues.clientId","messageQueues.queueName","messageQueues.sequenceNumber","messageQueues.messageContent","messageQueues.mediaUrls","messageQueues.status","messageQueues.messageId","messageQueues.retryCount","messageQueues.maxRetries","messageQueues.timeoutMinutes","messageQueues.errorMessage","messageQueues.createdAt","messageQueues.sentAt","messageQueues.deliveredAt","users.name as userName","users.phoneNumber as userPhone"]).where("messageQueues.status","=","pending");return e.clientId&&(s=s.where("messageQueues.clientId","=",e.clientId)),await s.orderBy("messageQueues.createdAt","desc").limit(e.limit||100).execute()}async findNextPending(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").limit(1).executeTakeFirst()}async findStalled(e){return await this.db.selectFrom("messageQueues").selectAll().where("status","=","sent").where("sentAt","<",e).execute()}async updateStatus(e,s,t,a){return await this.db.updateTable("messageQueues").set({status:s,...t?.sentAt&&{sentAt:t.sentAt},...t?.deliveredAt&&{deliveredAt:t.deliveredAt},...a&&{errorMessage:a}}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async linkMessage(e,s){return await this.db.updateTable("messageQueues").set({messageId:s,status:"sent",sentAt:new Date}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async incrementRetry(e){let s=await this.findById(e);if(!s)throw Error(`Queue entry ${e} not found`);return await this.db.updateTable("messageQueues").set({retryCount:s.retryCount+1}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async deleteCompleted(e,s){await this.db.deleteFrom("messageQueues").where("clientId","=",e).where("queueName","=",s).where("status","in",["delivered","failed"]).execute()}async getQueueStatus(e,s){let t=await this.db.selectFrom("messageQueues").select(["status"]).where("clientId","=",e).where("queueName","=",s).execute();return{total:t.length,pending:t.filter(e=>"pending"===e.status).length,sent:t.filter(e=>"sent"===e.status).length,delivered:t.filter(e=>"delivered"===e.status).length,failed:t.filter(e=>"failed"===e.status).length}}}e.s(["MessageQueueRepository",()=>t],94510);var a=e.i(36480),n=e.i(187070),i=e.i(681247);class r{static instance;messageQueueRepo;constructor(){this.messageQueueRepo=new t(a.postgresDb)}static getInstance(){return r.instance||(r.instance=new r),r.instance}async enqueueMessages(e,s,t){if(0===s.length)return;console.log(`[MessageQueueService] Enqueueing ${s.length} messages for client ${e} in queue '${t}'`);let a=s.map((s,a)=>({clientId:e,queueName:t,sequenceNumber:a+1,messageContent:s.content||null,mediaUrls:s.mediaUrls?JSON.stringify(s.mediaUrls):null,status:"pending"}));await this.messageQueueRepo.createMany(a),console.log(`[MessageQueueService] Created ${a.length} queue entries`),await n.inngest.send({name:"message-queue/process-next",data:{clientId:e,queueName:t}})}async processNextMessage(e,s){console.log(`[MessageQueueService] Processing next message for client ${e} in queue '${s}'`);let t=await this.messageQueueRepo.findNextPending(e,s);if(!t){console.log(`[MessageQueueService] No more pending messages in queue '${s}' for client ${e}`),await this.clearQueue(e,s);return}console.log(`[MessageQueueService] Found next message (sequence ${t.sequenceNumber})`),await n.inngest.send({name:"message-queue/send-message",data:{queueEntryId:t.id,clientId:t.clientId,queueName:t.queueName}})}async sendQueuedMessage(s){let t,a=await this.messageQueueRepo.findById(s);if(!a)throw Error(`Queue entry ${s} not found`);let{messageService:n}=await e.A(593853),{userService:i}=await e.A(464245),r=await i.getUser(a.clientId);if(!r)throw Error(`Client ${a.clientId} not found`);if(a.mediaUrls)if("string"==typeof a.mediaUrls)try{t=JSON.parse(a.mediaUrls)}catch(e){console.error("[MessageQueueService] Failed to parse media URLs:",e)}else t=a.mediaUrls;console.log(`[MessageQueueService] Sending queued message ${s}`);let u=await n.sendMessage(r,a.messageContent||void 0,t);return await this.messageQueueRepo.linkMessage(a.id,u.id),console.log("[MessageQueueService] Queued message sent successfully",{queueEntryId:s,messageId:u.id}),u}async markMessageDelivered(e){let s=await this.messageQueueRepo.findByMessageId(e);s?(console.log(`[MessageQueueService] Marking message ${e} as delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await n.inngest.send({name:"message-queue/process-next",data:{clientId:s.clientId,queueName:s.queueName}}),console.log(`[MessageQueueService] Triggered next message for queue '${s.queueName}'`)):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async markMessageFailed(e,s){let t=await this.messageQueueRepo.findByMessageId(e);t?(console.log(`[MessageQueueService] Message ${e} failed:`,s),t.retryCount<t.maxRetries?(console.log(`[MessageQueueService] Retrying message (attempt ${t.retryCount+1}/${t.maxRetries})`),await this.messageQueueRepo.incrementRetry(t.id),await this.messageQueueRepo.updateStatus(t.id,"pending",void 0,s),await n.inngest.send({name:"message/delivery-failed",data:{messageId:e,clientId:t.clientId,providerMessageId:e,error:s||"Unknown error"}})):(console.log("[MessageQueueService] Max retries reached, marking as failed and moving to next"),await this.messageQueueRepo.updateStatus(t.id,"failed",void 0,s||"Max retries exceeded"),await n.inngest.send({name:"message-queue/process-next",data:{clientId:t.clientId,queueName:t.queueName}}))):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async checkStalledMessages(){let s=new Date(Date.now()-6e5),t=await this.messageQueueRepo.findStalled(s);if(0===t.length)return void console.log("[MessageQueueService] No stalled messages found");for(let s of(console.log(`[MessageQueueService] Found ${t.length} stalled messages`),t))try{if(!s.messageId){console.warn(`[MessageQueueService] Stalled entry ${s.id} has no messageId, marking as failed`),await this.messageQueueRepo.updateStatus(s.id,"failed",void 0,"No message ID found");continue}let{messageService:t}=await e.A(593853),a=t.messageRepo,n=await a.findById(s.messageId);if(!n||!n.providerMessageId){console.warn(`[MessageQueueService] Message ${s.messageId} not found or has no provider ID`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName);continue}console.log(`[MessageQueueService] Checking Twilio status for ${n.providerMessageId}`);let r=await i.twilioClient.getMessageStatus(n.providerMessageId);"delivered"===r.status?(console.log("[MessageQueueService] Twilio confirms delivery, updating queue"),await this.markMessageDelivered(s.messageId)):"failed"===r.status||"undelivered"===r.status?(console.log("[MessageQueueService] Twilio confirms failure, updating queue"),await this.markMessageFailed(s.messageId,`Stalled message status: ${r.status}`)):(console.log(`[MessageQueueService] Message still in transit (${r.status}), assuming delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName))}catch(e){console.error(`[MessageQueueService] Error checking stalled message ${s.id}:`,e),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName)}}async getQueueStatus(e,s){return await this.messageQueueRepo.getQueueStatus(e,s)}async clearQueue(e,s){console.log(`[MessageQueueService] Clearing completed queue '${s}' for client ${e}`),await this.messageQueueRepo.deleteCompleted(e,s)}}let u=r.getInstance();e.s(["MessageQueueService",()=>r,"messageQueueService",0,u],38330)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__27a0d390._.js.map