{"version":3,"sources":["../../../../../packages/shared/src/server/utils/sessionCrypto.ts","../../../../../packages/shared/src/server/repositories/userAuthRepository.ts","../../../../../packages/shared/src/server/repositories/referralRepository.ts","../../../../../packages/shared/src/server/repositories/pageVisitRepository.ts","../../../../../packages/shared/src/server/services/orchestration/weeklyMessageService.ts","../../../../../packages/shared/src/server/services/referral/referralService.ts","../../../../../packages/shared/src/server/models/referral.ts","../../../../../packages/shared/src/server/services/auth/userAuthService.ts","../../../../../packages/shared/src/server/services/auth/adminAuthService.ts"],"sourcesContent":["import crypto from 'crypto';\nimport { getDatabaseSecrets } from '@/server/config';\n\n/**\n * Session crypto utilities for encrypting and decrypting user IDs in session cookies\n * Uses AES-256-GCM for authenticated encryption\n */\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16; // For GCM mode\nconst AUTH_TAG_LENGTH = 16;\nconst KEY_LENGTH = 32; // 256 bits\n\n/**\n * Get the encryption key from config\n * In production, this should be a strong random key stored securely\n */\nfunction getEncryptionKey(): Buffer {\n  const { sessionEncryptionKey } = getDatabaseSecrets();\n\n  if (!sessionEncryptionKey) {\n    // For development, use a default key (NOT for production!)\n    console.warn('SESSION_ENCRYPTION_KEY not set, using development key');\n    return crypto.scryptSync('gymtext-dev-key', 'salt', KEY_LENGTH);\n  }\n\n  // If key is hex-encoded, decode it\n  if (sessionEncryptionKey.length === KEY_LENGTH * 2) {\n    return Buffer.from(sessionEncryptionKey, 'hex');\n  }\n\n  // Otherwise, derive key from string\n  return crypto.scryptSync(sessionEncryptionKey, 'salt', KEY_LENGTH);\n}\n\n/**\n * Encrypt a user ID for use in a session cookie\n * Returns a base64-encoded string containing IV + authTag + encrypted data\n */\nexport function encryptUserId(userId: string): string {\n  try {\n    const key = getEncryptionKey();\n    const iv = crypto.randomBytes(IV_LENGTH);\n\n    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n    let encrypted = cipher.update(userId, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n\n    const authTag = cipher.getAuthTag();\n\n    // Combine IV + authTag + encrypted data\n    const combined = Buffer.concat([\n      iv,\n      authTag,\n      Buffer.from(encrypted, 'hex')\n    ]);\n\n    return combined.toString('base64');\n  } catch (error) {\n    console.error('Error encrypting user ID:', error);\n    throw new Error('Failed to encrypt session');\n  }\n}\n\n/**\n * Decrypt a user ID from a session cookie\n * Returns the user ID or null if decryption fails\n */\nexport function decryptUserId(encryptedData: string): string | null {\n  try {\n    const key = getEncryptionKey();\n    const combined = Buffer.from(encryptedData, 'base64');\n\n    // Extract IV, authTag, and encrypted data\n    const iv = combined.subarray(0, IV_LENGTH);\n    const authTag = combined.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);\n    const encrypted = combined.subarray(IV_LENGTH + AUTH_TAG_LENGTH);\n\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(authTag);\n\n    let decrypted = decipher.update(encrypted.toString('hex'), 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  } catch (error) {\n    console.error('Error decrypting user ID:', error);\n    return null;\n  }\n}\n\n/**\n * Generate a secure random encryption key for SESSION_ENCRYPTION_KEY\n * This is a utility function for generating a new key - run once and store securely\n */\nexport function generateEncryptionKey(): string {\n  return crypto.randomBytes(KEY_LENGTH).toString('hex');\n}\n","import { BaseRepository } from './baseRepository';\n\n/**\n * Repository for managing user authentication codes\n * Handles storage and retrieval of SMS verification codes\n */\nexport class UserAuthRepository extends BaseRepository {\n  /**\n   * Create a new authentication code for a phone number\n   */\n  async createAuthCode(\n    phoneNumber: string,\n    code: string,\n    expiresAt: Date\n  ): Promise<void> {\n    await this.db\n      .insertInto('userAuthCodes')\n      .values({\n        phoneNumber,\n        code,\n        expiresAt,\n        createdAt: new Date(),\n      })\n      .execute();\n  }\n\n  /**\n   * Find a valid (non-expired) auth code for a phone number\n   * Returns the code if found and not expired, null otherwise\n   */\n  async findValidCode(\n    phoneNumber: string,\n    code: string\n  ): Promise<{ id: string; phoneNumber: string } | null> {\n    const result = await this.db\n      .selectFrom('userAuthCodes')\n      .select(['id', 'phoneNumber'])\n      .where('phoneNumber', '=', phoneNumber)\n      .where('code', '=', code)\n      .where('expiresAt', '>', new Date())\n      .executeTakeFirst();\n\n    return result || null;\n  }\n\n  /**\n   * Delete all auth codes for a phone number\n   * Used after successful verification or to clear old codes\n   */\n  async deleteCodesForPhone(phoneNumber: string): Promise<void> {\n    await this.db\n      .deleteFrom('userAuthCodes')\n      .where('phoneNumber', '=', phoneNumber)\n      .execute();\n  }\n\n  /**\n   * Delete all expired auth codes\n   * Should be run periodically to clean up the database\n   */\n  async deleteExpiredCodes(): Promise<number> {\n    const result = await this.db\n      .deleteFrom('userAuthCodes')\n      .where('expiresAt', '<', new Date())\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows || 0);\n  }\n\n  /**\n   * Count recent auth code requests for a phone number\n   * Used for rate limiting\n   */\n  async countRecentRequests(\n    phoneNumber: string,\n    since: Date\n  ): Promise<number> {\n    const result = await this.db\n      .selectFrom('userAuthCodes')\n      .select((eb) => eb.fn.countAll<number>().as('count'))\n      .where('phoneNumber', '=', phoneNumber)\n      .where('createdAt', '>=', since)\n      .executeTakeFirst();\n\n    return Number(result?.count || 0);\n  }\n}\n","import { BaseRepository } from './baseRepository';\nimport { Referral, NewReferral } from '../models/referral';\nimport { sql } from 'kysely';\n\n/**\n * Repository for managing referrals\n * Handles storage and retrieval of referral relationships\n */\nexport class ReferralRepository extends BaseRepository {\n  /**\n   * Create a new referral record\n   * Called when a referee signs up using a referral code\n   */\n  async create(referrerId: string, refereeId: string): Promise<Referral> {\n    const result = await this.db\n      .insertInto('referrals')\n      .values({\n        referrerId,\n        refereeId,\n        creditApplied: false,\n        creditAmountCents: 0,\n        createdAt: new Date(),\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Find a referral by referee ID\n   * Used by webhook to find the referral when crediting the referrer\n   */\n  async findByRefereeId(refereeId: string): Promise<Referral | null> {\n    const result = await this.db\n      .selectFrom('referrals')\n      .selectAll()\n      .where('refereeId', '=', refereeId)\n      .executeTakeFirst();\n\n    return result || null;\n  }\n\n  /**\n   * Find all referrals for a referrer\n   * Used for displaying referral stats on the /me page\n   */\n  async findByReferrerId(referrerId: string): Promise<Referral[]> {\n    return await this.db\n      .selectFrom('referrals')\n      .selectAll()\n      .where('referrerId', '=', referrerId)\n      .orderBy('createdAt', 'desc')\n      .execute();\n  }\n\n  /**\n   * Mark a referral as credited\n   * Called after successfully applying credit to the referrer's Stripe account\n   */\n  async markCreditApplied(id: string, amountCents: number): Promise<Referral> {\n    const result = await this.db\n      .updateTable('referrals')\n      .set({\n        creditApplied: true,\n        creditAmountCents: amountCents,\n        creditedAt: new Date(),\n      })\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Count credits earned by a referrer\n   * Only counts referrals where credit was actually applied\n   */\n  async countCreditsEarned(referrerId: string): Promise<number> {\n    const result = await this.db\n      .selectFrom('referrals')\n      .select(sql<number>`count(*)`.as('count'))\n      .where('referrerId', '=', referrerId)\n      .where('creditApplied', '=', true)\n      .executeTakeFirst();\n\n    return Number(result?.count || 0);\n  }\n\n  /**\n   * Count total referrals by a referrer (regardless of credit status)\n   */\n  async countByReferrer(referrerId: string): Promise<number> {\n    const result = await this.db\n      .selectFrom('referrals')\n      .select(sql<number>`count(*)`.as('count'))\n      .where('referrerId', '=', referrerId)\n      .executeTakeFirst();\n\n    return Number(result?.count || 0);\n  }\n\n  /**\n   * Check if a user has already been referred\n   * Each user can only be referred once\n   */\n  async hasBeenReferred(refereeId: string): Promise<boolean> {\n    const result = await this.db\n      .selectFrom('referrals')\n      .select('id')\n      .where('refereeId', '=', refereeId)\n      .executeTakeFirst();\n\n    return !!result;\n  }\n}\n","import { BaseRepository } from './baseRepository';\nimport type { NewPageVisit, PageVisit } from '@/server/models/pageVisit';\n\nexport class PageVisitRepository extends BaseRepository {\n  /**\n   * Record a new page visit\n   */\n  async record(visit: NewPageVisit): Promise<PageVisit> {\n    const result = await this.db\n      .insertInto('pageVisits')\n      .values(visit)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Get visits within a date range\n   */\n  async getVisitsByDateRange(\n    startDate: Date,\n    endDate: Date,\n    options?: { source?: string; limit?: number }\n  ): Promise<PageVisit[]> {\n    let query = this.db\n      .selectFrom('pageVisits')\n      .selectAll()\n      .where('createdAt', '>=', startDate)\n      .where('createdAt', '<=', endDate)\n      .orderBy('createdAt', 'desc');\n\n    if (options?.source) {\n      query = query.where('source', '=', options.source);\n    }\n\n    if (options?.limit) {\n      query = query.limit(options.limit);\n    }\n\n    return query.execute();\n  }\n\n  /**\n   * Get aggregated visit counts by source\n   */\n  async getVisitCountsBySource(\n    startDate: Date,\n    endDate: Date\n  ): Promise<{ source: string | null; count: number }[]> {\n    const results = await this.db\n      .selectFrom('pageVisits')\n      .select(['source'])\n      .select((eb) => eb.fn.count('id').as('count'))\n      .where('createdAt', '>=', startDate)\n      .where('createdAt', '<=', endDate)\n      .groupBy('source')\n      .orderBy('count', 'desc')\n      .execute();\n\n    return results.map((r) => ({\n      source: r.source,\n      count: Number(r.count),\n    }));\n  }\n\n  /**\n   * Get total visit count for a date range\n   */\n  async getTotalVisits(startDate: Date, endDate: Date): Promise<number> {\n    const result = await this.db\n      .selectFrom('pageVisits')\n      .select((eb) => eb.fn.count('id').as('count'))\n      .where('createdAt', '>=', startDate)\n      .where('createdAt', '<=', endDate)\n      .executeTakeFirst();\n\n    return Number(result?.count ?? 0);\n  }\n}\n","import { MessageService } from '../messaging/messageService';\nimport { UserService } from '../user/userService';\nimport { FitnessPlanService } from '../training/fitnessPlanService';\nimport { ProgressService } from '../training/progressService';\nimport { MicrocycleService } from '../training/microcycleService';\nimport { UserWithProfile } from '@/server/models/user';\nimport { inngest } from '@/server/connections/inngest/client';\nimport { messagingAgentService } from '@/server/services/agents/messaging';\nimport { now, getNextWeekStart } from '@/shared/utils/date';\n\ninterface MessageResult {\n  success: boolean;\n  userId: string;\n  error?: string;\n  messageIds?: string[];\n}\n\ninterface SchedulingResult {\n  scheduled: number;\n  failed: number;\n  duration: number;\n  errors: Array<{ userId: string; error: string }>;\n}\n\nexport class WeeklyMessageService {\n  private static instance: WeeklyMessageService;\n  private userService: UserService;\n  private messageService: MessageService;\n  private progressService: ProgressService;\n  private microcycleService: MicrocycleService;\n  private fitnessPlanService: FitnessPlanService;\n\n  private constructor() {\n    this.userService = UserService.getInstance();\n    this.messageService = MessageService.getInstance();\n    this.progressService = ProgressService.getInstance();\n    this.microcycleService = MicrocycleService.getInstance();\n    this.fitnessPlanService = FitnessPlanService.getInstance();\n  }\n\n  public static getInstance(): WeeklyMessageService {\n    if (!WeeklyMessageService.instance) {\n      WeeklyMessageService.instance = new WeeklyMessageService();\n    }\n    return WeeklyMessageService.instance;\n  }\n\n  /**\n   * Schedules weekly messages for all users in a given UTC hour on Sunday\n   * Returns metrics about the scheduling operation\n   */\n  public async scheduleMessagesForHour(utcHour: number): Promise<SchedulingResult> {\n    const startTime = Date.now();\n    const errors: Array<{ userId: string; error: string }> = [];\n    let scheduled = 0;\n    let failed = 0;\n\n    try {\n      // Get all users who should receive weekly messages this hour (Sunday only)\n      const users = await this.userService.getUsersForWeeklyMessage(utcHour);\n      console.log(`[WeeklyMessageService] Found ${users.length} users to schedule for hour ${utcHour} on Sunday`);\n\n      if (users.length === 0) {\n        return {\n          scheduled: 0,\n          failed: 0,\n          duration: Date.now() - startTime,\n          errors: []\n        };\n      }\n\n      // Map users to Inngest events\n      const events = users.map(user => ({\n        name: 'weekly/scheduled' as const,\n        data: {\n          userId: user.id,\n        },\n      }));\n\n      // Send all events to Inngest in batch\n      try {\n        const { ids } = await inngest.send(events);\n        scheduled = ids.length;\n        console.log(`[WeeklyMessageService] Scheduled ${scheduled} Inngest jobs`);\n      } catch (error) {\n        console.error('[WeeklyMessageService] Failed to schedule Inngest jobs:', error);\n        failed = events.length;\n        errors.push({\n          userId: 'batch',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n\n      return {\n        scheduled,\n        failed,\n        duration: Date.now() - startTime,\n        errors\n      };\n    } catch (error) {\n      console.error('[WeeklyMessageService] Error scheduling messages:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sends weekly check-in messages to a single user\n   *\n   * Flow:\n   * 1. Calculate next Sunday's date in user's timezone\n   * 2. Get progress for next week using date-based calculation\n   * 3. Get/create next week's microcycle\n   * 4. Check if it's a deload week\n   * 5. Generate personalized feedback message using AI agent\n   * 6. Retrieve breakdown message from stored microcycle.message\n   * 7. Send both messages with delay\n   */\n  public async sendWeeklyMessage(user: UserWithProfile): Promise<MessageResult> {\n    try {\n      console.log(`[WeeklyMessageService] Processing weekly message for user ${user.id}`);\n\n      // Step 1: Get the fitness plan\n      const plan = await this.fitnessPlanService.getCurrentPlan(user.id);\n      if (!plan) {\n        console.error(`[WeeklyMessageService] No fitness plan found for user ${user.id}`);\n        return {\n          success: false,\n          userId: user.id,\n          error: 'No fitness plan found'\n        };\n      }\n\n      // Step 2: Calculate next Sunday's date in user's timezone (start of next week)\n      const currentDate = now(user.timezone).toJSDate();\n      const nextSundayDate = getNextWeekStart(currentDate, user.timezone);\n\n      console.log(`[WeeklyMessageService] Getting next week's plan for ${nextSundayDate.toISOString()} for user ${user.id}`);\n\n      // Step 3: Get progress for next week using date-based calculation\n      const nextWeekProgress = await this.progressService.getProgressForDate(plan, nextSundayDate, user.timezone);\n      if (!nextWeekProgress) {\n        console.error(`[WeeklyMessageService] Could not calculate progress for next week for user ${user.id}`);\n        return {\n          success: false,\n          userId: user.id,\n          error: 'Could not determine next week\\'s training progress'\n        };\n      }\n\n      // Step 4: Get or create next week's microcycle\n      const { microcycle: nextWeekMicrocycle } = await this.progressService.getOrCreateMicrocycleForDate(\n        user.id,\n        plan,\n        nextSundayDate,\n        user.timezone\n      );\n\n      if (!nextWeekMicrocycle) {\n        console.error(`[WeeklyMessageService] Failed to get/create next week's microcycle for user ${user.id}`);\n        return {\n          success: false,\n          userId: user.id,\n          error: 'Could not generate next week\\'s training pattern'\n        };\n      }\n\n      // Step 5: Check if next week is a deload week\n      const isDeload = nextWeekMicrocycle.isDeload;\n\n      if (isDeload) {\n        console.log(`[WeeklyMessageService] User ${user.id} is entering a deload week (week ${nextWeekMicrocycle.absoluteWeek})`);\n      }\n\n      // Step 6: Generate feedback message using messaging agent service\n      const feedbackMessage = await messagingAgentService.generateWeeklyMessage(\n        user,\n        isDeload,\n        nextWeekMicrocycle.absoluteWeek\n      );\n\n      // Step 7: Get breakdown message from stored microcycle\n      const breakdownMessage = nextWeekMicrocycle.message;\n\n      if (!breakdownMessage) {\n        console.error(`[WeeklyMessageService] No breakdown message stored for microcycle ${nextWeekMicrocycle.id}`);\n        return {\n          success: false,\n          userId: user.id,\n          error: 'No breakdown message found for next week\\'s microcycle'\n        };\n      }\n\n      // Step 8: Send both messages with delay\n      const messageIds: string[] = [];\n\n      // Send feedback message first\n      const feedbackMsg = await this.messageService.sendMessage(user, feedbackMessage);\n      messageIds.push(feedbackMsg.id);\n      console.log(`[WeeklyMessageService] Sent feedback message to user ${user.id}`);\n\n      // Small delay before sending breakdown\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Send breakdown message (from stored microcycle.message)\n      const breakdownMsg = await this.messageService.sendMessage(user, breakdownMessage);\n      messageIds.push(breakdownMsg.id);\n      console.log(`[WeeklyMessageService] Sent breakdown message to user ${user.id}`);\n\n      console.log(`[WeeklyMessageService] Successfully sent weekly messages to user ${user.id}`);\n      return {\n        success: true,\n        userId: user.id,\n        messageIds\n      };\n    } catch (error) {\n      console.error(`[WeeklyMessageService] Error sending weekly message to user ${user.id}:`, error);\n      return {\n        success: false,\n        userId: user.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const weeklyMessageService = WeeklyMessageService.getInstance();\n","import Stripe from 'stripe';\nimport { ReferralRepository } from '@/server/repositories/referralRepository';\nimport { UserRepository } from '@/server/repositories/userRepository';\nimport { getStripeSecrets } from '@/server/config';\nimport { getUrlsConfig } from '@/shared/config';\nimport {\n  ReferralStats,\n  MAX_REFERRAL_CREDITS,\n  REFERRAL_CREDIT_AMOUNT_CENTS,\n} from '@/server/models/referral';\n\nconst { secretKey } = getStripeSecrets();\nconst stripe = new Stripe(secretKey, {\n  apiVersion: '2023-10-16',\n});\n\n// Stripe coupon ID for referee's first month free\nconst REFERRAL_COUPON_ID = 'REFERRAL_FREE_MONTH';\n\nexport interface ValidateReferralResult {\n  valid: boolean;\n  referrerId?: string;\n  referrerName?: string;\n  error?: string;\n}\n\nexport interface CreditReferrerResult {\n  success: boolean;\n  creditId?: string;\n  error?: string;\n}\n\n/**\n * ReferralService\n *\n * Manages the referral program where users can share their referral code.\n * When someone signs up with a referral code:\n * - The referee (new user) gets their first month free via Stripe coupon\n * - The referrer gets a credit applied when the referee's payment succeeds\n *\n * Users can earn up to 12 free months via referrals.\n */\nexport class ReferralService {\n  private static instance: ReferralService;\n  private referralRepo: ReferralRepository;\n  private userRepo: UserRepository;\n\n  private constructor() {\n    this.referralRepo = new ReferralRepository();\n    this.userRepo = new UserRepository();\n  }\n\n  public static getInstance(): ReferralService {\n    if (!ReferralService.instance) {\n      ReferralService.instance = new ReferralService();\n    }\n    return ReferralService.instance;\n  }\n\n  /**\n   * Get or create a user's referral code\n   */\n  async getOrCreateReferralCode(userId: string): Promise<string | null> {\n    return this.userRepo.getOrCreateReferralCode(userId);\n  }\n\n  /**\n   * Get referral stats for displaying on the /me page\n   */\n  async getReferralStats(userId: string): Promise<ReferralStats | null> {\n    const referralCode = await this.userRepo.getOrCreateReferralCode(userId);\n    if (!referralCode) {\n      return null;\n    }\n\n    const { publicBaseUrl, baseUrl } = getUrlsConfig();\n    const resolvedBaseUrl = publicBaseUrl || baseUrl;\n    const referralLink = `${resolvedBaseUrl}/r/${referralCode}`;\n\n    const completedReferrals = await this.referralRepo.countByReferrer(userId);\n    const creditsEarned = await this.referralRepo.countCreditsEarned(userId);\n    const creditsRemaining = Math.max(0, MAX_REFERRAL_CREDITS - creditsEarned);\n\n    return {\n      referralCode,\n      referralLink,\n      completedReferrals,\n      creditsEarned,\n      creditsRemaining,\n    };\n  }\n\n  /**\n   * Validate a referral code before signup\n   * Checks that the code exists and prevents self-referral\n   */\n  async validateReferralCode(\n    code: string,\n    signupPhone?: string\n  ): Promise<ValidateReferralResult> {\n    if (!code || code.length !== 6) {\n      return { valid: false, error: 'Invalid referral code format' };\n    }\n\n    const referrer = await this.userRepo.findByReferralCode(code.toUpperCase());\n    if (!referrer) {\n      return { valid: false, error: 'Referral code not found' };\n    }\n\n    // Prevent self-referral\n    if (signupPhone && referrer.phoneNumber === signupPhone) {\n      return { valid: false, error: 'Cannot use your own referral code' };\n    }\n\n    return {\n      valid: true,\n      referrerId: referrer.id,\n      referrerName: referrer.name,\n    };\n  }\n\n  /**\n   * Complete a referral when a referee signs up\n   * Creates the referral record in the database\n   */\n  async completeReferral(\n    referralCode: string,\n    refereeUserId: string\n  ): Promise<void> {\n    const referrer = await this.userRepo.findByReferralCode(\n      referralCode.toUpperCase()\n    );\n    if (!referrer) {\n      console.error(\n        `[ReferralService] Cannot complete referral: code ${referralCode} not found`\n      );\n      return;\n    }\n\n    // Check if referee has already been referred\n    const alreadyReferred = await this.referralRepo.hasBeenReferred(refereeUserId);\n    if (alreadyReferred) {\n      console.log(\n        `[ReferralService] User ${refereeUserId} has already been referred, skipping`\n      );\n      return;\n    }\n\n    await this.referralRepo.create(referrer.id, refereeUserId);\n    console.log(\n      `[ReferralService] Referral completed: ${referrer.id} -> ${refereeUserId}`\n    );\n  }\n\n  /**\n   * Apply credit to the referrer's Stripe account\n   * Called by webhook when referee's payment succeeds\n   */\n  async creditReferrer(refereeUserId: string): Promise<CreditReferrerResult> {\n    // Find the referral for this referee\n    const referral = await this.referralRepo.findByRefereeId(refereeUserId);\n    if (!referral) {\n      console.log(\n        `[ReferralService] No referral found for referee ${refereeUserId}`\n      );\n      return { success: true }; // Not an error, just no referral\n    }\n\n    // Check if credit already applied\n    if (referral.creditApplied) {\n      console.log(\n        `[ReferralService] Credit already applied for referral ${referral.id}`\n      );\n      return { success: true };\n    }\n\n    // Check if referrer can still earn credits\n    const creditsEarned = await this.referralRepo.countCreditsEarned(\n      referral.referrerId\n    );\n    if (creditsEarned >= MAX_REFERRAL_CREDITS) {\n      console.log(\n        `[ReferralService] Referrer ${referral.referrerId} has reached max credits (${MAX_REFERRAL_CREDITS})`\n      );\n      // Still mark the referral, but don't apply credit\n      return { success: true };\n    }\n\n    // Get referrer's Stripe customer ID\n    const referrer = await this.userRepo.findById(referral.referrerId);\n    if (!referrer?.stripeCustomerId) {\n      console.error(\n        `[ReferralService] Referrer ${referral.referrerId} has no Stripe customer ID`\n      );\n      return { success: false, error: 'Referrer has no Stripe customer' };\n    }\n\n    try {\n      // Create invoice credit in Stripe\n      const credit = await stripe.customers.createBalanceTransaction(\n        referrer.stripeCustomerId,\n        {\n          amount: -REFERRAL_CREDIT_AMOUNT_CENTS, // Negative = credit\n          currency: 'usd',\n          description: 'Referral credit - 1 free month',\n        }\n      );\n\n      // Mark referral as credited\n      await this.referralRepo.markCreditApplied(\n        referral.id,\n        REFERRAL_CREDIT_AMOUNT_CENTS\n      );\n\n      console.log(\n        `[ReferralService] Applied $${(REFERRAL_CREDIT_AMOUNT_CENTS / 100).toFixed(2)} credit to referrer ${referrer.id}`\n      );\n\n      return { success: true, creditId: credit.id };\n    } catch (error) {\n      console.error('[ReferralService] Failed to apply credit:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Get or create the Stripe coupon for referee's first month free\n   */\n  async getRefereeCouponId(): Promise<string> {\n    try {\n      // Try to retrieve existing coupon\n      await stripe.coupons.retrieve(REFERRAL_COUPON_ID);\n      return REFERRAL_COUPON_ID;\n    } catch {\n      // Create if doesn't exist\n      await stripe.coupons.create({\n        id: REFERRAL_COUPON_ID,\n        amount_off: REFERRAL_CREDIT_AMOUNT_CENTS,\n        currency: 'usd',\n        duration: 'once',\n        name: 'Referral - First Month Free',\n      });\n      console.log('[ReferralService] Created referral coupon in Stripe');\n      return REFERRAL_COUPON_ID;\n    }\n  }\n\n  /**\n   * Check if a user can still earn referral credits\n   */\n  async canEarnCredits(userId: string): Promise<boolean> {\n    const creditsEarned = await this.referralRepo.countCreditsEarned(userId);\n    return creditsEarned < MAX_REFERRAL_CREDITS;\n  }\n}\n\nexport const referralService = ReferralService.getInstance();\n","/**\n * Referral Model\n *\n * Represents a referral relationship between two users.\n * Tracks when a user signs up via another user's referral link\n * and whether the referrer has been credited.\n */\n\nimport { Selectable, Insertable, Updateable } from 'kysely';\nimport { Referrals } from './_types';\n\n/**\n * Type for selecting referrals from the database\n */\nexport type Referral = Selectable<Referrals>;\n\n/**\n * Type for inserting referrals into the database\n */\nexport type NewReferral = Insertable<Referrals>;\n\n/**\n * Type for updating referrals in the database\n */\nexport type ReferralUpdate = Updateable<Referrals>;\n\n/**\n * Stats about a user's referral activity\n */\nexport interface ReferralStats {\n  /** User's unique referral code */\n  referralCode: string;\n  /** Full referral link URL */\n  referralLink: string;\n  /** Number of completed referrals */\n  completedReferrals: number;\n  /** Number of credits earned (referrals where credit was applied) */\n  creditsEarned: number;\n  /** Number of credits remaining until max (12 - earned) */\n  creditsRemaining: number;\n}\n\n/**\n * Maximum number of referral credits a user can earn\n */\nexport const MAX_REFERRAL_CREDITS = 12;\n\n/**\n * Amount credited per referral in cents ($19.99)\n */\nexport const REFERRAL_CREDIT_AMOUNT_CENTS = 1999;\n","import { UserAuthRepository } from '@/server/repositories/userAuthRepository';\nimport { UserRepository } from '@/server/repositories/userRepository';\nimport { twilioClient } from '@/server/connections/twilio/twilio';\nimport { encryptUserId } from '@/server/utils/sessionCrypto';\nimport { adminAuthService } from './adminAuthService';\nimport { getEnvironmentSettings } from '@/server/config';\nimport { getAdminConfig } from '@/shared/config';\n\n/**\n * Service for handling user authentication via SMS verification codes\n */\nexport class UserAuthService {\n  private authRepository: UserAuthRepository;\n  private userRepository: UserRepository;\n\n  // Rate limiting configuration\n  private readonly MAX_REQUESTS_PER_WINDOW = 3;\n  private readonly RATE_LIMIT_WINDOW_MINUTES = 15;\n  private readonly CODE_EXPIRY_MINUTES = 10;\n  private readonly CODE_LENGTH = 6;\n\n  // Dev mode detection\n  private readonly isDev = !getEnvironmentSettings().isProduction;\n  private readonly devBypassCode = getAdminConfig().devBypassCode || '000000';\n\n  constructor() {\n    this.authRepository = new UserAuthRepository();\n    this.userRepository = new UserRepository();\n  }\n\n  /**\n   * Generate a random 6-digit verification code\n   */\n  private generateCode(): string {\n    const min = 100000;\n    const max = 999999;\n    return Math.floor(Math.random() * (max - min + 1) + min).toString();\n  }\n\n  /**\n   * Request a verification code to be sent to a phone number\n   * Expects phone number to already be normalized to E.164 format (+1XXXXXXXXXX)\n   * Returns success status and optional error message\n   */\n  async requestVerificationCode(\n    phoneNumber: string\n  ): Promise<{ success: boolean; message?: string; userId?: string }> {\n    try {\n      // Phone number should already be normalized by API route\n      // Defensive check: ensure it's in E.164 format\n      if (!phoneNumber.startsWith('+1')) {\n        console.error('[UserAuth] Phone number not properly normalized:', phoneNumber);\n        return {\n          success: false,\n          message: 'Internal error: phone number format invalid',\n        };\n      }\n\n      // Check if user exists with this phone number OR if it's an admin phone\n      const user = await this.userRepository.findByPhoneNumber(phoneNumber);\n      const isAdmin = adminAuthService.isPhoneWhitelisted(phoneNumber);\n\n      if (!user && !isAdmin) {\n        return {\n          success: false,\n          message: 'Phone number not registered. Please sign up first.',\n        };\n      }\n\n      // Check rate limiting\n      const rateLimitWindow = new Date(\n        Date.now() - this.RATE_LIMIT_WINDOW_MINUTES * 60 * 1000\n      );\n      const recentRequests = await this.authRepository.countRecentRequests(\n        phoneNumber,\n        rateLimitWindow\n      );\n\n      if (recentRequests >= this.MAX_REQUESTS_PER_WINDOW) {\n        return {\n          success: false,\n          message: `Too many requests. Please try again in ${this.RATE_LIMIT_WINDOW_MINUTES} minutes.`,\n        };\n      }\n\n      // Generate verification code\n      const code = this.generateCode();\n      const expiresAt = new Date(Date.now() + this.CODE_EXPIRY_MINUTES * 60 * 1000);\n\n      // Store code in database\n      await this.authRepository.createAuthCode(phoneNumber, code, expiresAt);\n\n      // Send SMS with code\n      const message = `Your GymText verification code is: ${code}\\n\\nThis code expires in ${this.CODE_EXPIRY_MINUTES} minutes.`;\n      await twilioClient.sendSMS(phoneNumber, message);\n\n      // In dev mode, log the code to console for easy testing\n      if (this.isDev) {\n        console.log(`[UserAuth:Dev] ðŸ”‘ Verification code for ${phoneNumber}: ${code}`);\n        console.log(`[UserAuth:Dev] ðŸ’¡ Tip: You can also use magic code \"${this.devBypassCode}\" in dev mode`);\n      }\n\n      return {\n        success: true,\n        userId: user?.id, // May be undefined for admin-only phones\n      };\n    } catch (error) {\n      console.error('Error requesting verification code:', error);\n      return {\n        success: false,\n        message: 'Failed to send verification code. Please try again.',\n      };\n    }\n  }\n\n  /**\n   * Verify a code and return the user ID if valid\n   * Expects phone number to already be normalized to E.164 format (+1XXXXXXXXXX)\n   */\n  async verifyCode(\n    phoneNumber: string,\n    code: string\n  ): Promise<{ success: boolean; message?: string; userId?: string }> {\n    try {\n      // Phone number should already be normalized by API route\n      // Defensive check: ensure it's in E.164 format\n      if (!phoneNumber.startsWith('+1')) {\n        console.error('[UserAuth] Phone number not properly normalized:', phoneNumber);\n        return {\n          success: false,\n          message: 'Internal error: phone number format invalid',\n        };\n      }\n\n      // Validate code format\n      if (code.length !== this.CODE_LENGTH || !/^\\d+$/.test(code)) {\n        return {\n          success: false,\n          message: 'Invalid code format. Code must be 6 digits.',\n        };\n      }\n\n      // DEV MODE: Accept magic bypass code\n      if (this.isDev && code === this.devBypassCode) {\n        console.log(`[UserAuth:Dev] âœ… Magic bypass code accepted for ${phoneNumber}`);\n\n        // Get user by phone number (or return success for admin phones)\n        const user = await this.userRepository.findByPhoneNumber(phoneNumber);\n\n        // Clean up any existing codes for this phone\n        await this.authRepository.deleteCodesForPhone(phoneNumber);\n\n        return {\n          success: true,\n          userId: user?.id, // May be undefined for admin-only phones\n        };\n      }\n\n      // NORMAL FLOW: Find valid code in database\n      const authCode = await this.authRepository.findValidCode(\n        phoneNumber,\n        code\n      );\n\n      if (!authCode) {\n        return {\n          success: false,\n          message: 'Invalid or expired verification code.',\n        };\n      }\n\n      // Get user by phone number\n      const user = await this.userRepository.findByPhoneNumber(phoneNumber);\n\n      if (!user) {\n        return {\n          success: false,\n          message: 'User not found.',\n        };\n      }\n\n      // Delete all codes for this phone number (cleanup)\n      await this.authRepository.deleteCodesForPhone(phoneNumber);\n\n      return {\n        success: true,\n        userId: user.id,\n      };\n    } catch (error) {\n      console.error('Error verifying code:', error);\n      return {\n        success: false,\n        message: 'Failed to verify code. Please try again.',\n      };\n    }\n  }\n\n  /**\n   * Create an encrypted session token for a user ID\n   */\n  createSessionToken(userId: string): string {\n    return encryptUserId(userId);\n  }\n\n  /**\n   * Clean up expired auth codes (should be run periodically)\n   */\n  async cleanupExpiredCodes(): Promise<number> {\n    try {\n      const deletedCount = await this.authRepository.deleteExpiredCodes();\n      console.log(`Cleaned up ${deletedCount} expired auth codes`);\n      return deletedCount;\n    } catch (error) {\n      console.error('Error cleaning up expired codes:', error);\n      return 0;\n    }\n  }\n}\n\n// Export singleton instance\nexport const userAuthService = new UserAuthService();\n","import { UserAuthRepository } from '@/server/repositories/userAuthRepository';\nimport { twilioClient } from '@/server/connections/twilio/twilio';\nimport { getEnvironmentSettings } from '@/server/config';\nimport { getAdminConfig } from '@/shared/config';\n\n/**\n * Service for handling admin authentication via SMS verification codes\n * Admins are verified by phone number whitelist (no user account required)\n */\nexport class AdminAuthService {\n  private authRepository: UserAuthRepository;\n\n  // Rate limiting configuration\n  private readonly MAX_REQUESTS_PER_WINDOW = 3;\n  private readonly RATE_LIMIT_WINDOW_MINUTES = 15;\n  private readonly CODE_EXPIRY_MINUTES = 10;\n  private readonly CODE_LENGTH = 6;\n\n  // Dev mode detection\n  private readonly isDev = !getEnvironmentSettings().isProduction;\n  private readonly devBypassCode = getAdminConfig().devBypassCode || '000000';\n\n  constructor() {\n    this.authRepository = new UserAuthRepository();\n  }\n\n  /**\n   * Check if a phone number is in the admin whitelist\n   * Expects phone number to already be normalized to E.164 format (+1XXXXXXXXXX)\n   */\n  isPhoneWhitelisted(phoneNumber: string): boolean {\n    const { phoneNumbers } = getAdminConfig();\n\n    if (phoneNumbers.length === 0) {\n      console.warn('[AdminAuth] ADMIN_PHONE_NUMBERS not configured');\n      return false;\n    }\n\n    // Phone number should already be normalized - just check whitelist\n    return phoneNumbers.includes(phoneNumber);\n  }\n\n  /**\n   * Generate a random 6-digit verification code\n   */\n  private generateCode(): string {\n    const min = 100000;\n    const max = 999999;\n    return Math.floor(Math.random() * (max - min + 1) + min).toString();\n  }\n\n  /**\n   * Request a verification code for admin login\n   * Only sends codes to whitelisted phone numbers\n   * Expects phone number to already be normalized to E.164 format (+1XXXXXXXXXX)\n   */\n  async requestCode(\n    phoneNumber: string\n  ): Promise<{ success: boolean; message?: string }> {\n    try {\n      // Phone number should already be normalized by API route\n      // Defensive check: ensure it's in E.164 format\n      if (!phoneNumber.startsWith('+1')) {\n        console.error('[AdminAuth] Phone number not properly normalized:', phoneNumber);\n        return {\n          success: false,\n          message: 'Internal error: phone number format invalid',\n        };\n      }\n\n      // Check whitelist FIRST - reject if not authorized\n      if (!this.isPhoneWhitelisted(phoneNumber)) {\n        console.warn(`[AdminAuth] Unauthorized admin login attempt: ${phoneNumber}`);\n        return {\n          success: false,\n          message: 'Phone number not authorized for admin access.',\n        };\n      }\n\n      // Check rate limiting\n      const rateLimitWindow = new Date(\n        Date.now() - this.RATE_LIMIT_WINDOW_MINUTES * 60 * 1000\n      );\n      const recentRequests = await this.authRepository.countRecentRequests(\n        phoneNumber,\n        rateLimitWindow\n      );\n\n      if (recentRequests >= this.MAX_REQUESTS_PER_WINDOW) {\n        return {\n          success: false,\n          message: `Too many requests. Please try again in ${this.RATE_LIMIT_WINDOW_MINUTES} minutes.`,\n        };\n      }\n\n      // Generate verification code\n      const code = this.generateCode();\n      const expiresAt = new Date(Date.now() + this.CODE_EXPIRY_MINUTES * 60 * 1000);\n\n      // Store code in database\n      await this.authRepository.createAuthCode(phoneNumber, code, expiresAt);\n\n      // Send SMS with code\n      const message = `Your GymText admin verification code is: ${code}\\n\\nThis code expires in ${this.CODE_EXPIRY_MINUTES} minutes.`;\n      await twilioClient.sendSMS(phoneNumber, message);\n\n      console.log(`[AdminAuth] Verification code sent to ${phoneNumber}`);\n\n      // In dev mode, log the code to console for easy testing\n      if (this.isDev) {\n        console.log(`[AdminAuth:Dev] ðŸ”‘ Verification code for ${phoneNumber}: ${code}`);\n        console.log(`[AdminAuth:Dev] ðŸ’¡ Tip: You can also use magic code \"${this.devBypassCode}\" in dev mode`);\n      }\n\n      return {\n        success: true,\n      };\n    } catch (error) {\n      console.error('[AdminAuth] Error requesting verification code:', error);\n      return {\n        success: false,\n        message: 'Failed to send verification code. Please try again.',\n      };\n    }\n  }\n\n  /**\n   * Verify a code for admin login\n   * Does not require or create a user account\n   * Expects phone number to already be normalized to E.164 format (+1XXXXXXXXXX)\n   */\n  async verifyCode(\n    phoneNumber: string,\n    code: string\n  ): Promise<{ success: boolean; message?: string }> {\n    try {\n      // Phone number should already be normalized by API route\n      // Defensive check: ensure it's in E.164 format\n      if (!phoneNumber.startsWith('+1')) {\n        console.error('[AdminAuth] Phone number not properly normalized:', phoneNumber);\n        return {\n          success: false,\n          message: 'Internal error: phone number format invalid',\n        };\n      }\n\n      // Double-check whitelist (belt and suspenders)\n      if (!this.isPhoneWhitelisted(phoneNumber)) {\n        console.warn(`[AdminAuth] Unauthorized verification attempt: ${phoneNumber}`);\n        return {\n          success: false,\n          message: 'Phone number not authorized for admin access.',\n        };\n      }\n\n      // Validate code format\n      if (code.length !== this.CODE_LENGTH || !/^\\d+$/.test(code)) {\n        return {\n          success: false,\n          message: 'Invalid code format. Code must be 6 digits.',\n        };\n      }\n\n      // DEV MODE: Accept magic bypass code\n      if (this.isDev && code === this.devBypassCode) {\n        console.log(`[AdminAuth:Dev] âœ… Magic bypass code accepted for ${phoneNumber}`);\n\n        // Clean up any existing codes for this phone\n        await this.authRepository.deleteCodesForPhone(phoneNumber);\n\n        return {\n          success: true,\n        };\n      }\n\n      // NORMAL FLOW: Find valid code in database\n      const authCode = await this.authRepository.findValidCode(\n        phoneNumber,\n        code\n      );\n\n      if (!authCode) {\n        return {\n          success: false,\n          message: 'Invalid or expired verification code.',\n        };\n      }\n\n      // Delete all codes for this phone number (cleanup)\n      await this.authRepository.deleteCodesForPhone(phoneNumber);\n\n      console.log(`[AdminAuth] Admin verified: ${phoneNumber}`);\n\n      return {\n        success: true,\n      };\n    } catch (error) {\n      console.error('[AdminAuth] Error verifying code:', error);\n      return {\n        success: false,\n        message: 'Failed to verify code. Please try again.',\n      };\n    }\n  }\n\n  /**\n   * Clean up expired auth codes (should be run periodically)\n   */\n  async cleanupExpiredCodes(): Promise<number> {\n    try {\n      const deletedCount = await this.authRepository.deleteExpiredCodes();\n      console.log(`[AdminAuth] Cleaned up ${deletedCount} expired auth codes`);\n      return deletedCount;\n    } catch (error) {\n      console.error('[AdminAuth] Error cleaning up expired codes:', error);\n      return 0;\n    }\n  }\n}\n\n// Export singleton instance\nexport const adminAuthService = new AdminAuthService();\n"],"names":[],"mappings":"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"}