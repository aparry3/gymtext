module.exports=[898990,e=>{"use strict";var s=e.i(201236),t=e.i(80643),r=e.i(172709),a=e.i(125720),i=e.i(823525),n=e.i(108436);e.i(249805);var o=e.i(884031),u=e.i(38330);class c{static instance;fitnessPlanService;messageService;dailyMessageService;workoutInstanceService;progressService;constructor(){this.fitnessPlanService=s.FitnessPlanService.getInstance(),this.progressService=n.ProgressService.getInstance(),this.messageService=t.MessageService.getInstance(),this.dailyMessageService=r.DailyMessageService.getInstance(),this.workoutInstanceService=a.WorkoutInstanceService.getInstance()}static getInstance(){return c.instance||(c.instance=new c),c.instance}async createFitnessPlan(e){console.log(`[Onboarding] Creating fitness plan for ${e.id}`);try{await this.fitnessPlanService.createFitnessPlan(e),console.log(`[Onboarding] Successfully created fitness plan for ${e.id}`)}catch(s){throw console.error(`[Onboarding] Failed to create fitness plan for ${e.id}:`,s),s}}async createFirstMicrocycle(e){console.log(`[Onboarding] Creating first microcycle for ${e.id}`);try{let s=await this.fitnessPlanService.getCurrentPlan(e.id);if(!s)throw Error(`No fitness plan found for user ${e.id}`);let t=(0,i.now)(e.timezone).toJSDate(),{microcycle:r}=await this.progressService.getOrCreateMicrocycleForDate(e.id,s,t,e.timezone);if(!r)throw Error("Failed to create first microcycle");console.log(`[Onboarding] Successfully created first microcycle for ${e.id}`)}catch(s){throw console.error(`[Onboarding] Failed to create first microcycle for ${e.id}:`,s),s}}async createFirstWorkout(e){console.log(`[Onboarding] Creating first workout for ${e.id}`);try{let s=(0,i.now)(e.timezone).startOf("day");if(!await this.workoutInstanceService.generateWorkoutForDate(e,s))throw Error("Failed to create first workout");console.log(`[Onboarding] Successfully created first workout for ${e.id}`)}catch(s){throw console.error(`[Onboarding] Failed to create first workout for ${e.id}:`,s),s}}async sendOnboardingMessages(e){console.log(`[Onboarding] Sending onboarding messages to ${e.id}`);try{let s=await this.prepareCombinedPlanMicrocycleMessage(e),t=await this.prepareWorkoutMessage(e);await u.messageQueueService.enqueueMessages(e.id,[{content:s},{content:t}],"onboarding"),console.log(`[Onboarding] Successfully queued onboarding messages for ${e.id}`)}catch(s){throw console.error(`[Onboarding] Failed to send onboarding messages to ${e.id}:`,s),s}}async prepareCombinedPlanMicrocycleMessage(e){let s=await this.fitnessPlanService.getCurrentPlan(e.id);if(!s)throw Error(`No fitness plan found for user ${e.id}`);if(!s.message)throw Error(`No plan message found for user ${e.id}`);let t=(0,i.now)(e.timezone).toJSDate(),{microcycle:r}=await this.progressService.getOrCreateMicrocycleForDate(e.id,s,t,e.timezone);if(!r)throw Error(`No microcycle found for user ${e.id}`);if(!r.message)throw Error(`No microcycle message found for user ${e.id}`);let a=(0,i.getDayOfWeek)(void 0,e.timezone),n=await o.messagingAgentService.generatePlanMicrocycleCombinedMessage(s.message,r.message,a);return console.log(`[Onboarding] Prepared combined plan+microcycle message for ${e.id}`),n}async prepareWorkoutMessage(e){let s=(0,i.startOfDay)((0,i.now)(e.timezone).toJSDate(),e.timezone),t=await this.dailyMessageService.getTodaysWorkout(e.id,s);if(!t)throw Error(`No workout found for user ${e.id} on ${s.toISOString()}`);if(!t.message)throw Error(`No workout message found for ${t.id}`);return console.log(`[Onboarding] Prepared workout message for ${e.id}`),t.message}}c.getInstance(),e.s(["OnboardingService",()=>c])},23250,e=>{"use strict";var s=e.i(13423);class t{static instance;repository;constructor(){this.repository=new s.OnboardingRepository}static getInstance(){return t.instance||(t.instance=new t),t.instance}async createOnboardingRecord(e,s){return console.log(`[OnboardingDataService] Creating onboarding record for user ${e}`),await this.repository.create(e,s)}async markStarted(e){return console.log(`[OnboardingDataService] Marking onboarding started for user ${e}`),await this.repository.markStarted(e)}async updateCurrentStep(e,s){return console.log(`[OnboardingDataService] Updating step to ${s} for user ${e}`),await this.repository.updateCurrentStep(e,s)}async markCompleted(e){return console.log(`[OnboardingDataService] Marking onboarding completed for user ${e}`),await this.repository.markCompleted(e)}async updateStatus(e,s,t){return console.log(`[OnboardingDataService] Updating status to '${s}' for user ${e}`),await this.repository.updateStatus(e,s,t)}async getStatus(e){let s=await this.repository.findByClientId(e);return s?s.status:null}async findByClientId(e){return await this.repository.findByClientId(e)}async getSignupData(e){return await this.repository.getSignupData(e)}async clearSignupData(e){return console.log(`[OnboardingDataService] Clearing signup data for user ${e}`),await this.repository.clearSignupData(e)}async markMessagesSent(e){return console.log(`[OnboardingDataService] Marking messages sent for user ${e}`),await this.repository.markMessagesSent(e)}async hasMessagesSent(e){return await this.repository.hasMessagesSent(e)}async delete(e){return console.log(`[OnboardingDataService] Deleting onboarding record for user ${e}`),await this.repository.delete(e)}}let r=t.getInstance();e.s(["onboardingDataService",0,r])},961691,e=>{"use strict";var s=e.i(46308);class t extends s.BaseRepository{async create(e){let s={clientId:e.clientId,stripeSubscriptionId:e.stripeSubscriptionId,status:e.status,planType:e.planType,currentPeriodStart:e.currentPeriodStart,currentPeriodEnd:e.currentPeriodEnd};return await this.db.insertInto("subscriptions").values(s).returningAll().executeTakeFirstOrThrow()}async updateByStripeId(e,s){return await this.db.updateTable("subscriptions").set(s).where("stripeSubscriptionId","=",e).returningAll().executeTakeFirstOrThrow()}async findByClientId(e){return await this.db.selectFrom("subscriptions").selectAll().where("clientId","=",e).orderBy("createdAt","desc").execute()}async findByStripeId(e){return await this.db.selectFrom("subscriptions").selectAll().where("stripeSubscriptionId","=",e).executeTakeFirst()??null}async getActiveSubscription(e){return await this.db.selectFrom("subscriptions").selectAll().where("clientId","=",e).where("status","=","active").orderBy("createdAt","desc").executeTakeFirst()??null}async hasActiveSubscription(e){return null!==await this.getActiveSubscription(e)}async cancel(e,s){return await this.db.updateTable("subscriptions").set({status:"canceled",canceledAt:s}).where("stripeSubscriptionId","=",e).returningAll().executeTakeFirstOrThrow()}async scheduleCancellation(e){return await this.db.updateTable("subscriptions").set({status:"cancel_pending"}).where("stripeSubscriptionId","=",e).returningAll().executeTakeFirstOrThrow()}async reactivate(e){return await this.db.updateTable("subscriptions").set({status:"active"}).where("stripeSubscriptionId","=",e).returningAll().executeTakeFirstOrThrow()}async findActiveForMessaging(e){return await this.db.selectFrom("subscriptions").selectAll().where("clientId","=",e).where("status","=","active").orderBy("createdAt","desc").executeTakeFirst()??null}}e.s(["SubscriptionRepository",()=>t])},38330,94510,e=>{"use strict";var s=e.i(46308);class t extends s.BaseRepository{async create(e){return await this.db.insertInto("messageQueues").values(e).returningAll().executeTakeFirstOrThrow()}async createMany(e){return 0===e.length?[]:await this.db.insertInto("messageQueues").values(e).returningAll().execute()}async findById(e){return await this.db.selectFrom("messageQueues").selectAll().where("id","=",e).executeTakeFirst()}async findByMessageId(e){return await this.db.selectFrom("messageQueues").selectAll().where("messageId","=",e).executeTakeFirst()}async findPendingByClient(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").execute()}async findAllPending(e){let s=this.db.selectFrom("messageQueues").selectAll().where("status","=","pending");return e.clientId&&(s=s.where("clientId","=",e.clientId)),await s.orderBy("createdAt","desc").limit(e.limit||100).offset(e.offset||0).execute()}async findAllPendingWithUserInfo(e){let s=this.db.selectFrom("messageQueues").innerJoin("users","users.id","messageQueues.clientId").select(["messageQueues.id","messageQueues.clientId","messageQueues.queueName","messageQueues.sequenceNumber","messageQueues.messageContent","messageQueues.mediaUrls","messageQueues.status","messageQueues.messageId","messageQueues.retryCount","messageQueues.maxRetries","messageQueues.timeoutMinutes","messageQueues.errorMessage","messageQueues.createdAt","messageQueues.sentAt","messageQueues.deliveredAt","users.name as userName","users.phoneNumber as userPhone"]).where("messageQueues.status","=","pending");return e.clientId&&(s=s.where("messageQueues.clientId","=",e.clientId)),await s.orderBy("messageQueues.createdAt","desc").limit(e.limit||100).execute()}async findNextPending(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").limit(1).executeTakeFirst()}async findStalled(e){return await this.db.selectFrom("messageQueues").selectAll().where("status","=","sent").where("sentAt","<",e).execute()}async updateStatus(e,s,t,r){return await this.db.updateTable("messageQueues").set({status:s,...t?.sentAt&&{sentAt:t.sentAt},...t?.deliveredAt&&{deliveredAt:t.deliveredAt},...r&&{errorMessage:r}}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async linkMessage(e,s){return await this.db.updateTable("messageQueues").set({messageId:s,status:"sent",sentAt:new Date}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async incrementRetry(e){let s=await this.findById(e);if(!s)throw Error(`Queue entry ${e} not found`);return await this.db.updateTable("messageQueues").set({retryCount:s.retryCount+1}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async deleteCompleted(e,s){await this.db.deleteFrom("messageQueues").where("clientId","=",e).where("queueName","=",s).where("status","in",["delivered","failed"]).execute()}async getQueueStatus(e,s){let t=await this.db.selectFrom("messageQueues").select(["status"]).where("clientId","=",e).where("queueName","=",s).execute();return{total:t.length,pending:t.filter(e=>"pending"===e.status).length,sent:t.filter(e=>"sent"===e.status).length,delivered:t.filter(e=>"delivered"===e.status).length,failed:t.filter(e=>"failed"===e.status).length}}}e.s(["MessageQueueRepository",()=>t],94510);var r=e.i(36480),a=e.i(187070),i=e.i(681247);class n{static instance;messageQueueRepo;constructor(){this.messageQueueRepo=new t(r.postgresDb)}static getInstance(){return n.instance||(n.instance=new n),n.instance}async enqueueMessages(e,s,t){if(0===s.length)return;console.log(`[MessageQueueService] Enqueueing ${s.length} messages for client ${e} in queue '${t}'`);let r=s.map((s,r)=>({clientId:e,queueName:t,sequenceNumber:r+1,messageContent:s.content||null,mediaUrls:s.mediaUrls?JSON.stringify(s.mediaUrls):null,status:"pending"}));await this.messageQueueRepo.createMany(r),console.log(`[MessageQueueService] Created ${r.length} queue entries`),await a.inngest.send({name:"message-queue/process-next",data:{clientId:e,queueName:t}})}async processNextMessage(e,s){console.log(`[MessageQueueService] Processing next message for client ${e} in queue '${s}'`);let t=await this.messageQueueRepo.findNextPending(e,s);if(!t){console.log(`[MessageQueueService] No more pending messages in queue '${s}' for client ${e}`),await this.clearQueue(e,s);return}console.log(`[MessageQueueService] Found next message (sequence ${t.sequenceNumber})`),await a.inngest.send({name:"message-queue/send-message",data:{queueEntryId:t.id,clientId:t.clientId,queueName:t.queueName}})}async sendQueuedMessage(s){let t,r=await this.messageQueueRepo.findById(s);if(!r)throw Error(`Queue entry ${s} not found`);let{messageService:a}=await e.A(593853),{userService:i}=await e.A(464245),n=await i.getUser(r.clientId);if(!n)throw Error(`Client ${r.clientId} not found`);if(r.mediaUrls)if("string"==typeof r.mediaUrls)try{t=JSON.parse(r.mediaUrls)}catch(e){console.error("[MessageQueueService] Failed to parse media URLs:",e)}else t=r.mediaUrls;console.log(`[MessageQueueService] Sending queued message ${s}`);let o=await a.sendMessage(n,r.messageContent||void 0,t);return await this.messageQueueRepo.linkMessage(r.id,o.id),console.log("[MessageQueueService] Queued message sent successfully",{queueEntryId:s,messageId:o.id}),o}async markMessageDelivered(e){let s=await this.messageQueueRepo.findByMessageId(e);s?(console.log(`[MessageQueueService] Marking message ${e} as delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await a.inngest.send({name:"message-queue/process-next",data:{clientId:s.clientId,queueName:s.queueName}}),console.log(`[MessageQueueService] Triggered next message for queue '${s.queueName}'`)):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async markMessageFailed(e,s){let t=await this.messageQueueRepo.findByMessageId(e);t?(console.log(`[MessageQueueService] Message ${e} failed:`,s),t.retryCount<t.maxRetries?(console.log(`[MessageQueueService] Retrying message (attempt ${t.retryCount+1}/${t.maxRetries})`),await this.messageQueueRepo.incrementRetry(t.id),await this.messageQueueRepo.updateStatus(t.id,"pending",void 0,s),await a.inngest.send({name:"message/delivery-failed",data:{messageId:e,clientId:t.clientId,providerMessageId:e,error:s||"Unknown error"}})):(console.log("[MessageQueueService] Max retries reached, marking as failed and moving to next"),await this.messageQueueRepo.updateStatus(t.id,"failed",void 0,s||"Max retries exceeded"),await a.inngest.send({name:"message-queue/process-next",data:{clientId:t.clientId,queueName:t.queueName}}))):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async checkStalledMessages(){let s=new Date(Date.now()-6e5),t=await this.messageQueueRepo.findStalled(s);if(0===t.length)return void console.log("[MessageQueueService] No stalled messages found");for(let s of(console.log(`[MessageQueueService] Found ${t.length} stalled messages`),t))try{if(!s.messageId){console.warn(`[MessageQueueService] Stalled entry ${s.id} has no messageId, marking as failed`),await this.messageQueueRepo.updateStatus(s.id,"failed",void 0,"No message ID found");continue}let{messageService:t}=await e.A(593853),r=t.messageRepo,a=await r.findById(s.messageId);if(!a||!a.providerMessageId){console.warn(`[MessageQueueService] Message ${s.messageId} not found or has no provider ID`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName);continue}console.log(`[MessageQueueService] Checking Twilio status for ${a.providerMessageId}`);let n=await i.twilioClient.getMessageStatus(a.providerMessageId);"delivered"===n.status?(console.log("[MessageQueueService] Twilio confirms delivery, updating queue"),await this.markMessageDelivered(s.messageId)):"failed"===n.status||"undelivered"===n.status?(console.log("[MessageQueueService] Twilio confirms failure, updating queue"),await this.markMessageFailed(s.messageId,`Stalled message status: ${n.status}`)):(console.log(`[MessageQueueService] Message still in transit (${n.status}), assuming delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName))}catch(e){console.error(`[MessageQueueService] Error checking stalled message ${s.id}:`,e),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName)}}async getQueueStatus(e,s){return await this.messageQueueRepo.getQueueStatus(e,s)}async clearQueue(e,s){console.log(`[MessageQueueService] Clearing completed queue '${s}' for client ${e}`),await this.messageQueueRepo.deleteCompleted(e,s)}}let o=n.getInstance();e.s(["MessageQueueService",()=>n,"messageQueueService",0,o],38330)},37702,(e,s,t)=>{s.exports=e.x("worker_threads",()=>require("worker_threads"))},812057,(e,s,t)=>{s.exports=e.x("node:util",()=>require("node:util"))},363890,(e,s,t)=>{s.exports=e.x("stream/web",()=>require("stream/web"))},60438,(e,s,t)=>{s.exports=e.x("perf_hooks",()=>require("perf_hooks"))},178249,(e,s,t)=>{s.exports=e.x("util/types",()=>require("util/types"))},687769,(e,s,t)=>{s.exports=e.x("node:events",()=>require("node:events"))},154993,(e,s,t)=>{s.exports=e.x("diagnostics_channel",()=>require("diagnostics_channel"))},925328,(e,s,t)=>{s.exports=e.x("http2",()=>require("http2"))},99348,(e,s,t)=>{s.exports=e.x("string_decoder",()=>require("string_decoder"))},410430,(e,s,t)=>{s.exports=e.x("async_hooks",()=>require("async_hooks"))},611913,(e,s,t)=>{s.exports=e.x("console",()=>require("console"))}];

//# sourceMappingURL=%5Broot-of-the-server%5D__f666dd2b._.js.map