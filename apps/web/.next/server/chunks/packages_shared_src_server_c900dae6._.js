module.exports=[681247,e=>{"use strict";e.i(791146);var s=e.i(832821),t=e.i(875559),a=e.i(66637);let r=new Map,u=(0,s.getTwilioSecrets)(),{baseUrl:i}=(0,t.getUrlsConfig)(),n=i?`${i}/api/twilio/status`:void 0,d=function(e,s){let t=e.accountSid;if(r.has(t))return r.get(t);let u=(0,a.default)(e.accountSid,e.authToken),i=e.phoneNumber,n={async sendSMS(e,t,a){try{let r=a&&a.length>0?"MMS":"SMS";if(console.log(`Sending ${r} from:`,i,"to:",e),a&&a.length>0&&console.log("Media URLs:",a),!t&&(!a||0===a.length))throw Error("Must provide either message text or media URLs");return await u.messages.create({...t&&{body:t},from:i,to:e,statusCallback:s,...a&&a.length>0&&{mediaUrl:a}})}catch(e){throw console.error("Error sending SMS/MMS:",e),e}},async sendMMS(e,s,t){return this.sendSMS(e,s,t)},getMessageStatus:async e=>await u.messages(e).fetch(),getFromNumber:()=>i};return r.set(t,n),n}({accountSid:u.accountSid,authToken:u.authToken,phoneNumber:u.phoneNumber},n);e.s(["twilioClient",0,d],681247)},38330,94510,e=>{"use strict";var s=e.i(46308);class t extends s.BaseRepository{async create(e){return await this.db.insertInto("messageQueues").values(e).returningAll().executeTakeFirstOrThrow()}async createMany(e){return 0===e.length?[]:await this.db.insertInto("messageQueues").values(e).returningAll().execute()}async findById(e){return await this.db.selectFrom("messageQueues").selectAll().where("id","=",e).executeTakeFirst()}async findByMessageId(e){return await this.db.selectFrom("messageQueues").selectAll().where("messageId","=",e).executeTakeFirst()}async findPendingByClient(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").execute()}async findAllPending(e){let s=this.db.selectFrom("messageQueues").selectAll().where("status","=","pending");return e.clientId&&(s=s.where("clientId","=",e.clientId)),await s.orderBy("createdAt","desc").limit(e.limit||100).offset(e.offset||0).execute()}async findAllPendingWithUserInfo(e){let s=this.db.selectFrom("messageQueues").innerJoin("users","users.id","messageQueues.clientId").select(["messageQueues.id","messageQueues.clientId","messageQueues.queueName","messageQueues.sequenceNumber","messageQueues.messageContent","messageQueues.mediaUrls","messageQueues.status","messageQueues.messageId","messageQueues.retryCount","messageQueues.maxRetries","messageQueues.timeoutMinutes","messageQueues.errorMessage","messageQueues.createdAt","messageQueues.sentAt","messageQueues.deliveredAt","users.name as userName","users.phoneNumber as userPhone"]).where("messageQueues.status","=","pending");return e.clientId&&(s=s.where("messageQueues.clientId","=",e.clientId)),await s.orderBy("messageQueues.createdAt","desc").limit(e.limit||100).execute()}async findNextPending(e,s){return await this.db.selectFrom("messageQueues").selectAll().where("clientId","=",e).where("queueName","=",s).where("status","=","pending").orderBy("sequenceNumber","asc").limit(1).executeTakeFirst()}async findStalled(e){return await this.db.selectFrom("messageQueues").selectAll().where("status","=","sent").where("sentAt","<",e).execute()}async updateStatus(e,s,t,a){return await this.db.updateTable("messageQueues").set({status:s,...t?.sentAt&&{sentAt:t.sentAt},...t?.deliveredAt&&{deliveredAt:t.deliveredAt},...a&&{errorMessage:a}}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async linkMessage(e,s){return await this.db.updateTable("messageQueues").set({messageId:s,status:"sent",sentAt:new Date}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async incrementRetry(e){let s=await this.findById(e);if(!s)throw Error(`Queue entry ${e} not found`);return await this.db.updateTable("messageQueues").set({retryCount:s.retryCount+1}).where("id","=",e).returningAll().executeTakeFirstOrThrow()}async deleteCompleted(e,s){await this.db.deleteFrom("messageQueues").where("clientId","=",e).where("queueName","=",s).where("status","in",["delivered","failed"]).execute()}async getQueueStatus(e,s){let t=await this.db.selectFrom("messageQueues").select(["status"]).where("clientId","=",e).where("queueName","=",s).execute();return{total:t.length,pending:t.filter(e=>"pending"===e.status).length,sent:t.filter(e=>"sent"===e.status).length,delivered:t.filter(e=>"delivered"===e.status).length,failed:t.filter(e=>"failed"===e.status).length}}}e.s(["MessageQueueRepository",()=>t],94510);var a=e.i(36480),r=e.i(187070),u=e.i(681247);class i{static instance;messageQueueRepo;constructor(){this.messageQueueRepo=new t(a.postgresDb)}static getInstance(){return i.instance||(i.instance=new i),i.instance}async enqueueMessages(e,s,t){if(0===s.length)return;console.log(`[MessageQueueService] Enqueueing ${s.length} messages for client ${e} in queue '${t}'`);let a=s.map((s,a)=>({clientId:e,queueName:t,sequenceNumber:a+1,messageContent:s.content||null,mediaUrls:s.mediaUrls?JSON.stringify(s.mediaUrls):null,status:"pending"}));await this.messageQueueRepo.createMany(a),console.log(`[MessageQueueService] Created ${a.length} queue entries`),await r.inngest.send({name:"message-queue/process-next",data:{clientId:e,queueName:t}})}async processNextMessage(e,s){console.log(`[MessageQueueService] Processing next message for client ${e} in queue '${s}'`);let t=await this.messageQueueRepo.findNextPending(e,s);if(!t){console.log(`[MessageQueueService] No more pending messages in queue '${s}' for client ${e}`),await this.clearQueue(e,s);return}console.log(`[MessageQueueService] Found next message (sequence ${t.sequenceNumber})`),await r.inngest.send({name:"message-queue/send-message",data:{queueEntryId:t.id,clientId:t.clientId,queueName:t.queueName}})}async sendQueuedMessage(s){let t,a=await this.messageQueueRepo.findById(s);if(!a)throw Error(`Queue entry ${s} not found`);let{messageService:r}=await e.A(593853),{userService:u}=await e.A(464245),i=await u.getUser(a.clientId);if(!i)throw Error(`Client ${a.clientId} not found`);if(a.mediaUrls)if("string"==typeof a.mediaUrls)try{t=JSON.parse(a.mediaUrls)}catch(e){console.error("[MessageQueueService] Failed to parse media URLs:",e)}else t=a.mediaUrls;console.log(`[MessageQueueService] Sending queued message ${s}`);let n=await r.sendMessage(i,a.messageContent||void 0,t);return await this.messageQueueRepo.linkMessage(a.id,n.id),console.log("[MessageQueueService] Queued message sent successfully",{queueEntryId:s,messageId:n.id}),n}async markMessageDelivered(e){let s=await this.messageQueueRepo.findByMessageId(e);s?(console.log(`[MessageQueueService] Marking message ${e} as delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await r.inngest.send({name:"message-queue/process-next",data:{clientId:s.clientId,queueName:s.queueName}}),console.log(`[MessageQueueService] Triggered next message for queue '${s.queueName}'`)):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async markMessageFailed(e,s){let t=await this.messageQueueRepo.findByMessageId(e);t?(console.log(`[MessageQueueService] Message ${e} failed:`,s),t.retryCount<t.maxRetries?(console.log(`[MessageQueueService] Retrying message (attempt ${t.retryCount+1}/${t.maxRetries})`),await this.messageQueueRepo.incrementRetry(t.id),await this.messageQueueRepo.updateStatus(t.id,"pending",void 0,s),await r.inngest.send({name:"message/delivery-failed",data:{messageId:e,clientId:t.clientId,providerMessageId:e,error:s||"Unknown error"}})):(console.log("[MessageQueueService] Max retries reached, marking as failed and moving to next"),await this.messageQueueRepo.updateStatus(t.id,"failed",void 0,s||"Max retries exceeded"),await r.inngest.send({name:"message-queue/process-next",data:{clientId:t.clientId,queueName:t.queueName}}))):console.log(`[MessageQueueService] No queue entry found for message ${e}`)}async checkStalledMessages(){let s=new Date(Date.now()-6e5),t=await this.messageQueueRepo.findStalled(s);if(0===t.length)return void console.log("[MessageQueueService] No stalled messages found");for(let s of(console.log(`[MessageQueueService] Found ${t.length} stalled messages`),t))try{if(!s.messageId){console.warn(`[MessageQueueService] Stalled entry ${s.id} has no messageId, marking as failed`),await this.messageQueueRepo.updateStatus(s.id,"failed",void 0,"No message ID found");continue}let{messageService:t}=await e.A(593853),a=t.messageRepo,r=await a.findById(s.messageId);if(!r||!r.providerMessageId){console.warn(`[MessageQueueService] Message ${s.messageId} not found or has no provider ID`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName);continue}console.log(`[MessageQueueService] Checking Twilio status for ${r.providerMessageId}`);let i=await u.twilioClient.getMessageStatus(r.providerMessageId);"delivered"===i.status?(console.log("[MessageQueueService] Twilio confirms delivery, updating queue"),await this.markMessageDelivered(s.messageId)):"failed"===i.status||"undelivered"===i.status?(console.log("[MessageQueueService] Twilio confirms failure, updating queue"),await this.markMessageFailed(s.messageId,`Stalled message status: ${i.status}`)):(console.log(`[MessageQueueService] Message still in transit (${i.status}), assuming delivered`),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName))}catch(e){console.error(`[MessageQueueService] Error checking stalled message ${s.id}:`,e),await this.messageQueueRepo.updateStatus(s.id,"delivered",{deliveredAt:new Date}),await this.processNextMessage(s.clientId,s.queueName)}}async getQueueStatus(e,s){return await this.messageQueueRepo.getQueueStatus(e,s)}async clearQueue(e,s){console.log(`[MessageQueueService] Clearing completed queue '${s}' for client ${e}`),await this.messageQueueRepo.deleteCompleted(e,s)}}let n=i.getInstance();e.s(["MessageQueueService",()=>i,"messageQueueService",0,n],38330)},593853,e=>{e.v(s=>Promise.all(["server/chunks/[root-of-the-server]__5965555f._.js","server/chunks/packages_shared_src_server_repositories_userRepository_ts_0ff92dcb._.js","server/chunks/packages_shared_src_server_services_messaging_messageService_ts_7e2e56ec._.js","server/chunks/packages_shared_src_shared_utils_date_ts_87532123._.js","server/chunks/_d6e170b6._.js","server/chunks/packages_shared_src_server_f249b08b._.js","server/chunks/[root-of-the-server]__6b81c762._.js"].map(s=>e.l(s))).then(()=>s(80643)))},464245,e=>{e.v(s=>Promise.all(["server/chunks/packages_shared_src_server_ea6edf6f._.js","server/chunks/packages_shared_src_shared_utils_date_ts_87532123._.js","server/chunks/packages_shared_src_server_repositories_userRepository_ts_0ff92dcb._.js"].map(s=>e.l(s))).then(()=>s(565431)))}];

//# sourceMappingURL=packages_shared_src_server_c900dae6._.js.map