{"version":3,"sources":["../../../../../packages/shared/src/server/services/index.ts","../../../../../packages/shared/src/server/repositories/profileRepository.ts","../../../../../packages/shared/src/server/services/agents/chat/index.ts","../../../../../packages/shared/src/server/services/agents/profile/index.ts","../../../../../packages/shared/src/server/services/user/fitnessProfileService.ts","../../../../../packages/shared/src/server/services/agents/prompts/profile.ts","../../../../../packages/shared/src/server/services/agents/schemas/profile.ts","../../../../../packages/shared/src/shared/utils/timezone.ts","../../../../../packages/shared/src/shared/types/profile/schema.ts","../../../../../packages/shared/src/server/utils/profile/jsonToMarkdown.ts","../../../../../packages/shared/src/server/services/user/signupDataFormatter.ts","../../../../../packages/shared/src/server/services/flows/conversationFlowBuilder.ts","../../../../../packages/shared/src/server/services/agents/modifications/workoutModificationService.ts","../../../../../packages/shared/src/server/services/agents/modifications/planModificationService.ts","../../../../../packages/shared/src/server/services/agents/modifications/tools.ts","../../../../../packages/shared/src/server/services/agents/shared/utils.ts","../../../../../packages/shared/src/server/services/agents/prompts/modifications.ts","../../../../../packages/shared/src/server/services/agents/modifications/index.ts","../../../../../packages/shared/src/server/services/agents/chat/tools.ts","../../../../../packages/shared/src/server/services/subscription/subscriptionService.ts","../../../../../packages/shared/src/server/services/training/chainRunnerService.ts","../../../../../packages/shared/src/server/repositories/factory.ts","../../../../../packages/shared/src/server/repositories/adminActivityLogRepository.ts","../../../../../packages/shared/src/server/repositories/profileUpdateRepository.ts","../../../../../packages/shared/src/server/services/factory.ts"],"sourcesContent":["// Entity services (from /services/training/, /services/user/, /services/messaging/)\n// NOTE: These must be imported first as they're used to initialize ContextService\nimport { fitnessPlanService } from './training/fitnessPlanService';\nimport { workoutInstanceService } from './training/workoutInstanceService';\nimport { microcycleService } from './training/microcycleService';\nimport { progressService } from './training/progressService';\nexport { fitnessPlanService, workoutInstanceService, microcycleService, progressService };\n\n// Context service initialization (must happen before any agent services are used)\nimport { ContextService } from './context';\nimport { ProfileRepository } from '@/server/repositories/profileRepository';\n\nContextService.initialize({\n  fitnessPlanService,\n  workoutInstanceService,\n  microcycleService,\n  profileRepository: new ProfileRepository(),\n});\n\n// Agent orchestration services (from /services/agents/)\n// These use static methods - call directly e.g. ChatService.handleIncomingMessage()\nexport { ChatService } from './agents/chat';\nexport { ModificationService } from './agents/modifications';\nexport { ProfileService } from './agents/profile';\n\n// Sub-services for modifications (still use singleton pattern)\nexport {\n  workoutModificationService,\n  planModificationService,\n} from './agents/modifications';\nexport type {\n  WorkoutModificationService,\n  ModifyWorkoutResult,\n  ModifyWeekResult,\n  PlanModificationService,\n  ModifyPlanParams,\n  ModifyPlanResult,\n} from './agents/modifications';\n\n// Non-agent orchestration services (from /services/orchestration/)\nexport { dailyMessageService } from './orchestration/dailyMessageService';\nexport { weeklyMessageService } from './orchestration/weeklyMessageService';\nexport { onboardingService } from './orchestration/onboardingService';\n\nexport type { DailyMessageService } from './orchestration/dailyMessageService';\nexport type { WeeklyMessageService } from './orchestration/weeklyMessageService';\nexport type { OnboardingService } from './orchestration/onboardingService';\n\nexport type { FitnessPlanService } from './training/fitnessPlanService';\nexport type { ProgressService } from './training/progressService';\nexport type { WorkoutInstanceService } from './training/workoutInstanceService';\nexport type { MicrocycleService } from './training/microcycleService';\n\nexport { userService } from './user/userService';\nexport { fitnessProfileService } from './user/fitnessProfileService';\nexport { onboardingDataService } from './user/onboardingDataService';\n\nexport type { UserService, CreateUserRequest } from './user/userService';\nexport type { FitnessProfileService, ProfileUpdateResult } from './user/fitnessProfileService';\nexport type { OnboardingDataService } from './user/onboardingDataService';\n\nexport { messageService } from './messaging/messageService';\n\nexport type { MessageService } from './messaging/messageService';\n\nexport { subscriptionService } from './subscription/subscriptionService';\n\nexport type {\n  SubscriptionService,\n  CancelResult,\n  ReactivateResult,\n} from './subscription/subscriptionService';\n\n// Chain runner service for testing/improving AI outputs\nexport { ChainRunnerService } from './training/chainRunnerService';\nexport type { ChainOperation, ChainRunResult, ProfileRegenerationResult } from './training/chainRunnerService';\n\n// Calendar services\nexport { dayConfigService } from './calendar/dayConfigService';\nexport type { DayConfigService } from './calendar/dayConfigService';\n\n// Service factory (for environment context switching)\nexport { getServices, clearServiceCache } from './factory';\nexport type { ServiceContainer, WithContext } from './factory';\n","import { BaseRepository } from './baseRepository';\nimport type { Profiles } from '../models/_types';\nimport type { Selectable, Insertable } from 'kysely';\nimport type { StructuredProfile } from '@/server/models/profile';\n\nexport type Profile = Selectable<Profiles>;\nexport type NewProfile = Insertable<Profiles>;\n\n/**\n * Profile with typed structured data\n * The database stores structured as JSONB, this interface casts it to the correct type\n */\nexport interface ProfileWithStructured extends Omit<Profile, 'structured'> {\n  structured: StructuredProfile | null;\n}\n\n/**\n * ProfileRepository - Data access layer for Markdown-based fitness profiles\n *\n * This repository handles CRUD operations for the profiles table which stores\n * the history of user fitness profiles in Markdown format. Each update creates\n * a new row, providing full audit trail and versioning.\n */\nexport class ProfileRepository extends BaseRepository {\n  /**\n   * Get the current (most recent) profile for a user\n   *\n   * @param clientId - UUID of the user\n   * @returns Most recent profile or undefined if no profiles exist\n   */\n  async getCurrentProfile(clientId: string): Promise<Profile | undefined> {\n    const profile = await this.db\n      .selectFrom('profiles')\n      .where('clientId', '=', clientId)\n      .orderBy('createdAt', 'desc')\n      .limit(1)\n      .selectAll()\n      .executeTakeFirst();\n\n    return profile;\n  }\n\n  /**\n   * Get the current profile text (Markdown) for a user\n   *\n   * @param clientId - UUID of the user\n   * @returns Markdown profile text or null if no profiles exist\n   */\n  async getCurrentProfileText(clientId: string): Promise<string | null> {\n    const profile = await this.getCurrentProfile(clientId);\n    return profile?.profile ?? null;\n  }\n\n  /**\n   * Create a new profile entry (appends to history)\n   *\n   * @param newProfile - Profile data to insert\n   * @returns Created profile record\n   */\n  async createProfile(newProfile: NewProfile): Promise<Profile> {\n    const result = await this.db\n      .insertInto('profiles')\n      .values(newProfile)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Create a new profile entry with just clientId and profile text\n   * Convenience method for common use case\n   *\n   * @param clientId - UUID of the user\n   * @param profileMarkdown - Markdown-formatted profile text\n   * @returns Created profile record\n   */\n  async createProfileForUser(clientId: string, profileMarkdown: string): Promise<Profile> {\n    return this.createProfile({\n      clientId,\n      profile: profileMarkdown,\n    });\n  }\n\n  /**\n   * Get profile history for a user\n   *\n   * @param clientId - UUID of the user\n   * @param limit - Maximum number of historical profiles to retrieve (default: 10)\n   * @returns Array of profile records, ordered by most recent first\n   */\n  async getProfileHistory(clientId: string, limit: number = 10): Promise<Profile[]> {\n    const profiles = await this.db\n      .selectFrom('profiles')\n      .where('clientId', '=', clientId)\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .selectAll()\n      .execute();\n\n    return profiles;\n  }\n\n  /**\n   * Get profile as of a specific date\n   * Returns the most recent profile that was created before or at the given date\n   *\n   * @param clientId - UUID of the user\n   * @param date - Date to retrieve profile for\n   * @returns Profile record or undefined if no profiles exist before that date\n   */\n  async getProfileAtDate(clientId: string, date: Date): Promise<Profile | undefined> {\n    const profile = await this.db\n      .selectFrom('profiles')\n      .where('clientId', '=', clientId)\n      .where('createdAt', '<=', date)\n      .orderBy('createdAt', 'desc')\n      .limit(1)\n      .selectAll()\n      .executeTakeFirst();\n\n    return profile;\n  }\n\n  /**\n   * Count total profile updates for a user\n   *\n   * @param clientId - UUID of the user\n   * @returns Number of profile updates in history\n   */\n  async countProfileUpdates(clientId: string): Promise<number> {\n    const result = await this.db\n      .selectFrom('profiles')\n      .where('clientId', '=', clientId)\n      .select(this.db.fn.count('id').as('count'))\n      .executeTakeFirstOrThrow();\n\n    return Number(result.count);\n  }\n\n  /**\n   * Get the date of the last profile update\n   *\n   * @param clientId - UUID of the user\n   * @returns Date of last update or null if no profiles exist\n   */\n  async getLastUpdateDate(clientId: string): Promise<Date | null> {\n    const profile = await this.getCurrentProfile(clientId);\n    return profile?.createdAt ?? null;\n  }\n\n  /**\n   * Delete all profiles for a user (typically only for testing/cleanup)\n   * WARNING: This removes all history\n   *\n   * @param clientId - UUID of the user\n   * @returns Number of profiles deleted\n   */\n  async deleteAllProfilesForUser(clientId: string): Promise<number> {\n    const result = await this.db\n      .deleteFrom('profiles')\n      .where('clientId', '=', clientId)\n      .executeTakeFirst();\n\n    return Number(result.numDeletedRows);\n  }\n\n  /**\n   * Get all users who have profiles\n   *\n   * @returns Array of distinct client IDs\n   */\n  async getAllUsersWithProfiles(): Promise<string[]> {\n    const results = await this.db\n      .selectFrom('profiles')\n      .select('clientId')\n      .distinct()\n      .execute();\n\n    return results.map(r => r.clientId);\n  }\n\n  /**\n   * Check if a user has any profiles\n   *\n   * @param clientId - UUID of the user\n   * @returns True if user has at least one profile\n   */\n  async hasProfile(clientId: string): Promise<boolean> {\n    const count = await this.countProfileUpdates(clientId);\n    return count > 0;\n  }\n\n  // ============================================\n  // Structured Profile Methods\n  // ============================================\n\n  /**\n   * Create a new profile entry with structured data\n   * Convenience method that handles JSONB serialization\n   *\n   * @param clientId - UUID of the user\n   * @param profileMarkdown - Markdown-formatted profile text\n   * @param structured - Structured profile data (or null)\n   * @returns Created profile record\n   */\n  async createProfileWithStructured(\n    clientId: string,\n    profileMarkdown: string,\n    structured: StructuredProfile | null\n  ): Promise<Profile> {\n    const result = await this.db\n      .insertInto('profiles')\n      .values({\n        clientId,\n        profile: profileMarkdown,\n        structured: structured ? JSON.stringify(structured) : null,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Get the current profile with typed structured data\n   *\n   * @param clientId - UUID of the user\n   * @returns Most recent profile with typed structured field, or undefined\n   */\n  async getCurrentProfileWithStructured(clientId: string): Promise<ProfileWithStructured | undefined> {\n    const profile = await this.getCurrentProfile(clientId);\n    if (!profile) return undefined;\n\n    return {\n      ...profile,\n      structured: profile.structured as StructuredProfile | null,\n    };\n  }\n\n  /**\n   * Get the current structured profile data only\n   *\n   * @param clientId - UUID of the user\n   * @returns Structured profile data or null if not available\n   */\n  async getCurrentStructuredProfile(clientId: string): Promise<StructuredProfile | null> {\n    const profile = await this.getCurrentProfileWithStructured(clientId);\n    return profile?.structured ?? null;\n  }\n}\n","import { UserWithProfile } from '@/server/models/user';\nimport { createAgent, PROMPT_IDS, type Message as AgentMessage } from '@/server/agents';\nimport { messageService } from '../../messaging/messageService';\nimport { workoutInstanceService } from '../../training/workoutInstanceService';\nimport { ProfileService } from '../profile';\nimport { ModificationService } from '../modifications';\nimport { userService } from '../../user/userService';\nimport { now } from '@/shared/utils/date';\nimport { createChatTools } from './tools';\nimport { ContextService, ContextType } from '@/server/services/context';\nimport { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';\nimport type { ToolResult } from '../types/shared';\nimport { getChatConfig } from '@/shared/config';\nimport { getEnvironmentSettings } from '@/server/config';\n\n// Configuration from shared config\nconst { smsMaxLength: SMS_MAX_LENGTH, contextMinutes: CHAT_CONTEXT_MINUTES } = getChatConfig();\n\n/**\n * Get or generate today's workout for a user.\n * Returns a ToolResult with the workout message in the messages array.\n */\nasync function getWorkoutForToday(userId: string, timezone: string): Promise<ToolResult> {\n  try {\n    const today = now(timezone);\n    const todayDate = today.toJSDate();\n\n    // Check if workout already exists\n    const existingWorkout = await workoutInstanceService.getWorkoutByUserIdAndDate(userId, todayDate);\n\n    if (existingWorkout) {\n      // Workout exists - return its message\n      console.log('[ChatService] Existing workout found for today');\n      return {\n        toolType: 'query',\n        response: `User's workout for today: ${existingWorkout.sessionType || 'Workout'} - ${existingWorkout.description || 'Custom workout'}`,\n        messages: existingWorkout.message ? [existingWorkout.message] : undefined,\n      };\n    }\n\n    // No workout - need to generate one\n    // Fetch user with profile for generation\n    const user = await userService.getUser(userId);\n    if (!user) {\n      return { toolType: 'query', response: 'User not found.' };\n    }\n\n    // Generate the workout\n    console.log('[ChatService] Generating workout for today');\n    const generatedWorkout = await workoutInstanceService.generateWorkoutForDate(user, today);\n\n    if (!generatedWorkout) {\n      return {\n        toolType: 'query',\n        response: 'No workout scheduled for today. This could be a rest day based on the training plan, or the user may not have a fitness plan yet.',\n      };\n    }\n\n    return {\n      toolType: 'query',\n      response: `User's workout for today: ${generatedWorkout.sessionType || 'Workout'} - ${generatedWorkout.description || 'Custom workout'}`,\n      messages: generatedWorkout.message ? [generatedWorkout.message] : undefined,\n    };\n  } catch (error) {\n    console.error('[ChatService] Error getting/generating workout:', error);\n    return {\n      toolType: 'query',\n      response: `Failed to get workout: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    };\n  }\n}\n\n/**\n * ChatService handles incoming SMS messages and generates AI-powered responses.\n *\n * This service orchestrates the chat agent which operates in an agentic loop:\n * - Agent decides when to call tools (update_profile, make_modification, get_workout)\n * - Tool priority ensures update_profile runs first when called with other tools\n * - Agent generates a final conversational response\n * - Tool messages are accumulated and sent after the agent's response\n *\n * The service ensures that:\n * - Agent autonomously decides when profile updates are needed\n * - Modifications happen when the agent decides to call make_modification\n * - Conversation history and context are properly maintained\n * - SMS length constraints are enforced\n */\nexport class ChatService {\n\n  /**\n   * Processes pending inbound SMS messages using the two-agent architecture.\n   *\n   * @param user - The user object with their profile information\n   * @returns A promise that resolves to an array of response messages (empty if no pending messages)\n   *\n   * @remarks\n   * This method performs a single DB fetch and splits messages into:\n   * - pending: inbound messages after the last outbound (to be processed)\n   * - context: conversation history up to and including the last outbound\n   *\n   * This architecture ensures:\n   * - No race conditions from multiple DB fetches\n   * - Profile information is always current\n   * - Proper acknowledgment of profile updates in responses\n   * - Support for multiple messages (e.g., week update + workout message)\n   *\n   * @example\n   * ```typescript\n   * const messages = await ChatService.handleIncomingMessage(user);\n   * // Returns [] if no pending messages, otherwise generates responses\n   * ```\n   */\n  static async handleIncomingMessage(\n    user: UserWithProfile\n  ): Promise<string[]> {\n    try {\n      // Single DB fetch: get enough messages for pending + context window\n      // We fetch extra to ensure we have enough context after splitting\n      const allMessages = await messageService.getRecentMessages(\n        user.id,\n        20\n      );\n\n      // Split into pending (needs response) and context (conversation history)\n      const { pending, context } = messageService.splitMessages(allMessages, CHAT_CONTEXT_MINUTES);\n\n      // Early return if no pending messages\n      if (pending.length === 0) {\n        console.log('[ChatService] No pending messages, skipping');\n        return [];\n      }\n\n      // Aggregate pending message content\n      const message = pending.map(m => m.content).join('\\n\\n');\n\n      console.log('[ChatService] Processing pending messages:', {\n        pendingCount: pending.length,\n        contextCount: context.length,\n        aggregatedContent: message.substring(0, 100) + (message.length > 100 ? '...' : '')\n      });\n\n      // Fetch user with profile (if not already included)\n      const userWithProfile = user.profile !== undefined\n        ? user\n        : await userService.getUser(user.id) || user;\n\n              // Callback for sending immediate messages\n      const onSendMessage = async (immediateMessage: string) => {\n        try {\n          await messageService.sendMessage(userWithProfile, immediateMessage);\n          console.log('[ChatService] Sent immediate message:', immediateMessage);\n        } catch (error) {\n          console.error('[ChatService] Failed to send immediate message:', error);\n          // Don't throw - continue with tool execution\n        }\n      };\n\n      // Create tools using the factory function\n      // Tool priority: update_profile (1) > get_workout (2) > make_modification (3)\n      const tools = createChatTools(\n        {\n          userId: userWithProfile.id,\n          message,\n          previousMessages: context,\n          timezone: userWithProfile.timezone,\n        },\n        {\n          makeModification: ModificationService.makeModification,\n          getWorkout: getWorkoutForToday,\n          updateProfile: ProfileService.updateProfile,\n        },\n        onSendMessage,\n      );\n\n\n      // Build context using ContextService\n      const agentContext = await ContextService.getInstance().getContext(\n        userWithProfile,\n        [ContextType.DATE_CONTEXT, ContextType.CURRENT_WORKOUT]\n      );\n\n      // Convert previous messages to Message format for the configurable agent\n      const previousMsgs: AgentMessage[] = ConversationFlowBuilder.toMessageArray(context || [])\n        .map(m => ({\n          role: m.role as 'user' | 'assistant',\n          content: m.content,\n        }));\n\n      // Create chat agent - prompts fetched from DB based on agent name\n      const agent = await createAgent({\n        name: PROMPT_IDS.CHAT_GENERATE,\n        context: agentContext,\n        previousMessages: previousMsgs,\n        tools,\n      });\n\n      // Invoke the chat agent - it will decide when to call tools (including update_profile)\n      const result = await agent.invoke(message);\n\n      console.log(`[ChatService] Agent completed with response length: ${result.response.length}, accumulated messages: ${result.messages?.length || 0}`);\n\n      // Map to ChatOutput format\n      // Order: [agent's final response, ...accumulated tool messages]\n      const messages = [result.response, ...(result.messages || [])].filter(m => m && m.trim());\n\n      if (!messages || messages.length === 0) {\n        throw new Error('Chat agent returned no messages');\n      }\n\n      // Enforce SMS length constraints on each message\n      const validatedMessages = messages\n        .filter((msg: string) => msg && msg.trim())\n        .map((msg: string) => {\n          const trimmed = msg.trim();\n          if (trimmed.length > SMS_MAX_LENGTH) {\n            return trimmed.substring(0, SMS_MAX_LENGTH - 3) + '...';\n          }\n          return trimmed;\n        });\n\n      return validatedMessages;\n\n    } catch (error) {\n      console.error('[ChatService] Error handling message:', error);\n\n      // Log additional context in development\n      if (getEnvironmentSettings().isDevelopment) {\n        console.error('Error details:', {\n          userId: user.id,\n          error: error instanceof Error ? error.stack : error\n        });\n      }\n\n      // Return a helpful fallback message\n      return [\"Sorry, I'm having trouble processing that. Try asking about your workout or fitness goals!\"];\n    }\n  }\n}\n\n// Re-export tools for external use\nexport { createChatTools } from './tools';\nexport type { ChatToolContext, ChatToolDeps } from './tools';\n","import { userService } from '../../user/userService';\nimport { fitnessProfileService } from '../../user/fitnessProfileService';\nimport { workoutInstanceService } from '../../training/workoutInstanceService';\nimport { createAgent, PROMPT_IDS, type Message as AgentMessage } from '@/server/agents';\nimport { formatForAI, now } from '@/shared/utils/date';\nimport { inngest } from '@/server/connections/inngest/client';\nimport { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';\nimport {\n  buildProfileUpdateUserMessage,\n  buildUserFieldsUserMessage,\n  buildStructuredProfileUserMessage,\n} from '../prompts/profile';\nimport {\n  ProfileUpdateOutputSchema,\n  UserFieldsOutputSchema,\n} from '../schemas/profile';\nimport { StructuredProfileSchema } from '@/server/models/profile';\nimport type { StructuredProfileOutput, ProfileUpdateOutput, UserFieldsOutput, StructuredProfileInput } from '../types/profile';\nimport type { ToolResult } from '../types/shared';\nimport type { Message } from '@/server/models/message';\n\n/**\n * ProfileService - Orchestration service for profile and user field agents\n *\n * Handles profile updates via the profile agent AND user field updates\n * (timezone, send time, name) via the user fields agent.\n * Both agents run in parallel for efficiency.\n *\n * Uses entity services (UserService, FitnessProfileService) for data access.\n *\n * This is an ORCHESTRATION service - it coordinates agent calls.\n * For entity CRUD operations, use FitnessProfileService directly.\n */\nexport class ProfileService {\n  /**\n   * Update profile and user fields from a user message\n   *\n   * Runs both agents in parallel:\n   * 1. Profile agent - updates the fitness profile dossier\n   * 2. User fields agent - extracts timezone, send time, and name changes\n   *\n   * Fetches context via entity services, calls both agents,\n   * persists updates, and returns a standardized ToolResult.\n   *\n   * @param userId - The user's ID\n   * @param message - The user's message to extract info from\n   * @param previousMessages - Optional conversation history for context\n   * @returns ToolResult with response summary and optional messages\n   */\n  static async updateProfile(userId: string, message: string, previousMessages?: Message[]): Promise<ToolResult> {\n    console.log('[PROFILE_SERVICE] Processing profile update:', {\n      userId,\n      message: message.substring(0, 100) + (message.length > 100 ? '...' : ''),\n    });\n\n    try {\n      // Fetch context via entity services\n      const user = await userService.getUser(userId);\n      if (!user) {\n        console.warn('[PROFILE_SERVICE] User not found:', userId);\n        return { toolType: 'action', response: 'User not found.' };\n      }\n\n      const currentProfile = await fitnessProfileService.getCurrentProfile(userId) ?? '';\n      const currentDate = formatForAI(new Date(), user.timezone);\n\n      // Convert previous messages to Message format for the configurable agent\n      const previousMsgs: AgentMessage[] = ConversationFlowBuilder.toMessageArray(previousMessages || [])\n        .map(m => ({\n          role: m.role as 'user' | 'assistant',\n          content: m.content,\n        }));\n\n      // Helper function to create and invoke the structured profile agent\n      // System prompt fetched from DB based on agent name\n      const invokeStructuredProfileAgent = async (input: StructuredProfileInput | string): Promise<StructuredProfileOutput> => {\n        const parsedInput: StructuredProfileInput = typeof input === 'string' ? JSON.parse(input) : input;\n        const userPrompt = buildStructuredProfileUserMessage(parsedInput.dossierText, parsedInput.currentDate);\n        const agent = await createAgent({\n          name: PROMPT_IDS.PROFILE_STRUCTURED,\n          schema: StructuredProfileSchema,\n        }, { model: 'gpt-5-nano', temperature: 0.3 });\n\n        const result = await agent.invoke(userPrompt);\n        return { structured: result.response, success: true };\n      };\n\n      // Run BOTH agents in parallel for efficiency\n      const [profileResult, userFieldsResult] = await Promise.all([\n        // Profile agent - updates fitness profile dossier\n        // Prompts fetched from DB based on agent name\n        (async (): Promise<ProfileUpdateOutput> => {\n          const userPrompt = buildProfileUpdateUserMessage(currentProfile, message, user, currentDate);\n\n          // Create profile update agent with subAgents for structured extraction\n          const agent = await createAgent({\n            name: PROMPT_IDS.PROFILE_FITNESS,\n            previousMessages: previousMsgs,\n            schema: ProfileUpdateOutputSchema,\n            subAgents: [{\n              structured: {\n                agent: { name: PROMPT_IDS.PROFILE_STRUCTURED, invoke: invokeStructuredProfileAgent },\n                condition: (result: unknown) => (result as { wasUpdated: boolean }).wasUpdated,\n                transform: (result: unknown) => JSON.stringify({\n                  dossierText: (result as { updatedProfile: string }).updatedProfile,\n                  currentDate,\n                }),\n              },\n            }],\n          });\n\n          const result = await agent.invoke(userPrompt);\n          const structuredResult = (result as { structured?: StructuredProfileOutput }).structured;\n          const structured = structuredResult?.success ? structuredResult.structured : null;\n\n          return {\n            updatedProfile: result.response.updatedProfile,\n            wasUpdated: result.response.wasUpdated,\n            updateSummary: result.response.updateSummary || '',\n            structured,\n          };\n        })(),\n        // User fields agent - extracts timezone, send time, name changes\n        // Prompts fetched from DB based on agent name\n        (async (): Promise<UserFieldsOutput> => {\n          const userPrompt = buildUserFieldsUserMessage(message, user, currentDate);\n          const agent = await createAgent({\n            name: PROMPT_IDS.PROFILE_USER,\n            previousMessages: previousMsgs,\n            schema: UserFieldsOutputSchema,\n          }, { model: 'gpt-5-nano', temperature: 0.3 });\n\n          const result = await agent.invoke(userPrompt);\n          return {\n            timezone: result.response.timezone,\n            preferredSendHour: result.response.preferredSendHour,\n            name: result.response.name,\n            hasUpdates: result.response.hasUpdates,\n            updateSummary: result.response.updateSummary || '',\n          };\n        })(),\n      ]);\n\n      // Persist profile updates (structured data now included from update agent)\n      if (profileResult.wasUpdated) {\n        await fitnessProfileService.saveProfileWithStructured(\n          userId,\n          profileResult.updatedProfile,\n          profileResult.structured\n        );\n\n        console.log('[PROFILE_SERVICE] Profile updated:', {\n          summary: profileResult.updateSummary,\n          hasStructured: profileResult.structured !== null,\n        });\n      } else {\n        console.log('[PROFILE_SERVICE] No profile updates detected');\n      }\n\n      // Handle user field updates\n      if (userFieldsResult.hasUpdates) {\n        const userUpdates: { preferredSendHour?: number; timezone?: string; name?: string } = {};\n\n        // Timezone: !! handles null and empty string\n        if (!!userFieldsResult.timezone) {\n          userUpdates.timezone = userFieldsResult.timezone;\n          console.log('[PROFILE_SERVICE] Timezone update:', userFieldsResult.timezone);\n        }\n\n        // PreferredSendHour: can't use !! because 0 (midnight) is valid\n        // Check for null and -1 sentinel explicitly\n        if (userFieldsResult.preferredSendHour != null && userFieldsResult.preferredSendHour !== -1) {\n          userUpdates.preferredSendHour = userFieldsResult.preferredSendHour;\n        }\n\n        // Name: !! handles null and empty string\n        if (!!userFieldsResult.name) {\n          userUpdates.name = userFieldsResult.name;\n        }\n\n        // Persist user updates if any valid fields\n        if (Object.keys(userUpdates).length > 0) {\n          await userService.updatePreferences(userId, userUpdates);\n          console.log('[PROFILE_SERVICE] User fields updated:', userUpdates);\n\n          // Check if time-related fields changed - ensure user has today's workout\n          if (userUpdates.timezone !== undefined || userUpdates.preferredSendHour !== undefined) {\n            const newTimezone = userUpdates.timezone ?? user.timezone;\n            const currentTime = now(newTimezone);\n\n            // Check if workout already exists for today (prevents duplicates)\n            const todayStart = currentTime.startOf('day').toJSDate();\n            const existingWorkout = await workoutInstanceService.getWorkoutByUserIdAndDate(userId, todayStart);\n\n            if (!existingWorkout) {\n              // No workout exists - trigger immediate send via Inngest\n              await inngest.send({\n                name: 'workout/scheduled',\n                data: {\n                  userId,\n                  targetDate: currentTime.startOf('day').toISO(),\n                },\n              });\n              console.log('[PROFILE_SERVICE] Triggered immediate workout for missed send time');\n            }\n          }\n        }\n      }\n\n      // Combine summaries for response\n      const summaries: string[] = [];\n      if (profileResult.wasUpdated) {\n        summaries.push(`Profile: ${profileResult.updateSummary}`);\n      }\n      if (userFieldsResult.hasUpdates && Object.keys(userFieldsResult).some(k =>\n        k !== 'hasUpdates' && k !== 'updateSummary' &&\n        userFieldsResult[k as keyof typeof userFieldsResult] !== null\n      )) {\n        summaries.push(`Settings: ${userFieldsResult.updateSummary}`);\n      }\n\n      return {\n        toolType: 'action',\n        response: summaries.length > 0\n          ? summaries.join('; ')\n          : 'No updates detected.',\n      };\n    } catch (error) {\n      console.error('[PROFILE_SERVICE] Error updating profile:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        toolType: 'action',\n        response: `Profile update failed: ${errorMessage}`,\n      };\n    }\n  }\n}\n","/**\n * FitnessProfileService - Markdown-based Profile Management\n *\n * This service manages Markdown \"Living Dossier\" profiles with full history tracking.\n *\n * Key features:\n * - Uses ProfileRepository for Markdown profile storage\n * - Single Profile Update Agent for AI-powered profile creation\n * - Each update creates a new profile row (history tracking)\n * - Profiles stored as Markdown text\n * - Circuit breaker pattern for resilience\n */\n\nimport { UserWithProfile } from '@/server/models/user';\nimport { ProfileRepository } from '@/server/repositories/profileRepository';\nimport { CircuitBreaker } from '@/server/utils/circuitBreaker';\nimport { createAgent, PROMPT_IDS } from '@/server/agents';\nimport {\n  buildProfileUpdateUserMessage,\n  buildStructuredProfileUserMessage,\n} from '@/server/services/agents/prompts/profile';\nimport { ProfileUpdateOutputSchema } from '@/server/services/agents/schemas/profile';\nimport { StructuredProfileSchema, type StructuredProfile } from '@/server/models/profile';\nimport type { StructuredProfileOutput, StructuredProfileInput } from '@/server/services/agents/types/profile';\nimport { createEmptyProfile } from '@/server/utils/profile/jsonToMarkdown';\nimport { formatSignupDataForLLM } from './signupDataFormatter';\nimport type { SignupData } from '@/server/repositories/onboardingRepository';\nimport { formatForAI } from '@/shared/utils/date';\n\n/**\n * Result returned when patching/updating a profile\n */\nexport interface ProfileUpdateResult {\n  /** Updated Markdown profile text */\n  profile: string;\n  /** Whether the profile was actually updated */\n  wasUpdated: boolean;\n  /** Summary of changes made. Empty string if nothing was updated. */\n  updateSummary: string;\n}\n\nexport class FitnessProfileService {\n  private static instance: FitnessProfileService;\n  private circuitBreaker: CircuitBreaker;\n  private profileRepository: ProfileRepository;\n\n  private constructor() {\n    this.circuitBreaker = new CircuitBreaker({\n      failureThreshold: 5,\n      resetTimeout: 60000, // 1 minute\n      monitoringPeriod: 60000, // 1 minute\n    });\n    this.profileRepository = new ProfileRepository();\n  }\n\n  public static getInstance(): FitnessProfileService {\n    if (!FitnessProfileService.instance) {\n      FitnessProfileService.instance = new FitnessProfileService();\n    }\n    return FitnessProfileService.instance;\n  }\n\n  /**\n   * Get the current Markdown profile for a user\n   *\n   * @param userId - UUID of the user\n   * @returns Markdown profile text or null if no profile exists\n   */\n  async getCurrentProfile(userId: string): Promise<string | null> {\n    return await this.profileRepository.getCurrentProfileText(userId);\n  }\n\n  /**\n   * Save updated profile\n   * Creates new row in profiles table for history tracking\n   *\n   * @param userId - UUID of the user\n   * @param profile - Complete profile text\n   */\n  async saveProfile(userId: string, profile: string): Promise<void> {\n    try {\n      await this.profileRepository.createProfileForUser(userId, profile);\n      console.log(`[FitnessProfileService] Saved profile for user ${userId}`);\n    } catch (error) {\n      console.error(`[FitnessProfileService] Error saving profile for user ${userId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create initial fitness profile from signup data\n   * Converts signup data to Markdown format and stores it\n   *\n   * @param user - User to create profile for\n   * @param signupData - Onboarding signup data\n   * @returns Markdown profile text\n   */\n  async createFitnessProfile(user: UserWithProfile, signupData: SignupData): Promise<string | null> {\n    return this.circuitBreaker.execute<string | null>(async (): Promise<string | null> => {\n      try {\n        // Format signup data for agent processing\n        const formattedData = formatSignupDataForLLM(signupData);\n\n        // Build message from signup data\n        const messageParts: string[] = [];\n\n        if (formattedData.fitnessGoals?.trim()) {\n          messageParts.push(`***Goals***:\\n${formattedData.fitnessGoals.trim()}`);\n        }\n\n        if (formattedData.currentExercise?.trim()) {\n          messageParts.push(`***Current Activity***:\\n${formattedData.currentExercise.trim()}`);\n        }\n\n        if (formattedData.environment?.trim()) {\n          messageParts.push(`***Training Environment***:\\n${formattedData.environment.trim()}`);\n        }\n\n        if (formattedData.injuries?.trim()) {\n          messageParts.push(`***Injuries or Limitations***:\\n${formattedData.injuries.trim()}`);\n        }\n\n        const message = messageParts.join('\\n\\n');\n\n        // Start with empty profile\n        const currentProfile = createEmptyProfile(user);\n\n        // Use Profile Update Agent to build initial profile from signup data\n        const currentDate = formatForAI(new Date(), user.timezone);\n\n        // Helper function for structured profile extraction\n        // System prompt fetched from DB based on agent name\n        const invokeStructuredProfileAgent = async (input: StructuredProfileInput | string): Promise<StructuredProfileOutput> => {\n          const parsedInput: StructuredProfileInput = typeof input === 'string' ? JSON.parse(input) : input;\n          const userPrompt = buildStructuredProfileUserMessage(parsedInput.dossierText, parsedInput.currentDate);\n          const agent = await createAgent({\n            name: PROMPT_IDS.PROFILE_STRUCTURED,\n            schema: StructuredProfileSchema,\n          }, { model: 'gpt-5-nano', temperature: 0.3 });\n\n          const agentResult = await agent.invoke(userPrompt);\n          return { structured: agentResult.response, success: true };\n        };\n\n        // Create profile update agent inline with subAgents for structured extraction\n        // Prompts fetched from DB based on agent name\n        const userPrompt = buildProfileUpdateUserMessage(currentProfile, message, user, currentDate);\n        const agent = await createAgent({\n          name: PROMPT_IDS.PROFILE_FITNESS,\n          schema: ProfileUpdateOutputSchema,\n          subAgents: [{\n            structured: {\n              agent: { name: PROMPT_IDS.PROFILE_STRUCTURED, invoke: invokeStructuredProfileAgent },\n              condition: (agentResult: unknown) => (agentResult as { wasUpdated: boolean }).wasUpdated,\n              transform: (agentResult: unknown) => JSON.stringify({\n                dossierText: (agentResult as { updatedProfile: string }).updatedProfile,\n                currentDate,\n              }),\n            },\n          }],\n        }, { model: 'gpt-5.1' });\n\n        const agentResult = await agent.invoke(userPrompt);\n        const structuredResult = (agentResult as { structured?: StructuredProfileOutput }).structured;\n        const structured = structuredResult?.success ? structuredResult.structured : null;\n\n        const result = {\n          updatedProfile: agentResult.response.updatedProfile,\n          wasUpdated: agentResult.response.wasUpdated,\n          updateSummary: agentResult.response.updateSummary || '',\n          structured,\n        };\n\n        console.log('[FitnessProfileService] Created initial profile:', {\n          wasUpdated: result.wasUpdated,\n          summary: result.updateSummary,\n          hasStructured: result.structured !== null,\n        });\n\n        // Store profile with structured data\n        await this.profileRepository.createProfileWithStructured(\n          user.id,\n          result.updatedProfile,\n          result.structured\n        );\n\n        return result.updatedProfile;\n      } catch (error) {\n        console.error('[FitnessProfileService] Error creating profile:', error);\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Get profile update history for a user\n   *\n   * @param userId - UUID of the user\n   * @param limit - Number of historical profiles to retrieve\n   * @returns Array of profile snapshots with timestamps\n   */\n  async getProfileHistory(userId: string, limit: number = 10) {\n    return await this.profileRepository.getProfileHistory(userId, limit);\n  }\n\n  // ============================================\n  // Structured Profile Methods\n  // ============================================\n\n  /**\n   * Save updated profile with structured data\n   * Creates new row in profiles table for history tracking\n   *\n   * @param userId - UUID of the user\n   * @param profile - Complete profile text (Markdown)\n   * @param structured - Structured profile data (or null)\n   */\n  async saveProfileWithStructured(\n    userId: string,\n    profile: string,\n    structured: StructuredProfile | null\n  ): Promise<void> {\n    try {\n      await this.profileRepository.createProfileWithStructured(userId, profile, structured);\n      console.log(`[FitnessProfileService] Saved profile with structured data for user ${userId}`);\n    } catch (error) {\n      console.error(`[FitnessProfileService] Error saving profile for user ${userId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current structured profile data\n   *\n   * @param userId - UUID of the user\n   * @returns Structured profile data or null if not available\n   */\n  async getCurrentStructuredProfile(userId: string): Promise<StructuredProfile | null> {\n    return await this.profileRepository.getCurrentStructuredProfile(userId);\n  }\n}\n\n// Export singleton instance\nexport const fitnessProfileService = FitnessProfileService.getInstance();\n","import type { UserWithProfile } from '@/server/models/user';\n\n// =============================================================================\n// Profile Update Agent Prompts\n// =============================================================================\n\nexport const PROFILE_UPDATE_SYSTEM_PROMPT = `\nYou are the Profile Manager for GymText. Your goal is to maintain a \"Living Dossier\" of the user's fitness context.\n\n# CRITICAL: TRANSIENT vs PERMANENT\n\n**ONLY record PERMANENT information about the user.** Do NOT record one-time requests or transient modifications.\n\n## How to Distinguish:\n\n**PERMANENT (DO record):**\n- Uses words like: \"I like\", \"I prefer\", \"I always\", \"I want to\", \"from now on\", \"generally\", \"usually\"\n- Expresses ongoing preferences: \"I like to start my week with legs\"\n- States facts about themselves: \"I have a home gym\", \"I hate lunges\"\n- Describes their schedule/availability: \"I can only train mornings\"\n\n**TRANSIENT (DO NOT record):**\n- Uses words like: \"today\", \"this time\", \"right now\", \"can we\", \"let's\", \"switch to\"\n- One-time modification requests: \"switch today to chest\", \"can I do legs instead\"\n- Temporary situations already handled by modifications: \"didn't workout yesterday\"\n- Questions or conversation: \"what's my workout?\", \"thanks\"\n\n## Examples:\n\n| Message | Action |\n|---------|--------|\n| \"I like to start my week with legs\" | RECORD as Scheduling Preference |\n| \"switch today to chest\" | DO NOT record - transient request |\n| \"I prefer barbell over dumbbell\" | RECORD as Exercise Preference |\n| \"can I do upper body instead\" | DO NOT record - one-time swap |\n| \"Add runs on Tuesdays and Thursdays to my plan\" | RECORD as Scheduling Preference |\n| \"I hurt my knee\" | RECORD as Constraint |\n| \"didn't workout yesterday\" | DO NOT record - context for modification |\n| \"I go to Planet Fitness\" | RECORD as Equipment/Location |\n\n**When in doubt, DO NOT record.** Only record information that will be relevant for future workout generation.\n\n# CORE OPERATING RULES\n1. **Fact-Based Recording:** Only record what is explicitly stated as a permanent fact or preference.\n2. **Flexible Structure:** Use bullet points under the broad \"Bucket\" headings below.\n3. **Omit Empty Sections:** Only include sections that have actual content. If there is no information for a section, omit the section header entirely.\n4. **Date Management:**\n   - Reference \"Current Date\" in CONTEXT.\n   - Convert relative dates to absolute (YYYY-MM-DD).\n   - Prune expired [ACTIVE] tags.\n\n# PROFILE SECTIONS (THE BUCKETS)\n\n## 1. # IDENTITY\n- Name, Age, Gender.\n- Experience Level (only if explicitly stated).\n\n## 2. # OBJECTIVES\n- A simple list of user's stated goals.\n- *Examples:* \"- Lose 10lbs\", \"- Bench press 225lbs\".\n\n## 3. # PREFERENCES (PERMANENT ONLY)\nUser's ongoing preferences that inform future workout generation.\n**Only record if the user expresses this as a general preference, NOT a one-time request.**\n\n### Scheduling Preferences\nHow the user prefers to structure their training week GOING FORWARD.\n- \"I like to start my week with legs\" -> Record\n- \"I prefer morning workouts\" -> Record\n- \"Add runs on Tuesdays and Thursdays\" -> Record (permanent schedule change)\n- \"switch today to chest\" -> DO NOT record (one-time)\n- \"can I do legs instead\" -> DO NOT record (one-time)\n\n### Exercise Preferences\nSpecific exercise likes/dislikes that apply to ALL future workouts.\n- \"I prefer barbell over dumbbell\" -> Record\n- \"I hate lunges\" -> Record\n- \"I love deadlifts\" -> Record\n- \"give me something other than squats today\" -> DO NOT record (one-time)\n\n### Workout Style Preferences\nHow the user likes their workouts structured IN GENERAL.\n- \"I like supersets\" -> Record\n- \"I prefer high intensity\" -> Record\n- \"make today's workout shorter\" -> DO NOT record (one-time)\n\n## 4. # LOGISTICS & ENVIRONMENT\n\n### Availability\n- Days per week, time constraints, session duration.\n- *Examples:* \"6 days per week\", \"M/W/F mornings\", \"45 min max\".\n\n### Equipment Access\n**Gym Type:** (e.g., Commercial gym, Home gym, Planet Fitness, Hotel gym)\n**Available Equipment:** List specific equipment mentioned.\n- *Examples:* \"Full rack\", \"Dumbbells up to 50lbs\", \"Cable machine\"\n**Equipment Limitations:** What they DON'T have.\n- *Examples:* \"No barbell\", \"Dumbbells only\"\n\n### Location\n- Where they typically train.\n- *Examples:* \"Home\", \"Equinox\", \"LA Fitness\".\n\n## 5. # SCHEDULE COMMITMENTS (CRITICAL DISTINCTION)\nYou MUST distinguish between a \"Fixed Anchor\" and a \"Habit\".\n- **Fixed Anchors:** Specific classes, sports practice, or external obligations the user MUST attend.\n  - *Example:* \"Tuesday 7pm Yoga Class\" -> **Fixed Anchor**.\n  - *Example:* \"Rugby Practice\" -> **Fixed Anchor**.\n- **Historical Habits:** If a user says \"I currently run 3x a week,\" record this as a **Habit**, NOT a Fixed Anchor.\n  - *Example:* \"Usually runs 3x a week\" -> **Current Habit**.\n\n## 6. # CONSTRAINTS\n- **Permanent:** Injuries or long-term physical limitations.\n- **Temporary:** Travel, sickness, or temporary lack of equipment.\n  - MUST use format: \\`* **[ACTIVE] Description (Effective: YYYY-MM-DD to YYYY-MM-DD)**\\`\n\n## 7. # PROGRESS & RECORDS\n- **Personal Records (PRs):** Max lifts, fastest times, benchmarks.\n  - *Format:* \\`- [YYYY-MM-DD] Exercise: Weight/Time (Notes)\\`\n- **Milestones:** Significant achievements or consistency streaks.\n  - *Format:* \\`- [YYYY-MM-DD] Achievement Description\\`\n\n# OUTPUT FORMAT\nReturn a valid JSON object:\n{\n  \"updatedProfile\": \"string (The complete Markdown document)\",\n  \"wasUpdated\": boolean,\n  \"updateSummary\": \"string (Brief summary of changes made, or empty string if none)\"\n}\n\n**CRITICAL:**\n- The \"updatedProfile\" field must contain ONLY the profile Markdown document itself.\n- Start directly with \"# IDENTITY\"\n- Do NOT include any input context.\n- Set wasUpdated to FALSE if the message only contains transient requests with no permanent profile info.\n`;\n\nexport function buildProfileUpdateUserMessage(\n  currentProfile: string,\n  message: string,\n  user: UserWithProfile,\n  currentDate: string\n): string {\n  return `## CONTEXT\n\n**Current Date**: ${currentDate}\n**User Timezone**: ${user.timezone}\n**User Name**: ${user.name}\n**User Age**: ${user.age || 'Unknown'}\n**User Gender**: ${user.gender || 'Unknown'}\n\n---\n\n## CURRENT PROFILE\n\n${currentProfile || '_No profile exists yet. Create initial profile based on the message._'}\n\n---\n\n## USER'S MESSAGE\n\n${message}\n\n---\n\n## YOUR TASK\n\n1. Review the current profile.\n2. **FIRST: Determine if this message contains PERMANENT profile information.**\n   - If it's only a transient request (like \"switch today to X\", \"can I do Y instead\"), return wasUpdated: false.\n   - Look for keywords: \"today\", \"this time\", \"can we\", \"let's\" = TRANSIENT (don't record)\n   - Look for keywords: \"I like\", \"I prefer\", \"I always\", \"from now on\" = PERMANENT (do record)\n3. Check for [ACTIVE] constraints that have expired and remove them.\n4. Extract any PERMANENT preferences (scheduling, exercise, workout style).\n5. Update EQUIPMENT details if the user mentions gym type, specific equipment, or limitations.\n6. Update other sections based on the message. **Carefully distinguish between \"Fixed Anchors\" (Classes/Sports) and \"Current Habits\" (General routine).**\n7. Return the COMPLETE updated profile (or unchanged if wasUpdated: false).\n`;\n}\n\n// =============================================================================\n// User Fields Agent Prompts\n// =============================================================================\n\n/**\n * System prompt for the User Fields Agent\n *\n * Instructs the agent to extract user preference updates from messages.\n * Focuses on three fields: timezone, preferred send time, and name.\n */\nexport const USER_FIELDS_SYSTEM_PROMPT = `You are a user preference extraction agent. Your job is to detect when a user wants to update their account settings based on their message.\n\nYou extract THREE types of settings changes:\n\n## 1. TIMEZONE CHANGES\nDetect when the user mentions wanting to change their timezone or location.\n\nLook for:\n- Location mentions: \"I'm in California\", \"I moved to New York\", \"I live on the east coast\"\n- Timezone mentions: \"my timezone is PST\", \"I'm on eastern time\", \"change my timezone to central\"\n- City/region mentions: \"I'm in Chicago\", \"Seattle time\", \"mountain time\"\n\nOutput the matching IANA timezone from this list (or null if no change requested):\n\n**Americas:**\n- America/New_York (Eastern US: New York, Boston, Miami, Atlanta, DC)\n- America/Chicago (Central US: Chicago, Dallas, Houston)\n- America/Denver (Mountain US: Denver, Phoenix, Utah)\n- America/Los_Angeles (Pacific US: LA, San Francisco, Seattle, Portland)\n- America/Toronto (Eastern Canada)\n- America/Vancouver (Pacific Canada)\n- America/Mexico_City (Mexico)\n- America/Sao_Paulo (Brazil)\n\n**Europe:**\n- Europe/London (UK)\n- Europe/Paris (France)\n- Europe/Berlin (Germany)\n- Europe/Madrid (Spain)\n- Europe/Rome (Italy)\n- Europe/Amsterdam (Netherlands)\n- Europe/Stockholm (Sweden)\n- Europe/Moscow (Russia)\n\n**Asia Pacific:**\n- Asia/Tokyo (Japan)\n- Asia/Shanghai (China)\n- Asia/Hong_Kong\n- Asia/Singapore\n- Asia/Seoul (Korea)\n- Asia/Mumbai (India)\n- Asia/Dubai (UAE)\n- Australia/Sydney\n- Australia/Melbourne\n- Pacific/Auckland (New Zealand)\n\nMap common references:\n- \"East coast\" / \"Eastern\" / \"EST\" / \"EDT\"  America/New_York\n- \"Central\" / \"CST\" / \"CDT\"  America/Chicago\n- \"Mountain\" / \"MST\" / \"MDT\"  America/Denver\n- \"West coast\" / \"Pacific\" / \"PST\" / \"PDT\"  America/Los_Angeles\n\n## 2. PREFERRED SEND TIME CHANGES\nDetect when the user wants to change when they receive their daily messages.\n\nInterpret natural language intelligently:\n- \"morning\"  8\n- \"early morning\" / \"before work\"  6\n- \"afternoon\"  14\n- \"evening\" / \"after work\" / \"end of day\"  18\n- \"night\" / \"late\"  20\n- \"noon\" / \"lunch\" / \"midday\"  12\n- Explicit times: \"8am\"  8, \"6pm\"  18, \"7:30am\"  7, \"5:00 PM\"  17\n\nOnly extract if the user is clearly asking to CHANGE their send time, not just mentioning a time casually.\nExamples that ARE changes: \"send my workouts in the morning\", \"can I get messages at 6pm instead\", \"change my send time to evening\"\nExamples that are NOT changes: \"I worked out this morning\", \"I'll be busy at 6pm\"\n\n## 3. NAME CHANGES\nDetect when the user wants to be called something different.\n\nLook for:\n- \"call me X\"\n- \"my name is X\"\n- \"I go by X\"\n- \"you can call me X\"\n- \"I prefer X\"\n\nOnly extract the NEW name they want, not their current name being referenced.\n\n## IMPORTANT RULES\n\n1. Only extract fields the user is ACTIVELY REQUESTING to change\n2. Return null for any field not mentioned or not being changed\n3. Set hasUpdates to true only if at least one field is non-null\n4. Be conservative - when in doubt, return null\n5. The updateSummary should briefly describe what was detected (empty string if nothing)\n\n## OUTPUT FORMAT\n\nReturn JSON with:\n- timezone: string | null (IANA timezone from the list above, e.g., \"America/New_York\")\n- preferredSendHour: number | null (0-23)\n- name: string | null\n- hasUpdates: boolean\n- updateSummary: string`;\n\n/**\n * Build the user message for the User Fields Agent\n *\n * Provides context about the user's current settings and the message to analyze.\n */\nexport function buildUserFieldsUserMessage(\n  message: string,\n  user: UserWithProfile,\n  currentDate: string\n): string {\n  return `## CURRENT USER SETTINGS\n- Name: ${user.name || 'Not set'}\n- Timezone: ${user.timezone}\n- Preferred Send Hour: ${user.preferredSendHour} (${formatHourForDisplay(user.preferredSendHour)})\n- Current Date: ${currentDate}\n\n## USER MESSAGE\n${message}\n\n## TASK\nAnalyze the message above. Extract any requested changes to timezone, send time, or name.\nReturn null for fields not being changed.`;\n}\n\n/**\n * Format hour for display (e.g., 8  \"8:00 AM\", 18  \"6:00 PM\")\n */\nfunction formatHourForDisplay(hour: number): string {\n  const period = hour >= 12 ? 'PM' : 'AM';\n  const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;\n  return `${displayHour}:00 ${period}`;\n}\n\n// =============================================================================\n// Structured Profile Agent Prompts\n// =============================================================================\n\n/**\n * System prompt for the Structured Profile Agent\n *\n * Instructs the agent to extract structured data from a Markdown fitness profile.\n */\nexport const STRUCTURED_PROFILE_SYSTEM_PROMPT = `You are a profile parser for a fitness coaching app. Your job is to extract structured data from a Markdown fitness profile document.\n\n# INPUT\nYou will receive a Markdown \"Living Dossier\" profile document. This document contains sections like IDENTITY, OBJECTIVES, PREFERENCES, LOGISTICS & ENVIRONMENT, CONSTRAINTS, etc.\n\n# OUTPUT\nExtract the following fields into structured JSON:\n\n## 1. goals (string[])\nExtract all fitness goals from the OBJECTIVES section and any other goal-related mentions.\n- Examples: \"Lose 10lbs\", \"Bench 225lbs\", \"Run a marathon\", \"Build muscle\"\n- Keep them as concise statements\n\n## 2. experienceLevel (\"beginner\" | \"intermediate\" | \"advanced\" | null)\nLook for explicit mentions of experience level in IDENTITY or elsewhere.\n- Only set this if explicitly stated (e.g., \"Experience Level: Intermediate\")\n- Return null if not explicitly mentioned\n\n## 3. preferences (string[])\nExtract ALL preferences including:\n- **Exercise preferences**: \"Prefers barbell over dumbbell\", \"Hates lunges\", \"Loves deadlifts\"\n- **Scheduling preferences**: \"Likes to start week with legs\", \"Prefers morning workouts\"\n- **Workout style preferences**: \"Likes supersets\", \"Prefers high intensity\"\n- Keep each preference as a clear, concise statement\n\n## 4. injuries (string[])\nExtract PERMANENT physical limitations from the CONSTRAINTS section.\n- Only include injuries marked as permanent or chronic\n- Examples: \"Bad lower back\", \"Chronic shoulder impingement\", \"Knee arthritis\"\n- Do NOT include temporary injuries here\n\n## 5. constraints (array of objects)\nExtract TEMPORARY constraints with optional date bounds.\nEach constraint has:\n- value: Description of the constraint\n- start: ISO date (YYYY-MM-DD) when it started, or null if unknown\n- end: ISO date (YYYY-MM-DD) when it ends, or null if ongoing\n\nLook for [ACTIVE] tags which contain dates in format: [ACTIVE] Description (Effective: YYYY-MM-DD to YYYY-MM-DD)\n- Examples:\n  - \"[ACTIVE] Travel (Effective: 2024-01-15 to 2024-01-22)\"  { value: \"Travel\", start: \"2024-01-15\", end: \"2024-01-22\" }\n  - \"[ACTIVE] Recovering from flu\"  { value: \"Recovering from flu\", start: null, end: null }\n\n## 6. equipmentAccess (string[])\nExtract equipment and gym access information:\n- Gym type: \"Commercial gym\", \"Home gym\", \"Planet Fitness\"\n- Available equipment: \"Full rack\", \"Dumbbells up to 50lbs\", \"Cable machine\"\n- Equipment limitations: \"No barbell\", \"Dumbbells only\"\n- Location: \"Works out at LA Fitness\"\n\n# RULES\n1. Extract ONLY what is explicitly stated in the profile\n2. Return empty arrays [] for sections with no data\n3. For experienceLevel, return null unless explicitly stated\n4. Keep values concise and normalized\n5. Parse [ACTIVE] tags carefully for date extraction\n6. Ignore expired constraints (where end date has passed based on current date)\n\n# EXAMPLES\n\nInput profile:\n\\`\\`\\`\n# IDENTITY\n- Name: John\n- Age: 30\n- Experience Level: Intermediate\n\n# OBJECTIVES\n- Lose 15lbs\n- Bench 225lbs\n\n# PREFERENCES\n### Exercise Preferences\n- I prefer barbell over dumbbell\n- I hate lunges\n\n### Workout Style Preferences\n- I like supersets\n\n# LOGISTICS & ENVIRONMENT\n### Equipment Access\n**Gym Type:** Commercial gym (LA Fitness)\n**Available Equipment:** Full rack, Cable machine, Dumbbells\n\n# CONSTRAINTS\n**Permanent:**\n- Bad lower back\n\n**Temporary:**\n* **[ACTIVE] Shoulder strain (Effective: 2024-01-10 to 2024-02-10)**\n\\`\\`\\`\n\nOutput:\n{\n  \"goals\": [\"Lose 15lbs\", \"Bench 225lbs\"],\n  \"experienceLevel\": \"intermediate\",\n  \"preferences\": [\"Prefers barbell over dumbbell\", \"Hates lunges\", \"Likes supersets\"],\n  \"injuries\": [\"Bad lower back\"],\n  \"constraints\": [{ \"value\": \"Shoulder strain\", \"start\": \"2024-01-10\", \"end\": \"2024-02-10\" }],\n  \"equipmentAccess\": [\"Commercial gym\", \"LA Fitness\", \"Full rack\", \"Cable machine\", \"Dumbbells\"]\n}`;\n\n/**\n * Build the user message for the Structured Profile Agent\n */\nexport function buildStructuredProfileUserMessage(\n  dossierText: string,\n  currentDate: string\n): string {\n  return `## CURRENT DATE\n${currentDate}\n\n## PROFILE TO PARSE\n\n${dossierText || '_No profile content - return empty arrays for all fields_'}\n\n## YOUR TASK\nParse this profile into the structured format. Extract all relevant information following the rules above.`;\n}\n","import { z } from 'zod';\nimport { COMMON_TIMEZONES } from '@/shared/utils/timezone';\n\n/**\n * Agent-Specific Profile Schemas\n *\n * These schemas are for agent output formats only.\n * Domain types (StructuredProfile, etc.) have been moved to @/server/models/profile\n */\n\n// =============================================================================\n// Profile Update Agent Schema\n// =============================================================================\n\n/**\n * Zod schema for Profile Update Agent output\n */\nexport const ProfileUpdateOutputSchema = z.object({\n  updatedProfile: z.string().describe('The complete updated Markdown profile document'),\n  wasUpdated: z.boolean().describe('Whether any changes were made to the profile'),\n  updateSummary: z.string().describe('Brief summary of changes made. Empty string if nothing was updated.'),\n});\n\nexport type ProfileUpdateSchemaOutput = z.infer<typeof ProfileUpdateOutputSchema>;\n\n// =============================================================================\n// User Fields Agent Schema\n// =============================================================================\n\n/**\n * Zod schema for User Fields Agent output\n *\n * Used with LLM structured output to ensure consistent response format.\n * Fields are nullable - agent returns null when not mentioned in message.\n */\nexport const UserFieldsOutputSchema = z.object({\n  /**\n   * IANA timezone from constrained enum\n   * LLM picks from valid options based on user's location/timezone mention\n   * Returns null if no timezone change was requested\n   */\n  timezone: z.enum(COMMON_TIMEZONES).nullable(),\n\n  /**\n   * Inferred preferred send hour (0-23 in 24-hour format)\n   * The agent interprets natural language time expressions:\n   * - \"morning\"  8\n   * - \"early morning\"  6\n   * - \"afternoon\"  14\n   * - \"evening\" / \"after work\"  18\n   * - \"night\"  20\n   * - \"noon\" / \"lunch\"  12\n   * - Explicit times: \"8am\"  8, \"6pm\"  18\n   * Returns null if no send time change was requested\n   */\n  preferredSendHour: z.number().int().min(0).max(23).nullable(),\n\n  /**\n   * New name if user wants to change it\n   * Detected from phrases like \"call me X\", \"my name is X\", \"I go by X\"\n   * Returns null if no name change was requested\n   */\n  name: z.string().nullable(),\n\n  /**\n   * Whether any field updates were detected in the message\n   * True if at least one of timezone, preferredSendHour, or name is non-null\n   */\n  hasUpdates: z.boolean(),\n\n  /**\n   * Brief summary of what was detected\n   * Examples:\n   * - \"User wants to change timezone to east coast\"\n   * - \"User wants messages at 6pm and to be called Mike\"\n   * - \"\" (empty string if no updates)\n   */\n  updateSummary: z.string(),\n});\n\nexport type UserFieldsOutputSchemaType = z.infer<typeof UserFieldsOutputSchema>;\n","/**\n * Client-side timezone utilities\n * These are safe to use in React components\n */\n\n// Common IANA timezones for UI selection\nexport const COMMON_TIMEZONES = [\n  // Americas\n  'America/New_York',\n  'America/Chicago',\n  'America/Denver',\n  'America/Los_Angeles',\n  'America/Toronto',\n  'America/Vancouver',\n  'America/Mexico_City',\n  'America/Sao_Paulo',\n  \n  // Europe\n  'Europe/London',\n  'Europe/Paris',\n  'Europe/Berlin',\n  'Europe/Madrid',\n  'Europe/Rome',\n  'Europe/Amsterdam',\n  'Europe/Stockholm',\n  'Europe/Moscow',\n  \n  // Asia Pacific\n  'Asia/Tokyo',\n  'Asia/Shanghai',\n  'Asia/Hong_Kong',\n  'Asia/Singapore',\n  'Asia/Seoul',\n  'Asia/Mumbai',\n  'Asia/Dubai',\n  'Australia/Sydney',\n  'Australia/Melbourne',\n  'Pacific/Auckland',\n] as const;\n\nexport type CommonTimezone = typeof COMMON_TIMEZONES[number];\n\n// Helper to format timezone for display\nexport function formatTimezoneForDisplay(timezone: string): string {\n  // Convert America/New_York to \"New York (America)\"\n  const parts = timezone.split('/');\n  if (parts.length === 2) {\n    const city = parts[1].replace(/_/g, ' ');\n    return `${city} (${parts[0]})`;\n  }\n  return timezone;\n}\n\n/**\n * Validate if a timezone string is a valid IANA timezone identifier\n * \n * @param timezone - Timezone string to validate\n * @returns true if valid IANA timezone, false otherwise\n */\nexport function isValidTimezone(timezone: string | null | undefined): boolean {\n  if (!timezone || typeof timezone !== 'string') {\n    return false;\n  }\n  \n  // First check if it's in our common timezones list\n  if (COMMON_TIMEZONES.includes(timezone as CommonTimezone)) {\n    return true;\n  }\n  \n  // Then try to validate using Intl.DateTimeFormat\n  try {\n    new Intl.DateTimeFormat('en-US', { timeZone: timezone });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get timezone suggestions based on partial input\n * \n * @param input - Partial timezone or location input\n * @returns Array of suggested timezones with display names\n */\nexport function getTimezoneSuggestions(input: string): Array<{ timezone: string; display: string }> {\n  if (!input || input.length < 2) {\n    // Return most common US timezones\n    return [\n      { timezone: 'America/New_York', display: 'New York (Eastern Time)' },\n      { timezone: 'America/Chicago', display: 'Chicago (Central Time)' },\n      { timezone: 'America/Denver', display: 'Denver (Mountain Time)' },\n      { timezone: 'America/Los_Angeles', display: 'Los Angeles (Pacific Time)' },\n    ];\n  }\n  \n  const cleaned = input.toLowerCase().trim();\n  const suggestions: Array<{ timezone: string; display: string }> = [];\n  \n  // Filter common timezones that match the input\n  for (const timezone of COMMON_TIMEZONES) {\n    const display = formatTimezoneForDisplay(timezone);\n    const city = timezone.split('/')[1]?.replace(/_/g, ' ').toLowerCase() || '';\n    const region = timezone.split('/')[0]?.toLowerCase() || '';\n    \n    if (\n      timezone.toLowerCase().includes(cleaned) ||\n      display.toLowerCase().includes(cleaned) ||\n      city.includes(cleaned) ||\n      region.includes(cleaned)\n    ) {\n      suggestions.push({ timezone, display });\n    }\n  }\n  \n  return suggestions.slice(0, 5); // Limit to top 5 suggestions\n}","import { z } from 'zod';\n\n/**\n * Structured Profile Schemas\n *\n * These schemas define the structured profile format extracted from the\n * Markdown dossier. Used for:\n * - LLM-extracted profile data\n * - Storing structured profile in profiles.structured JSONB column\n * - Type-safe access in repositories\n *\n * Note: This is different from FitnessProfile in user/schemas.ts which\n * is the full detailed user profile model.\n */\n\n/**\n * Constraint with optional temporal bounds\n * Represents temporary constraints like travel, injuries with recovery time, etc.\n *\n * Named StructuredConstraint to differentiate from the more detailed\n * Constraint type in user/schemas.ts\n */\nexport const StructuredConstraintSchema = z.object({\n  value: z.string().describe('Description of the constraint (injury, travel, temporary limitation, etc.)'),\n  start: z.string().nullable().describe('ISO date string when constraint started, or null if permanent/unknown'),\n  end: z.string().nullable().describe('ISO date string when constraint ends, or null if ongoing/permanent'),\n});\n\n/**\n * Experience level enum\n */\nexport const ExperienceLevelSchema = z.enum(['beginner', 'intermediate', 'advanced']);\n\n/**\n * Main structured profile schema\n * A simplified, flat representation of the user's fitness profile\n * extracted from the Markdown dossier\n */\nexport const StructuredProfileSchema = z.object({\n  /** User's fitness goals extracted from profile */\n  goals: z.array(z.string()).describe(\"User's stated fitness goals\"),\n\n  /** User's experience level if stated */\n  experienceLevel: ExperienceLevelSchema.nullable().describe(\"User's experience level (beginner, intermediate, advanced) or null if not stated\"),\n\n  /** Exercise, scheduling, and workout style preferences */\n  preferences: z.array(z.string()).describe('Preferences including exercise likes/dislikes, scheduling preferences, and workout style preferences'),\n\n  /** Permanent physical limitations or injuries */\n  injuries: z.array(z.string()).describe('Permanent physical limitations or chronic injuries'),\n\n  /** Temporary constraints with optional date bounds */\n  constraints: z.array(StructuredConstraintSchema).describe('Temporary constraints with optional start/end dates (travel, temporary injuries, etc.)'),\n\n  /** Available equipment and gym access info */\n  equipmentAccess: z.array(z.string()).describe('Equipment access including gym type, available equipment, and limitations'),\n});\n\n// Inferred types\nexport type StructuredProfile = z.infer<typeof StructuredProfileSchema>;\nexport type StructuredConstraint = z.infer<typeof StructuredConstraintSchema>;\nexport type ExperienceLevel = z.infer<typeof ExperienceLevelSchema>;\n","/**\n * Markdown Profile Utilities\n *\n * Provides utilities for creating Markdown \"Living Dossier\" format profiles.\n */\n\nimport type { User } from '@/server/models/user';\n\n/**\n * Create a default/empty Markdown profile\n * Used when creating a new user with no profile data\n */\nexport function createEmptyProfile(user?: Partial<User>): string {\n  const sections: string[] = [];\n\n  // Minimal IDENTITY section\n  const identityLines: string[] = ['# IDENTITY'];\n  if (user?.name) {\n    identityLines.push(`**Name:** ${user.name}`);\n  }\n  if (user?.age) {\n    identityLines.push(`**Age:** ${user.age}`);\n  }\n  sections.push(identityLines.join('\\n'));\n\n  return sections.join('\\n\\n');\n}\n","import type { SignupData } from '@/server/repositories/onboardingRepository';\n\n/**\n * SignupDataFormatter\n *\n * Service for formatting raw signup form data into LLM-friendly text strings.\n * This logic was moved from the frontend to centralize data formatting on the backend.\n *\n * Responsibilities:\n * - Convert structured form data into natural language descriptions\n * - Provide consistent formatting for LLM consumption\n * - Make it easy to modify formatting without touching frontend\n */\n\n/**\n * Format raw signup data into LLM-friendly text strings\n *\n * Takes structured form data and converts it into natural language\n * descriptions suitable for fitness profile extraction.\n */\nexport function formatSignupDataForLLM(data: SignupData): {\n  fitnessGoals: string;\n  currentExercise: string; // Keeping key name for compatibility, but content is changed\n  environment: string;\n  injuries?: string;\n} {\n  // 1. Fitness Goals\n  const goalsList = `My goals are: ${(data.primaryGoals || [])\n    .map(getGoalDescription)\n    .join(', ')}`;\n  const fitnessGoals = data.goalsElaboration?.trim()\n    ? `${goalsList}. Additional details: ${data.goalsElaboration.trim()}`\n    : goalsList;\n\n  // 2. Desired Availability & Experience\n  const desiredFrequency = data.desiredDaysPerWeek\n    ? getDaysPerWeekDescription(data.desiredDaysPerWeek)\n    : '';\n  const experienceLevel = data.experienceLevel\n    ? `Experience level: ${data.experienceLevel.charAt(0).toUpperCase() + data.experienceLevel.slice(1)}`\n    : '';\n\n  // Frame as desired availability - what the user WANTS, not what they currently do\n  const availabilityText = `***Desired Availability***:\n  ${experienceLevel}. ${desiredFrequency}.\n  Additional Details: ${data.availabilityElaboration?.trim() || 'None provided.'}`;\n\n  const currentExercise = availabilityText; \n\n  // 3. Environment\n  const locationText = data.trainingLocation\n    ? `Training location: ${getLocationDescription(data.trainingLocation)}`\n    : '';\n  const equipmentText =\n    data.equipment && data.equipment.length > 0\n      ? `Available equipment: ${data.equipment.map(e => getEquipmentDescription(e)).join(', ')}`\n      : 'No specific equipment';\n  \n  const environment = `***Environment & Constraints***:\n  ${locationText}. ${equipmentText}`;\n\n  return {\n    fitnessGoals,\n    currentExercise,\n    environment,\n    injuries: data.injuries,\n  };\n}\n// Helper functions for converting enum values to descriptions\n\nfunction getGoalDescription(goal: string): string {\n  const goalMap: Record<string, string> = {\n    strength: 'Build strength and muscle',\n    endurance: 'Improve endurance and stamina',\n    weight_loss: 'Lose weight and improve body composition',\n    general_fitness: 'Improve overall fitness and health',\n  };\n  return goalMap[goal] || goal;\n}\n\nfunction getDaysPerWeekDescription(daysPerWeek: string): string {\n  const daysMap: Record<string, string> = {\n    '3_per_week': 'Wants to train 3 days per week',\n    '4_per_week': 'Wants to train 4 days per week',\n    '5_per_week': 'Wants to train 5 days per week',\n    '6_per_week': 'Wants to train 6 days per week',\n  };\n  return daysMap[daysPerWeek] || daysPerWeek;\n}\n\nfunction getLocationDescription(location: string): string {\n  const locationMap: Record<string, string> = {\n    home: 'Home gym',\n    commercial_gym: 'Commercial gym',\n    bodyweight: 'Bodyweight/minimal equipment',\n  };\n  return locationMap[location] || location;\n}\n\nfunction getEquipmentDescription(equipment: string): string {\n  const equipmentMap: Record<string, string> = {\n    dumbbells: 'Dumbbells',\n    barbell: 'Barbell',\n    resistance_bands: 'Resistance bands',\n    pull_up_bar: 'Pull-up bar',\n    cardio_equipment: 'Cardio equipment',\n    full_gym: 'Full gym access',\n  };\n  return equipmentMap[equipment] || equipment;\n}\n","import { Message } from '@/server/models/conversation';\n\n/**\n * ConversationFlowBuilder\n *\n * Lightweight utility for building natural message flows with context awareness.\n * Used for ephemeral orchestration of multi-message sequences (not persisted to DB).\n *\n * ## Purpose\n *\n * Track messages BEING SENT within a single orchestrated flow to provide context\n * to subsequent agents. This prevents repetitive greetings and creates natural\n * conversational flows.\n *\n * ## When to Use\n *\n * **Use ConversationFlowBuilder when:**\n * - Orchestrating multiple messages in a single flow (e.g., onboarding)\n * - Each message in the sequence needs context from previous messages in THAT flow\n * - You want agents to avoid repeating greetings/names\n *\n * **DO NOT use ConversationFlowBuilder when:**\n * - Responding to a single user message (use ConversationService.getRecentMessages())\n * - Retrieving historical conversation data (use ConversationService)\n * - Persisting messages to database (use ConversationService)\n *\n * ## Architecture Pattern\n *\n * **ConversationService** = Persistent storage (Database)\n * - Store/retrieve messages from DB\n * - Get conversation history\n * - Source of truth for past conversations\n * - Example: `conversationService.getRecentMessages(userId, 10)`\n *\n * **ConversationFlowBuilder** = Ephemeral flow tracking (In-Memory)\n * - Track messages being sent RIGHT NOW in an orchestration\n * - Provide context to agents in the same flow\n * - Formatting utilities for LangChain/prompts\n * - Example: `flow.addMessage(msg); flow.getRecentMessages()`\n *\n * ## Pattern A: Single Message (Use ConversationService)\n *\n * ```typescript\n * // User sends a message, you respond once\n * const previousMessages = await conversationService.getRecentMessages(userId, 10);\n * const response = await chatAgent(user, message, previousMessages);\n * ```\n *\n * ## Pattern B: Multi-Message Flow (Use ConversationFlowBuilder)\n *\n * ```typescript\n * // Orchestrating multiple messages in sequence\n * const flow = new ConversationFlowBuilder();\n *\n * const welcome = await messageService.sendWelcomeMessage(user);\n * flow.addMessage(welcome);\n *\n * const planMessages = await messageService.sendPlanSummary(user, plan, flow.getRecentMessages());\n * flow.addMessage(planMessages);\n *\n * const workout = await dailyMessageService.sendDailyMessage(user, flow.getRecentMessages());\n * // Now agents see previous messages in THIS flow, creating natural conversation\n * ```\n *\n * @example\n * ```typescript\n * // Onboarding flow - multiple messages in sequence\n * const flow = new ConversationFlowBuilder();\n *\n * // 1. Welcome message (first message, no context)\n * const welcome = await messageService.sendWelcomeMessage(user);\n * flow.addMessage(welcome);\n *\n * // 2. Plan summary (has context from welcome, won't repeat greeting)\n * const planMessages = await messageService.sendPlanSummary(\n *   user,\n *   plan,\n *   flow.getRecentMessages()\n * );\n * flow.addMessage(planMessages);\n *\n * // 3. First workout (has context from welcome + plan, natural continuation)\n * await dailyMessageService.sendDailyMessage(user, flow.getRecentMessages());\n * ```\n */\nexport class ConversationFlowBuilder {\n  private messages: Message[] = [];\n\n  /**\n   * Convert Message array to LangChain message format (static utility)\n   *\n   * Use this when you need to convert Message objects to the format expected\n   * by LangChain/OpenAI APIs. This is the single source of truth for message formatting.\n   *\n   * @param messages - Array of Message objects to convert\n   * @returns Array formatted for LangChain with proper roles (user/assistant)\n   *\n   * @example\n   * ```typescript\n   * // In an agent:\n   * const messages = [\n   *   { role: 'system', content: systemPrompt },\n   *   ...ConversationFlowBuilder.toMessageArray(previousMessages),\n   *   { role: 'user', content: currentMessage }\n   * ];\n   * ```\n   */\n  static toMessageArray(messages: Message[]): Array<{ role: string; content: string }> {\n    return messages.map(msg => ({\n      role: msg.direction === 'inbound' ? 'user' : 'assistant',\n      content: msg.content,\n    }));\n  }\n\n  /**\n   * Filter messages to get proper context for chat agents\n   *\n   * When processing a new inbound message, the database may contain:\n   * - Case 1: [..., user_message] - Last is the current inbound message being processed (duplicate)\n   * - Case 2: [..., reply_agent_message] - Last is the reply agent's acknowledgment (needed for context)\n   *\n   * This method intelligently filters to avoid duplicates while preserving reply agent context.\n   *\n   * @param messages - Array of messages from the database\n   * @returns Filtered messages for use as chat context\n   *\n   * @example\n   * ```typescript\n   * // In chatService when processing a new message:\n   * const recentMessages = await conversationService.getRecentMessages(userId, 10);\n   * const contextMessages = ConversationFlowBuilder.filterMessagesForContext(recentMessages);\n   * const response = await chatAgent(user, message, contextMessages);\n   * ```\n   */\n  static filterMessagesForContext(messages: Message[]): Message[] {\n    if (!messages || messages.length === 0) {\n      return [];\n    }\n\n    const lastMessage = messages[messages.length - 1];\n\n    // If last message is inbound (from user), it's the current message being processed\n    // Remove it to avoid duplicate context\n    if (lastMessage.direction === 'inbound') {\n      return messages.slice(0, -1);\n    }\n\n    // If last message is outbound (from assistant/reply agent), keep it\n    // This is important context from the reply agent that the chat agent needs\n    return messages;\n  }\n\n  /**\n   * Add one or more messages to the flow\n   */\n  addMessage(message: Message | Message[]): void {\n    if (Array.isArray(message)) {\n      this.messages.push(...message);\n    } else {\n      this.messages.push(message);\n    }\n  }\n\n  /**\n   * Get recent messages from the flow\n   * @param limit - Maximum number of messages to return (most recent first)\n   * @returns Array of messages\n   */\n  getRecentMessages(limit?: number): Message[] {\n    if (!limit) {\n      return [...this.messages];\n    }\n    return this.messages.slice(-limit);\n  }\n\n  /**\n   * Convert messages to LangChain message format\n   * @param limit - Optional limit on number of messages to convert\n   * @returns Array formatted for LangChain with proper roles\n   */\n  toArray(limit?: number): Array<{ role: string; content: string }> {\n    const messages = this.getRecentMessages(limit);\n    return messages.map(msg => ({\n      role: msg.direction === 'inbound' ? 'user' : 'assistant',\n      content: msg.content,\n    }));\n  }\n\n  /**\n   * Convert messages to formatted string for direct prompt injection\n   * @param limit - Optional limit on number of messages to include\n   * @returns Formatted string of conversation\n   */\n  toString(limit?: number): string {\n    const messages = this.getRecentMessages(limit);\n    return messages\n      .map(msg => {\n        const role = msg.direction === 'inbound' ? 'User' : 'Assistant';\n        return `${role}: ${msg.content}`;\n      })\n      .join('\\n\\n');\n  }\n\n  /**\n   * Get total number of messages in the flow\n   */\n  get length(): number {\n    return this.messages.length;\n  }\n\n  /**\n   * Clear all messages from the flow\n   */\n  clear(): void {\n    this.messages = [];\n  }\n}\n","import { UserService } from '../../user/userService';\nimport { MicrocycleService } from '../../training/microcycleService';\nimport { WorkoutInstanceService } from '../../training/workoutInstanceService';\nimport { workoutAgentService, microcycleAgentService } from '../training';\nimport type { ModifyWorkoutOutput, WorkoutGenerateOutput } from '@/server/services/agents/types/workouts';\nimport { now, getDayOfWeek, DAY_NAMES } from '@/shared/utils/date';\nimport { DateTime } from 'luxon';\nimport { ProgressService } from '../../training/progressService';\nimport { FitnessPlanService } from '../../training/fitnessPlanService';\n\n/**\n * WorkoutModificationService\n *\n * Orchestration service for all workout-related modifications.\n *\n * Responsibilities:\n * - Coordinate weekly pattern modifications across microcycle and workout services\n * - Orchestrate single workout modifications (substitutions and replacements)\n * - Handle AI agent interactions for workout modifications\n * - Ensure proper sequencing and state updates across multiple entities\n *\n * This service follows the orchestration pattern (like OnboardingService, DailyMessageService)\n * and eliminates circular dependencies between MicrocycleService and WorkoutInstanceService.\n */\nexport interface ModifyWorkoutParams {\n  userId: string;\n  workoutDate: Date;\n  changeRequest: string;\n}\n\nexport interface ModifyWorkoutResult {\n  success: boolean;\n  workout?: ModifyWorkoutOutput;\n  modifications?: string;\n  messages: string[];\n  error?: string;\n}\n\nexport interface ModifyWeekParams {\n  userId: string;\n  targetDay: string; // The day being modified (e.g., \"Monday\", \"Tuesday\")\n  changeRequest: string; // What changes to make (e.g., [\"Change chest to back workout\", \"Use dumbbells only\", \"Limit to 45 min\"])\n}\n\nexport interface ModifyWeekResult {\n  success: boolean;\n  workout?: WorkoutGenerateOutput;\n  modifiedDays?: number;\n  modifications?: string;\n  messages: string[];\n  error?: string;\n}\n\nexport class WorkoutModificationService {\n  private static instance: WorkoutModificationService;\n  private userService: UserService;\n  private microcycleService: MicrocycleService;\n  private workoutInstanceService: WorkoutInstanceService;\n  private progressService: ProgressService;\n  private fitnessPlanService: FitnessPlanService;\n  private constructor() {\n    this.userService = UserService.getInstance();\n    this.microcycleService = MicrocycleService.getInstance();\n    this.workoutInstanceService = WorkoutInstanceService.getInstance();\n    this.progressService = ProgressService.getInstance();\n    this.fitnessPlanService = FitnessPlanService.getInstance();\n  }\n\n  public static getInstance(): WorkoutModificationService {\n    if (!WorkoutModificationService.instance) {\n      WorkoutModificationService.instance = new WorkoutModificationService();\n    }\n    return WorkoutModificationService.instance;\n  }\n\n\n  /**\n   * Modify an entire workout based on constraints\n   */\n  public async modifyWorkout(params: ModifyWorkoutParams): Promise<ModifyWorkoutResult> {\n    try {\n      const { userId, workoutDate, changeRequest } = params;\n\n      console.log('Modifying workout', params);\n      // Get user with profile first to determine timezone\n      const user = await this.userService.getUser(userId);\n      if (!user) {\n        return {\n          success: false,\n          messages: [],\n          error: 'User not found',\n        };\n      }\n\n      // Convert the workout date to the user's timezone\n      // If the date came as an ISO string like \"2024-10-08\", it was parsed as UTC midnight\n      // We need to interpret it as a calendar date in the user's timezone instead\n      const dateStr = workoutDate.toISOString().split('T')[0]; // Get YYYY-MM-DD\n      const userLocalDate = DateTime.fromISO(dateStr, { zone: user.timezone }).startOf('day').toJSDate();\n\n      // Get the existing workout\n      const existingWorkout = await this.workoutInstanceService.getWorkoutByUserIdAndDate(userId, userLocalDate);\n\n      if (!existingWorkout) {\n        return {\n          success: false,\n          messages: [],\n          error: 'No workout found for the specified date',\n        };\n      }\n\n\n      // Use the workout agent service to modify the workout\n      const result = await workoutAgentService.modifyWorkout(\n        user,\n        existingWorkout,\n        changeRequest\n      );\n\n      // Extract theme from structured data or use default\n      const theme = result.structure?.title || 'Workout';\n\n      // Store theme in details\n      const details = {\n        theme,  // Keep theme for quick access\n      };\n\n      // Update the workout in the database\n      await this.workoutInstanceService.updateWorkout(existingWorkout.id, {\n        description: result.response.overview,\n        message: result.message,\n        structured: result.structure,\n        details,\n      });\n\n      return {\n        success: true,\n        workout: result,\n        modifications: result.response.modifications,\n        messages: result.message ? [result.message] : [],\n      };\n    } catch (error) {\n      console.error('Error modifying workout:', error);\n      return {\n        success: false,\n        messages: [],\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Modify the weekly pattern for remaining days and regenerate a single workout\n   */\n  public async modifyWeek(params: ModifyWeekParams): Promise<ModifyWeekResult> {\n    try {\n      const { userId, changeRequest } = params;\n      // const reason = params.reason; // Not currently used\n      // targetDay is not currently used - we use the current day of week instead\n\n      // Get user with profile\n      const user = await this.userService.getUser(userId);\n      if (!user) {\n        return {\n          success: false,\n          messages: [],\n          error: 'User not found',\n        };\n      }\n\n      const plan = await this.fitnessPlanService.getCurrentPlan(userId);\n      if (!plan) {\n        return {\n          success: false,\n          messages: [],\n          error: 'No fitness plan found',\n        };\n      }\n      const progress = await this.progressService.getCurrentProgress(plan, user.timezone);\n      if (!progress) {\n        return {\n          success: false,\n          messages: [],\n          error: 'No progress found',\n        };\n      }\n\n      const { microcycle } = progress;\n\n      if (!microcycle) {\n        return {\n          success: false,\n          messages: [],\n          error: 'No microcycle found',\n        };\n      }\n\n      console.log(`[MODIFY_WEEK] Using active microcycle ${microcycle.id} (${new Date(microcycle.startDate).toLocaleDateString()} - ${new Date(microcycle.endDate).toLocaleDateString()})`);\n\n      // Get current date in user's timezone (needed for workout operations below)\n      const today = now(user.timezone).toJSDate();\n\n      // Get today's day of week and index for microcycle days array (0-6, Mon-Sun)\n      const todayDayOfWeek = getDayOfWeek(undefined, user.timezone);\n      const todayDayIndex = DAY_NAMES.indexOf(todayDayOfWeek);\n      const originalTodayOverview = microcycle.days[todayDayIndex] || null;\n\n      // Use the microcycle agent service to modify the pattern\n      const modifyMicrocycleResult = await microcycleAgentService.modifyMicrocycle(\n        user,\n        microcycle,\n        changeRequest\n      );\n\n      console.log(`[MODIFY_WEEK] Microcycle modification result:`, modifyMicrocycleResult);\n      // Check if the microcycle was actually modified\n      if (modifyMicrocycleResult.wasModified) {\n        console.log(`[MODIFY_WEEK] Microcycle was modified - updating database`);\n\n        // Generate specialized \"updated week\" message using remaining days\n        // const updatedMicrocycleMessageAgent = createUpdatedMicrocycleMessageAgent();\n        // const microcycleUpdateMessage = await updatedMicrocycleMessageAgent.invoke({\n        //   modifiedMicrocycle: {\n        //     overview: modifyMicrocycleResult.description,\n        //     isDeload: modifyMicrocycleResult.isDeload || false,\n        //     days: modifyMicrocycleResult.days,\n        //   },\n        //   modifications: modifyMicrocycleResult.modifications || 'Updated weekly pattern based on your request',\n        //   currentWeekday: todayDayOfWeek as DayOfWeek,\n        //   user,\n        // });\n\n        // Update the microcycle with the new pattern (days array from the result)\n        await this.microcycleService.updateMicrocycle(\n          microcycle.id,\n          {\n            days: modifyMicrocycleResult.days,\n            description: modifyMicrocycleResult.description,\n            isDeload: modifyMicrocycleResult.isDeload,\n            structured: modifyMicrocycleResult.structure,\n            // message: microcycleUpdateMessage\n          }\n        );\n\n        // Check if today's overview changed - if so, regenerate today's workout\n        const newTodayOverview = modifyMicrocycleResult.days[todayDayIndex] || null;\n\n        if (originalTodayOverview !== newTodayOverview) {\n          // Get activity type from modified microcycle structure\n          const structuredDay = modifyMicrocycleResult.structure?.days?.[todayDayIndex];\n          const activityType = structuredDay?.activityType as 'TRAINING' | 'ACTIVE_RECOVERY' | 'REST' | undefined;\n\n          // Generate new workout for today using workout agent service\n          const workoutResult = await workoutAgentService.generateWorkout(\n            user,\n            newTodayOverview || '',\n            modifyMicrocycleResult.isDeload || false,\n            activityType\n          );\n\n          // Extract theme from structured data or use default\n          const theme = workoutResult.structure?.title || 'Workout';\n\n          // Store theme in details\n          const details = {\n            theme,\n          };\n\n          // Check if a workout exists for today\n          const existingWorkout = await this.workoutInstanceService.getWorkoutByUserIdAndDate(userId, today);\n\n          if (existingWorkout) {\n            // Update existing workout\n            await this.workoutInstanceService.updateWorkout(existingWorkout.id, {\n              details,\n              description: workoutResult.response,\n              message: workoutResult.message,\n              structured: workoutResult.structure,\n              goal: theme,\n              sessionType: this.mapThemeToSessionType(theme),\n            });\n            console.log(`[MODIFY_WEEK] Updated today's workout`);\n          } else {\n            // Create new workout\n            await this.workoutInstanceService.createWorkout({\n              clientId: userId,\n              microcycleId: microcycle.id,\n              date: today,\n              sessionType: this.mapThemeToSessionType(theme),\n              goal: theme,\n              details,\n              description: workoutResult.response,\n              message: workoutResult.message,\n              structured: workoutResult.structure,\n            });\n            console.log(`[MODIFY_WEEK] Created new workout for today`);\n          }\n\n          // Return with both microcycle and workout messages\n          const messages: string[] = [];\n          if (workoutResult.message) {\n            messages.push(workoutResult.message);\n          }\n\n          return {\n            success: true,\n            workout: workoutResult,\n            messages,\n            modifications: modifyMicrocycleResult.modifications,\n          };\n        }\n\n        // Return success with the modified microcycle message and modifications\n        return {\n          success: true,\n          messages: [],\n          modifications: modifyMicrocycleResult.modifications,\n        };\n      } else {\n        console.log(`[MODIFY_WEEK] No modifications needed - current plan already satisfies the request`);\n\n        // Return success without database update\n        // Empty messages - conversation agent will use modifications field to craft response\n        return {\n          success: true,\n          messages: [],\n          modifications: 'No changes needed - your current plan already matches your request',\n        };\n      }\n    } catch (error) {\n      console.error('Error modifying week:', error);\n      return {\n        success: false,\n        messages: [],\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  /**\n   * Map workout theme to session type for database storage\n   */\n  private mapThemeToSessionType(theme: string): string {\n    const themeLower = theme.toLowerCase();\n    // Valid types: strength, cardio, mobility, recovery, assessment, deload\n    if (themeLower.includes('run') || themeLower.includes('cardio') ||\n        themeLower.includes('hiit') || themeLower.includes('metcon') ||\n        themeLower.includes('conditioning')) return 'cardio';\n    if (themeLower.includes('lift') || themeLower.includes('strength') ||\n        themeLower.includes('upper') || themeLower.includes('lower') ||\n        themeLower.includes('push') || themeLower.includes('pull')) return 'strength';\n    if (themeLower.includes('mobility') || themeLower.includes('flexibility') ||\n        themeLower.includes('stretch')) return 'mobility';\n    if (themeLower.includes('rest') || themeLower.includes('recovery')) return 'recovery';\n    if (themeLower.includes('assessment') || themeLower.includes('test')) return 'assessment';\n    if (themeLower.includes('deload')) return 'deload';\n    // Default to strength for hybrid/unknown workouts\n    return 'strength';\n  }\n}\n\n// Export singleton instance\nexport const workoutModificationService = WorkoutModificationService.getInstance();\n","import { UserService } from '../../user/userService';\nimport { FitnessPlanService } from '../../training/fitnessPlanService';\nimport { fitnessPlanAgentService } from '../training';\nimport { FitnessPlanRepository } from '@/server/repositories/fitnessPlanRepository';\nimport { postgresDb } from '@/server/connections/postgres/postgres';\nimport { now, getDayOfWeek } from '@/shared/utils/date';\nimport { WorkoutModificationService } from './workoutModificationService';\n\n/**\n * PlanModificationService\n *\n * Orchestration service for fitness plan modifications.\n *\n * Responsibilities:\n * - Modify fitness plans based on user change requests\n * - Delegate week/microcycle/workout modifications to WorkoutModificationService\n * - Handle AI agent interactions for plan modifications\n * - Run plan and week modifications in parallel for faster response\n *\n * This service follows the orchestration pattern and coordinates with\n * WorkoutModificationService for microcycle and workout updates.\n */\n\nexport interface ModifyPlanParams {\n  userId: string;\n  changeRequest: string;\n}\n\nexport interface ModifyPlanResult {\n  success: boolean;\n  wasModified?: boolean;\n  modifications?: string;\n  messages: string[];\n  error?: string;\n}\n\nexport class PlanModificationService {\n  private static instance: PlanModificationService;\n  private userService: UserService;\n  private fitnessPlanService: FitnessPlanService;\n  private fitnessPlanRepo: FitnessPlanRepository;\n  private workoutModificationService: WorkoutModificationService;\n\n  private constructor() {\n    this.userService = UserService.getInstance();\n    this.fitnessPlanService = FitnessPlanService.getInstance();\n    this.fitnessPlanRepo = new FitnessPlanRepository(postgresDb);\n    this.workoutModificationService = WorkoutModificationService.getInstance();\n  }\n\n  public static getInstance(): PlanModificationService {\n    if (!PlanModificationService.instance) {\n      PlanModificationService.instance = new PlanModificationService();\n    }\n    return PlanModificationService.instance;\n  }\n\n  /**\n   * Modify a user's fitness plan based on their change request\n   * Modifies (not regenerates) the current microcycle to preserve completed workouts\n   * Runs plan and microcycle modifications in parallel for faster response\n   */\n  public async modifyPlan(params: ModifyPlanParams): Promise<ModifyPlanResult> {\n    try {\n      const { userId, changeRequest } = params;\n\n      console.log('[MODIFY_PLAN] Starting plan modification', { userId, changeRequest });\n\n      // 1. Get user with profile\n      const user = await this.userService.getUser(userId);\n      if (!user) {\n        return {\n          success: false,\n          messages: [],\n          error: 'User not found',\n        };\n      }\n\n      // 2. Get current fitness plan\n      const currentPlan = await this.fitnessPlanService.getCurrentPlan(userId);\n      if (!currentPlan) {\n        return {\n          success: false,\n          messages: [],\n          error: 'No fitness plan found. Please create a plan first.',\n        };\n      }\n\n      // 3. Get today's date for week modification\n      const today = now(user.timezone);\n      const currentDayOfWeek = getDayOfWeek(today.toJSDate(), user.timezone);\n\n      // 4. Run plan and week modifications in PARALLEL\n      // modifyWeek handles microcycle modification AND workout generation\n      console.log('[MODIFY_PLAN] Running plan and week modifications in parallel');\n\n      const [planResult, weekResult] = await Promise.all([\n        // Modify plan using agent service\n        fitnessPlanAgentService.modifyFitnessPlan(user, currentPlan, changeRequest),\n        // Modify week (handles microcycle + workout)\n        this.workoutModificationService.modifyWeek({\n          userId,\n          targetDay: currentDayOfWeek,\n          changeRequest,\n        }),\n      ]);\n\n      // 5. Check if plan was actually modified\n      if (!planResult.wasModified) {\n        console.log('[MODIFY_PLAN] No modifications needed - current plan already satisfies the request');\n        return {\n          success: true,\n          wasModified: false,\n          messages: [],\n        };\n      }\n\n      console.log('[MODIFY_PLAN] Plan was modified - saving new version');\n\n      // 6. Save new plan version\n      const newPlan = await this.fitnessPlanRepo.insertFitnessPlan({\n        clientId: userId,\n        description: planResult.description,\n        structured: planResult.structure,\n        startDate: new Date(),\n      });\n\n      console.log(`[MODIFY_PLAN] Saved new plan version ${newPlan.id}`);\n\n      // Week modification (microcycle + workout) was handled in parallel by modifyWeek\n      if (weekResult.success) {\n        console.log(`[MODIFY_PLAN] Week modification completed successfully`);\n      } else if (weekResult.error) {\n        console.warn(`[MODIFY_PLAN] Week modification had issues: ${weekResult.error}`);\n      }\n\n      return {\n        success: true,\n        wasModified: true,\n        modifications: planResult.modifications,\n        messages: weekResult.messages || [],\n      };\n    } catch (error) {\n      console.error('[MODIFY_PLAN] Error modifying plan:', error);\n      return {\n        success: false,\n        messages: [],\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const planModificationService = PlanModificationService.getInstance();\n","import { z } from 'zod';\nimport { tool, type StructuredToolInterface } from '@langchain/core/tools';\nimport type { ToolResult } from '../types/shared';\nimport { toToolResult } from '../shared/utils';\nimport type { ModifyWorkoutResult, ModifyWeekResult } from './workoutModificationService';\nimport type { ModifyPlanResult } from './planModificationService';\n\n/**\n * Parameters for modifying a workout\n */\nexport interface ModifyWorkoutParams {\n  userId: string;\n  workoutDate: Date;\n  changeRequest: string;\n}\n\n/**\n * Parameters for modifying the weekly pattern\n */\nexport interface ModifyWeekParams {\n  userId: string;\n  targetDay: string;\n  changeRequest: string;\n}\n\n/**\n * Parameters for modifying the fitness plan\n */\nexport interface ModifyPlanParams {\n  userId: string;\n  changeRequest: string;\n}\n\n/**\n * Dependencies for modification tools (DI pattern)\n */\nexport interface ModificationToolDeps {\n  modifyWorkout: (params: ModifyWorkoutParams) => Promise<ModifyWorkoutResult>;\n  modifyWeek: (params: ModifyWeekParams) => Promise<ModifyWeekResult>;\n  modifyPlan: (params: ModifyPlanParams) => Promise<ModifyPlanResult>;\n}\n\n/**\n * Context required for modification tools (pre-filled from chat context)\n */\nexport interface ModificationToolContext {\n  userId: string;\n  message: string;\n  workoutDate: Date;\n  targetDay: string;\n}\n\n// Schema definitions - empty because all params come from context\nconst ModifyWorkoutSchema = z.object({});\nconst ModifyWeekSchema = z.object({});\nconst ModifyPlanSchema = z.object({});\n\n/**\n * Factory function to create modification tools with injected dependencies (DI pattern)\n *\n * This allows services to be injected rather than directly imported,\n * breaking circular dependencies and improving testability.\n *\n * All tools return standardized ToolResult: { response: string, messages?: string[] }\n *\n * @param context - Context from chat (userId, message, workoutDate, targetDay)\n * @param deps - Dependencies including workout and microcycle services\n * @returns Array of LangChain tools configured with the provided services\n */\nexport const createModificationTools = (\n  context: ModificationToolContext,\n  deps: ModificationToolDeps\n): StructuredToolInterface[] => {\n  // Tool 1: Modify Workout\n  const modifyWorkoutTool = tool(\n    async (): Promise<ToolResult> => {\n      const result = await deps.modifyWorkout({\n        userId: context.userId,\n        workoutDate: context.workoutDate,\n        changeRequest: context.message,\n      });\n      return toToolResult(result);\n    },\n    {\n      name: 'modify_workout',\n      description: `Regenerate today's workout keeping the SAME muscle group/focus but with different constraints.\n\nNOTE: All parameters (userId, date, request) are automatically filled from context - no input needed.\n\nUse ONLY when the user explicitly wants to keep the same muscle group/workout type but change HOW they do it:\n- Same muscle group, different equipment (e.g., \"Today is chest - can't make it to my gym, need a chest workout with just dumbbells\")\n- Same focus, different time (e.g., \"Today is leg day but only have 30 min, can you adjust my leg workout?\")\n- Same workout, different constraints (e.g., \"Today's shoulder workout but my shoulder hurts, can you modify it to be gentler?\")\n\nIMPORTANT: User must indicate they want to keep the SAME muscle group/workout type.\nDO NOT use if user requests a DIFFERENT muscle group or doesn't specify - use modify_week instead.\nThis is the LEAST commonly used tool - default to modify_week when uncertain.`,\n      schema: ModifyWorkoutSchema,\n    }\n  );\n\n  // Tool 2: Modify Week\n  const modifyWeekTool = tool(\n    async (): Promise<ToolResult> => {\n      const result = await deps.modifyWeek({\n        userId: context.userId,\n        targetDay: context.targetDay,\n        changeRequest: context.message,\n      });\n      return toToolResult(result);\n    },\n    {\n      name: 'modify_week',\n      description: `Modify the weekly training pattern and regenerate workouts as needed. **This is the PRIMARY and MOST COMMON tool.**\n\nNOTE: All parameters (userId, targetDay, request) are automatically filled from context - no input needed.\n\nUse this for ANY request for a different workout type or muscle group:\n- ANY different muscle group request (e.g., \"can I have a leg workout\", \"chest workout please\", \"give me back instead\")\n- ANY different workout type (e.g., \"I actually want to run today instead\", \"cardio today?\", \"full body workout\")\n- Rearranging the weekly schedule (e.g., \"can we swap my rest days?\", \"move leg day to Friday\")\n- Multi-day constraints (e.g., \"traveling this week with hotel gym\", \"only 30 min per day rest of week\")\n\n**DEFAULT TO THIS TOOL when user requests a workout change.** Even if they don't explicitly say \"instead of\" or mention multiple days.\n\nExamples that should use modify_week:\n- \"Can I do legs today?\" -> YES (different muscle group)\n- \"Chest workout please\" -> YES (potentially different from scheduled)\n- \"I want to run instead\" -> YES (different workout type)\n- \"Can't make it to gym this week\" -> YES (multi-day change)\n\nThis intelligently updates the weekly pattern to maintain training balance and muscle group spacing.`,\n      schema: ModifyWeekSchema,\n    }\n  );\n\n  // Tool 3: Modify Plan\n  const modifyPlanTool = tool(\n    async (): Promise<ToolResult> => {\n      const result = await deps.modifyPlan({\n        userId: context.userId,\n        changeRequest: context.message,\n      });\n      return toToolResult(result);\n    },\n    {\n      name: 'modify_plan',\n      description: `Modify the user's overall fitness plan/program structure.\n\nNOTE: All parameters (userId, changeRequest) are automatically filled from context - no input needed.\n\nUse when the user wants to change their PROGRAM-LEVEL settings:\n- Training frequency changes (e.g., \"change from 5 to 6 days a week\", \"I want to train 4 days instead of 3\")\n- Adding/removing fixed schedule items (e.g., \"add yoga on Monday/Friday mornings\", \"I joined a spinning class on Wednesdays\")\n- Changing their training split (e.g., \"switch to push/pull/legs\", \"I want an upper/lower split\")\n- Adjusting overall goals or focus (e.g., \"more cardio\", \"focus on strength\", \"add more conditioning\")\n- Equipment/facility changes (e.g., \"I joined a new gym with more equipment\", \"I only have dumbbells now\")\n\nDO NOT use for day-to-day or single week changes - use modify_week or modify_workout instead.\nThis tool is for STRUCTURAL/ARCHITECTURAL changes to the entire training program.\n\nExamples that should use modify_plan:\n- \"Can we change to 6 days a week?\" -> YES (frequency change)\n- \"I started yoga on Mondays and Fridays\" -> YES (adding anchors)\n- \"Switch me to a PPL split\" -> YES (program structure)\n- \"I want more cardio overall\" -> YES (program balance)\n\nExamples that should NOT use modify_plan:\n- \"Can I do legs today?\" -> NO (use modify_week)\n- \"Skip today's workout\" -> NO (use modify_week)`,\n      schema: ModifyPlanSchema,\n    }\n  );\n\n  return [\n    modifyWorkoutTool,\n    modifyWeekTool,\n    modifyPlanTool,\n  ];\n};\n","/**\n * Shared utilities for agent orchestration services\n */\n\nimport type { ToolResult } from '../types/shared';\nimport type { ToolType } from '@/server/agents';\n\n/**\n * Result interface that domain services can return\n * This is the minimum shape required for toToolResult to work\n */\nexport interface DomainResult {\n  success: boolean;\n  messages?: string[];\n  error?: string;\n  modifications?: string;\n}\n\n/**\n * Transform a domain-specific result to a standard ToolResult\n *\n * This utility converts service results (like ModifyWorkoutResult, ModifyWeekResult, etc.)\n * into the standard ToolResult format that agents expect.\n *\n * @param result - Domain-specific result with success, messages, error, and modifications\n * @param toolType - Type of tool ('query' or 'action'), defaults to 'action'\n * @returns Standard ToolResult with response and optional messages\n */\nexport function toToolResult<T extends DomainResult>(result: T, toolType: ToolType = 'action'): ToolResult {\n  if (!result.success) {\n    return {\n      toolType,\n      response: `Operation failed: ${result.error || 'Unknown error'}`,\n      messages: result.messages?.length ? result.messages : undefined,\n    };\n  }\n  return {\n    toolType,\n    response: result.modifications\n      ? `Operation completed: ${result.modifications}`\n      : 'Operation completed successfully',\n    messages: result.messages?.length ? result.messages : undefined,\n  };\n}\n","import type { UserWithProfile } from '@/server/models/user';\nimport { formatForAI, getDayOfWeekName } from '@/shared/utils/date';\n\n/**\n * Input for building the modifications user message\n */\nexport interface ModificationsUserMessageInput {\n  user: UserWithProfile;\n  message: string;\n}\n\n/**\n * Static system prompt for the Modifications Agent\n * Handles user requests to change, swap, or modify workouts\n */\nexport const MODIFICATIONS_SYSTEM_PROMPT = `You are a flexible fitness coach for GymText, helping users modify their workouts and training plans.\n\n## YOUR ROLE\n\nYour job is to analyze the user's modification request and select the appropriate tool. All parameters are automatically provided from context - you only need to choose which tool to call. You do not need to generate conversational responses.\n\n## AVAILABLE TOOLS\n\nYou have three tools available (in order of usage frequency):\n\n1. **modify_week** - **PRIMARY TOOL** - Use for TEMPORARY or CURRENT WEEK changes\n   - Use when the user wants a different muscle group or workout type than scheduled **for this week only**\n   - Example: \"Can I have a leg workout today?\" (any leg request, regardless of what's scheduled)\n   - Example: \"I want to run today instead\" (different workout type)\n   - Example: \"Can we do back instead of chest **today**?\" (explicit swap for now)\n   - Example: \"Can we move leg day to Friday **this week**?\" (temporary rearrange)\n   - Example: \"I'm traveling **this week** with limited equipment\" (temporary constraints)\n   - **DEFAULT TO THIS TOOL for one-off changes**\n\n2. **modify_workout** - **LESS COMMON** - Use ONLY when user wants SAME muscle group with different constraints\n   - Use when user explicitly wants to keep the same muscle group but change HOW they do it\n   - Example: \"Today is chest day - can't make it to my gym, need a chest workout with just dumbbells\" (same muscle group, different equipment)\n   - Example: \"Today is leg day but only have 30 min, can you adjust my leg workout?\" (same focus, less time)\n   - **User must indicate they want the SAME muscle group - otherwise use modify_week**\n\n3. **modify_plan** - **LEAST COMMON** - Use for PERMANENT PROGRAM-LEVEL structural changes\n   - Use when the user wants to change their **ongoing** training program structure or schedule\n   - Example: \"Can we update my plan so that I start my weeks with legs instead of push\" (permanent reorder)\n   - Example: \"Can we change to 6 days a week?\" (frequency change)\n   - Example: \"I want to do yoga on Mondays from now on\" (permanent schedule anchor)\n   - Example: \"Switch me to a push/pull/legs split\" (program structure change)\n   - **Use this for ANY request that implies \"from now on\", \"my plan\", or \"always\"**\n\n## TOOL USAGE GUIDELINES\n\n**Priority Bias (use this order):**\n1. **modify_week** - MOST COMMON (temporary/current week changes)\n2. **modify_workout** - LESS COMMON (same muscle group, different constraints)\n3. **modify_plan** - LEAST COMMON (permanent program/structural changes)\n\n**Decision Tree:**\n\n**Step 1:** Is the user asking for a PERMANENT or STRUCTURAL change?\n- \"Update my plan so I start weeks with legs\"  YES  **modify_plan**\n- \"Can we change to 6 days a week?\"  YES  **modify_plan**\n- \"I want to do yoga every Monday\"  YES  **modify_plan**\n- \"Switch me to push/pull/legs\"  YES  **modify_plan**\n- \"I want more cardio overall in my plan\"  YES  **modify_plan**\n- Keywords: \"plan\", \"program\", \"start my weeks\", \"from now on\", \"always\"\n- If YES  **use modify_plan**\n\n**Step 2:** Is the user asking for a DIFFERENT workout type or muscle group (Temporary/One-off)?\n- \"Can I have a leg workout today?\"  YES  **modify_week**\n- \"I want to run instead\"  YES  **modify_week**\n- \"Can we do back instead of chest today?\"  YES  **modify_week**\n- \"Move legs to Friday just for this week\"  YES  **modify_week**\n- If YES  **use modify_week**\n\n**Step 3:** Is the user explicitly asking to keep the SAME muscle group but change constraints?\n- \"Today is chest - can I do a chest workout with just dumbbells?\"  YES  **modify_workout**\n- \"Today is leg day but only have 30 min, can you adjust my leg workout?\"  YES  **modify_workout**\n- If YES  **use modify_workout**\n\n**When uncertain between modifying the week vs plan, look for \"this week\" (modify_week) vs \"my plan/always\" (modify_plan). If ambiguous, default to modify_week.**\n\n## EXAMPLES\n\n**Example 1: Different workout type (modify_week)**\nUser: \"Can I have a leg workout today?\"\nTool: modify_week (different muscle group request)\n\n**Example 2: Permanent Schedule Reorder (modify_plan)**\nUser: \"Can we update my plan so that I start my weeks with legs instead of push\"\nTool: modify_plan (permanent schedule change)\n\n**Example 3: Different workout type (modify_week)**\nUser: \"I actually want to run today instead\"\nTool: modify_week (different workout type)\n\n**Example 4: Same muscle group, different constraints (modify_workout)**\nUser: \"Today is chest day - can't make it to my gym, need a chest workout with just dumbbells\"\nTool: modify_workout (same muscle group, different equipment)\n\n**Example 5: Training frequency change (modify_plan)**\nUser: \"Can we change to 6 days a week?\"\nTool: modify_plan (program-level frequency change)\n\n**Example 6: Temporary Schedule Shift (modify_week)**\nUser: \"Can we move leg day to Friday this week?\"\nTool: modify_week (temporary rearrange)\n`;\n\n/**\n * Build the dynamic user message with context\n *\n * Note: Conversation history is now passed as structured messages in the message array,\n * not concatenated into this prompt.\n */\nexport const buildModificationsUserMessage = (input: ModificationsUserMessageInput): string => {\n  const { user } = input;\n\n  // Get current date/time in user's timezone\n  const now = new Date();\n  const currentDate = formatForAI(now, user.timezone);\n\n  // Get the current day of the week\n  const currentDayOfWeek = getDayOfWeekName(now, user.timezone); // Full weekday name (e.g., \"Monday\")\n\n  return `## CONTEXT\n\n**Todays Date**: ${currentDate}\n**Todays Day of Week**: ${currentDayOfWeek}\n**User Name**: ${user.name}\n\n### User Profile\n${user.profile || 'No profile available'}\n\n---\n\n**Users Message**: ${input.message}\n\n---\n\nSelect the appropriate tool based on the user's request. All parameters (userId, date, targetDay, etc.) are automatically provided from context.`;\n};\n","import { workoutModificationService } from './workoutModificationService';\nimport { planModificationService } from './planModificationService';\nimport { createModificationTools } from './tools';\nimport { createAgent, PROMPT_IDS, type Message as AgentMessage } from '@/server/agents';\nimport { userService } from '../../user/userService';\nimport { workoutInstanceService } from '../../training/workoutInstanceService';\nimport { now, getWeekday, DAY_NAMES } from '@/shared/utils/date';\nimport { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';\nimport { buildModificationsUserMessage } from '../prompts/modifications';\nimport type { ToolResult } from '../types/shared';\nimport type { Message } from '@/server/models/message';\n\n/**\n * ModificationService - Orchestration service for modifications agent\n *\n * Handles workout, schedule, and plan modifications via the modifications agent.\n * Fetches its own context and delegates to specialized sub-services.\n *\n * This is an ORCHESTRATION service - it coordinates agent calls.\n * For specific modification operations, use WorkoutModificationService or PlanModificationService.\n */\nexport class ModificationService {\n  /**\n   * Process a modification request from a user message\n   *\n   * Fetches context via entity services, calls the modifications agent,\n   * and returns a standardized ToolResult.\n   *\n   * @param userId - The user's ID\n   * @param message - The user's modification request message\n   * @param previousMessages - Optional conversation history for context\n   * @returns ToolResult with response summary and optional messages\n   */\n  static async makeModification(userId: string, message: string, previousMessages?: Message[]): Promise<ToolResult> {\n    console.log('[MODIFICATION_SERVICE] Processing modification request:', {\n      userId,\n      message: message.substring(0, 100) + (message.length > 100 ? '...' : ''),\n    });\n\n    try {\n      // Fetch context via entity services\n      const user = await userService.getUser(userId);\n      if (!user) {\n        console.warn('[MODIFICATION_SERVICE] User not found:', userId);\n        return { toolType: 'action', response: 'User not found.' };\n      }\n\n      const today = now(user.timezone).toJSDate();\n      const weekday = getWeekday(today, user.timezone);\n      const targetDay = DAY_NAMES[weekday - 1];\n      const currentWorkout = await workoutInstanceService.getWorkoutByUserIdAndDate(userId, today);\n\n      console.log('[MODIFICATION_SERVICE] Context fetched:', {\n        targetDay,\n        workoutDate: today.toISOString(),\n        hasWorkout: !!currentWorkout,\n        messageCount: previousMessages?.length ?? 0,\n      });\n\n      // Create modification tools with context and service dependencies\n      const tools = createModificationTools(\n        {\n          userId,\n          message,\n          workoutDate: today,\n          targetDay,\n        },\n        {\n          modifyWorkout: workoutModificationService.modifyWorkout.bind(workoutModificationService),\n          modifyWeek: workoutModificationService.modifyWeek.bind(workoutModificationService),\n          modifyPlan: planModificationService.modifyPlan.bind(planModificationService),\n        }\n      );\n\n      // Convert previous messages to Message format for the configurable agent\n      const previousMsgs: AgentMessage[] = ConversationFlowBuilder.toMessageArray(previousMessages || [])\n        .map(m => ({\n          role: m.role as 'user' | 'assistant',\n          content: m.content,\n        }));\n\n      // Build user message\n      const userMessage = buildModificationsUserMessage({ user, message });\n\n      // Create modifications agent - prompts fetched from DB based on agent name\n      const agent = await createAgent({\n        name: PROMPT_IDS.MODIFICATIONS_ROUTER,\n        previousMessages: previousMsgs,\n        tools,\n      }, { model: 'gpt-5-mini' });\n\n      // Invoke the agent - tool execution is handled by createAgent\n      const result = await agent.invoke(userMessage);\n\n      console.log('[MODIFICATION_SERVICE] Agent returned:', {\n        messageCount: result.messages?.length ?? 0,\n        response: result.response.substring(0, 100) + (result.response.length > 100 ? '...' : ''),\n      });\n\n      return {\n        toolType: 'action',\n        response: result.response,\n        messages: result.messages,\n      };\n    } catch (error) {\n      console.error('[MODIFICATION_SERVICE] Error processing modification:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n\n      return {\n        toolType: 'action',\n        response: `Modification failed: ${errorMessage}`,\n      };\n    }\n  }\n}\n\n// Re-export sub-services and types for convenience\nexport { WorkoutModificationService, workoutModificationService } from './workoutModificationService';\nexport type { ModifyWorkoutResult, ModifyWeekResult, ModifyWorkoutParams, ModifyWeekParams } from './workoutModificationService';\nexport { PlanModificationService, planModificationService } from './planModificationService';\nexport type { ModifyPlanResult, ModifyPlanParams } from './planModificationService';\nexport { createModificationTools } from './tools';\nexport type { ModificationToolContext, ModificationToolDeps } from './tools';\n","import { z } from 'zod';\nimport { tool, type StructuredToolInterface } from '@langchain/core/tools';\nimport type { ToolResult } from '../types/shared';\nimport type { Message } from '@/server/models/message';\n\n/**\n * Creates a tool with a required `message` parameter that gets sent immediately\n * before the callback executes. This allows the LLM to provide an acknowledgment\n * message while slow tools are processing.\n *\n * @param name - Tool name\n * @param description - Tool description for the LLM\n * @param callback - The async function to execute\n * @param onSendMessage - Callback to send the immediate message\n * @returns StructuredToolInterface with message handling built-in\n */\nexport function toolWithMessage(\n  name: string,\n  description: string,\n  callback: () => Promise<ToolResult>,\n  onSendMessage: (message: string) => Promise<void>\n): StructuredToolInterface {\n  return tool(\n    async (args: { message: string }): Promise<ToolResult> => {\n      // Send immediate message before execution\n      if (args.message) {\n        try {\n          await onSendMessage(args.message);\n          console.log(`[toolWithMessage] Sent: ${args.message}`);\n        } catch (error) {\n          console.error('[toolWithMessage] Failed to send:', error);\n        }\n      }\n      return callback();\n    },\n    {\n      name,\n      description,\n      schema: z.object({\n        message: z.string().describe(\n          'REQUIRED. Brief acknowledgment to send immediately (1 sentence). Example: \"Got it, switching to legs!\"'\n        ),\n      }),\n    }\n  );\n}\n\n/**\n * Dependencies for chat tools (DI pattern)\n * Pass the methods directly, not the full services\n */\nexport interface ChatToolDeps {\n  makeModification: (userId: string, message: string, previousMessages?: Message[]) => Promise<ToolResult>;\n  getWorkout: (userId: string, timezone: string) => Promise<ToolResult>;\n  updateProfile: (userId: string, message: string, previousMessages?: Message[]) => Promise<ToolResult>;\n}\n\n/**\n * Context required for chat tools\n */\nexport interface ChatToolContext {\n  userId: string;\n  message: string;\n  previousMessages?: Message[];\n  timezone: string;\n}\n\n/**\n * Factory function to create chat tools with injected dependencies\n *\n * Creates tools that the chat agent can use:\n * - update_profile: Record permanent user preferences and profile information (Priority 1)\n * - get_workout: Get or generate today's workout (Priority 2)\n * - make_modification: Make changes to workouts, schedules, or plans (Priority 3)\n *\n * All tools return standardized ToolResult: { response: string, messages?: string[] }\n *\n * @param context - Context from chat (userId, message)\n * @param deps - Dependencies (updateProfile, makeModification, getWorkout methods)\n * @returns Array of LangChain tools\n */\nexport const createChatTools = (\n  context: ChatToolContext,\n  deps: ChatToolDeps,\n  onSendMessage: (message: string) => Promise<void>\n): StructuredToolInterface[] => {\n  // Tool 1: Update Profile (Priority 1 - runs first when called with other tools)\n  const updateProfileTool = tool(\n    async (): Promise<ToolResult> => {\n      return deps.updateProfile(context.userId, context.message, context.previousMessages);\n    },\n    {\n      name: 'update_profile',\n      description: `Record permanent user preferences and profile information.\n\nUse this tool when the user shares PERMANENT information:\n- **Preferences**: \"I like starting with legs\", \"I prefer barbells\", \"I hate lunges\"\n- **Constraints/Injuries**: \"I hurt my knee\", \"I have a bad shoulder\"\n- **Schedule preferences**: \"I prefer runs on Tuesdays\", \"I like morning workouts\"\n- **Goals**: \"I want to lose 10lbs\", \"training for a marathon\"\n- **Equipment/Location**: \"I go to Planet Fitness\", \"I have a home gym\"\n- **Settings**: timezone, send time, or name changes\n\nDO NOT use for one-time requests (\"switch today to legs\") or questions.\n\nIMPORTANT: If user wants BOTH a preference AND a workout change, call BOTH tools.\nExample: \"Add runs to my plan on Tues/Thurs\" -> update_profile (preference) + make_modification (plan change)\n\nAll context is automatically provided - no parameters needed.`,\n      schema: z.object({}),\n    }\n  );\n\n  // Tool 2: Make Modification\n  const makeModificationTool = toolWithMessage(\n    'make_modification',\n    `Make changes to the user's workout or training program.\n\nUse this tool for:\n- **Today's Workout**: Swap exercises, different constraints, different equipment\n- **Weekly Schedule**: Change workout type, muscle group, or training day\n- **Program-Level**: Frequency, training splits, overall focus\n\nThis tool handles WORKOUT CONTENT - not user settings like send time, timezone, or name.\nAll context (user, message, date, etc.) is automatically provided - no parameters needed.`,\n    async (): Promise<ToolResult> => {\n      return deps.makeModification(context.userId, context.message, context.previousMessages);\n    },\n    onSendMessage\n  );\n\n  // Tool 3: Get Workout\n  const getWorkoutTool = tool(\n    async (): Promise<ToolResult> => {\n      return deps.getWorkout(context.userId, context.timezone);\n    },\n    {\n      name: 'get_workout',\n      description: `Get the user's workout for today.\n\nUse this tool when the user asks about their workout for today, such as:\n- \"What's my workout today?\"\n- \"What am I doing today?\"\n- \"Send me my workout\"\n- \"What exercises do I have?\"\n\nThis tool will:\n1. Check if a workout already exists for today\n2. If not, generate one based on their fitness plan\n3. Return the full workout details and send the workout message\n\nIMPORTANT: Only use this for TODAY's workout. Do not use for future dates.\nIf [CONTEXT: WORKOUT] says \"No workout scheduled\", use this tool to generate it.\nAll context is automatically provided - no parameters needed.`,\n      schema: z.object({}),\n    }\n  );\n\n  return [updateProfileTool, makeModificationTool, getWorkoutTool];\n};\n","import Stripe from 'stripe';\nimport { SubscriptionRepository } from '@/server/repositories/subscriptionRepository';\nimport { UserRepository } from '@/server/repositories/userRepository';\nimport { getStripeSecrets } from '@/server/config';\nimport { getStripeConfig, getUrlsConfig } from '@/shared/config';\n\nconst { secretKey } = getStripeSecrets();\nconst stripe = new Stripe(secretKey, {\n  apiVersion: '2023-10-16',\n});\n\nexport interface CancelResult {\n  success: boolean;\n  periodEndDate?: Date;\n  error?: string;\n}\n\nexport interface ReactivateResult {\n  success: boolean;\n  reactivated: boolean;\n  requiresNewSubscription: boolean;\n  checkoutUrl?: string;\n  error?: string;\n}\n\n/**\n * SubscriptionService\n *\n * Manages subscription cancellation and reactivation via SMS commands (STOP/START)\n *\n * Status flow:\n * - 'active' -> user sends STOP -> 'cancel_pending' (messages stop, sub cancels at period end)\n * - 'cancel_pending' -> user sends START -> 'active' (reactivated)\n * - 'cancel_pending' -> period ends -> 'canceled' (handled by Stripe webhook)\n * - 'canceled' -> user sends START -> new checkout session required\n */\nexport class SubscriptionService {\n  private static instance: SubscriptionService;\n  private subscriptionRepo: SubscriptionRepository;\n  private userRepo: UserRepository;\n\n  private constructor() {\n    this.subscriptionRepo = new SubscriptionRepository();\n    this.userRepo = new UserRepository();\n  }\n\n  public static getInstance(): SubscriptionService {\n    if (!SubscriptionService.instance) {\n      SubscriptionService.instance = new SubscriptionService();\n    }\n    return SubscriptionService.instance;\n  }\n\n  /**\n   * Cancel user's subscription via STOP command\n   * Sets cancel_at_period_end in Stripe and status to 'cancel_pending' locally\n   * User keeps access but messages stop immediately\n   */\n  async cancelSubscription(userId: string): Promise<CancelResult> {\n    try {\n      // Get active subscription\n      const subscription = await this.subscriptionRepo.getActiveSubscription(userId);\n      if (!subscription) {\n        // Check if already pending cancellation\n        const subscriptions = await this.subscriptionRepo.findByClientId(userId);\n        const pendingSub = subscriptions.find(s => s.status === 'cancel_pending');\n        if (pendingSub) {\n          return {\n            success: true,\n            periodEndDate: new Date(pendingSub.currentPeriodEnd),\n          };\n        }\n        return { success: false, error: 'No active subscription found' };\n      }\n\n      // Cancel in Stripe (at period end)\n      const stripeSubscription = await stripe.subscriptions.update(\n        subscription.stripeSubscriptionId,\n        { cancel_at_period_end: true }\n      );\n\n      // Update local DB to 'cancel_pending'\n      await this.subscriptionRepo.scheduleCancellation(subscription.stripeSubscriptionId);\n\n      console.log(`[SubscriptionService] Subscription ${subscription.stripeSubscriptionId} scheduled for cancellation`);\n\n      return {\n        success: true,\n        periodEndDate: new Date(stripeSubscription.current_period_end * 1000),\n      };\n    } catch (error) {\n      console.error('[SubscriptionService] Cancel failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Reactivate user's subscription via START command\n   * If cancel_at_period_end was set, clears it and sets status back to 'active'\n   * If fully canceled, returns checkout URL for new subscription\n   */\n  async reactivateSubscription(userId: string): Promise<ReactivateResult> {\n    try {\n      // Get user's most recent subscription\n      const subscriptions = await this.subscriptionRepo.findByClientId(userId);\n      const subscription = subscriptions[0]; // Most recent\n\n      if (!subscription) {\n        // No subscription history - need new subscription\n        return await this.createResubscriptionSession(userId);\n      }\n\n      // If already active, nothing to do\n      if (subscription.status === 'active') {\n        return { success: true, reactivated: false, requiresNewSubscription: false };\n      }\n\n      // If cancel_pending, try to reactivate in Stripe\n      if (subscription.status === 'cancel_pending') {\n        try {\n          // Check Stripe subscription state\n          const stripeSubscription = await stripe.subscriptions.retrieve(\n            subscription.stripeSubscriptionId\n          );\n\n          if (stripeSubscription.status === 'active' && stripeSubscription.cancel_at_period_end) {\n            // Can reactivate by clearing cancel_at_period_end\n            await stripe.subscriptions.update(subscription.stripeSubscriptionId, {\n              cancel_at_period_end: false,\n            });\n\n            // Update local DB\n            await this.subscriptionRepo.reactivate(subscription.stripeSubscriptionId);\n\n            console.log(`[SubscriptionService] Subscription ${subscription.stripeSubscriptionId} reactivated`);\n\n            return { success: true, reactivated: true, requiresNewSubscription: false };\n          }\n        } catch (stripeError) {\n          console.error('[SubscriptionService] Stripe reactivation failed:', stripeError);\n          // Fall through to create new subscription\n        }\n      }\n\n      // If canceled or Stripe reactivation failed, need new subscription\n      if (subscription.status === 'canceled' || subscription.status === 'cancel_pending') {\n        return await this.createResubscriptionSession(userId);\n      }\n\n      // Unknown state\n      return { success: false, reactivated: false, requiresNewSubscription: false, error: 'Unknown subscription state' };\n    } catch (error) {\n      console.error('[SubscriptionService] Reactivate failed:', error);\n      return {\n        success: false,\n        reactivated: false,\n        requiresNewSubscription: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Check if user should receive messages\n   * Only users with status='active' (not 'cancel_pending') receive messages\n   */\n  async shouldReceiveMessages(userId: string): Promise<boolean> {\n    const subscription = await this.subscriptionRepo.findActiveForMessaging(userId);\n    return subscription !== null;\n  }\n\n  /**\n   * Create a new checkout session for resubscription\n   */\n  private async createResubscriptionSession(userId: string): Promise<ReactivateResult> {\n    try {\n      const user = await this.userRepo.findById(userId);\n      if (!user) {\n        return { success: false, reactivated: false, requiresNewSubscription: true, error: 'User not found' };\n      }\n\n      const { publicBaseUrl, baseUrl } = getUrlsConfig();\n      const resolvedBaseUrl = publicBaseUrl || baseUrl;\n      const { priceId } = getStripeConfig();\n\n      const session = await stripe.checkout.sessions.create({\n        customer: user.stripeCustomerId || undefined,\n        mode: 'subscription',\n        line_items: [{ price: priceId, quantity: 1 }],\n        success_url: `${resolvedBaseUrl}/api/checkout/session?session_id={CHECKOUT_SESSION_ID}`,\n        cancel_url: `${resolvedBaseUrl}/`,\n        metadata: { userId },\n        client_reference_id: userId,\n      });\n\n      console.log(`[SubscriptionService] Created resubscription checkout session for user ${userId}`);\n\n      return {\n        success: true,\n        reactivated: false,\n        requiresNewSubscription: true,\n        checkoutUrl: session.url || undefined,\n      };\n    } catch (error) {\n      console.error('[SubscriptionService] Create checkout session failed:', error);\n      return {\n        success: false,\n        reactivated: false,\n        requiresNewSubscription: true,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n}\n\nexport const subscriptionService = SubscriptionService.getInstance();\n","import { FitnessPlanService } from '@/server/services/training/fitnessPlanService';\nimport { MicrocycleService } from '@/server/services/training/microcycleService';\nimport { WorkoutInstanceService } from '@/server/services/training/workoutInstanceService';\nimport { UserService } from '@/server/services/user/userService';\nimport { FitnessProfileService } from '@/server/services/user/fitnessProfileService';\nimport { OnboardingRepository } from '@/server/repositories/onboardingRepository';\n\n// Agent services for full chain operations and sub-agents\nimport {\n  workoutAgentService,\n  microcycleAgentService,\n  fitnessPlanAgentService,\n} from '@/server/services/agents/training';\n\n// Types\nimport type { FitnessPlan } from '@/server/models/fitnessPlan';\nimport type { Microcycle } from '@/server/models/microcycle';\nimport type { WorkoutInstance } from '@/server/models/workout';\nimport type { UserWithProfile } from '@/server/models/user';\n\nexport type ChainOperation = 'full' | 'structured' | 'message';\n\nexport interface ChainRunResult<T> {\n  success: boolean;\n  data: T;\n  executionTimeMs: number;\n  operation: ChainOperation;\n}\n\nexport interface ProfileRegenerationResult {\n  success: boolean;\n  profile: string;\n  executionTimeMs: number;\n}\n\n/**\n * Chain Runner Service\n *\n * Enables running individual chain components (structured, formatted, message)\n * or full chains for fitness plans, microcycles, and workouts.\n *\n * Used for testing and iterative improvement of AI outputs.\n */\nexport class ChainRunnerService {\n  private static instance: ChainRunnerService;\n  private fitnessPlanService: FitnessPlanService;\n  private microcycleService: MicrocycleService;\n  private workoutService: WorkoutInstanceService;\n  private userService: UserService;\n  private fitnessProfileService: FitnessProfileService;\n  private onboardingRepository: OnboardingRepository;\n\n  private constructor() {\n    this.fitnessPlanService = FitnessPlanService.getInstance();\n    this.microcycleService = MicrocycleService.getInstance();\n    this.workoutService = WorkoutInstanceService.getInstance();\n    this.userService = UserService.getInstance();\n    this.fitnessProfileService = FitnessProfileService.getInstance();\n    this.onboardingRepository = new OnboardingRepository();\n  }\n\n  public static getInstance(): ChainRunnerService {\n    if (!ChainRunnerService.instance) {\n      ChainRunnerService.instance = new ChainRunnerService();\n    }\n    return ChainRunnerService.instance;\n  }\n\n  // ============================================\n  // PROFILE OPERATIONS\n  // ============================================\n\n  /**\n   * Regenerate a user's profile from their signup data\n   * Creates a new profile from scratch using the ProfileUpdateAgent\n   */\n  async runProfileRegeneration(userId: string): Promise<ProfileRegenerationResult> {\n    const startTime = Date.now();\n\n    console.log(`[ChainRunner] Regenerating profile for user ${userId}`);\n\n    // Fetch the user with profile\n    const user = await this.userService.getUser(userId);\n    if (!user) {\n      throw new Error(`User not found: ${userId}`);\n    }\n\n    // Fetch signup data\n    const signupData = await this.onboardingRepository.getSignupData(userId);\n    if (!signupData) {\n      throw new Error(`No signup data found for user: ${userId}`);\n    }\n\n    // Regenerate profile from signup data\n    const profile = await this.fitnessProfileService.createFitnessProfile(user, signupData);\n\n    if (!profile) {\n      throw new Error(`Failed to regenerate profile for user: ${userId}`);\n    }\n\n    console.log(`[ChainRunner] Profile regenerated for user ${userId}`);\n\n    return {\n      success: true,\n      profile,\n      executionTimeMs: Date.now() - startTime,\n    };\n  }\n\n  // ============================================\n  // FITNESS PLAN OPERATIONS\n  // ============================================\n\n  /**\n   * Run a chain operation for a fitness plan\n   */\n  async runFitnessPlanChain(\n    planId: string,\n    operation: ChainOperation\n  ): Promise<ChainRunResult<FitnessPlan>> {\n    const startTime = Date.now();\n\n    // Fetch the plan\n    const plan = await this.fitnessPlanService.getPlanById(planId);\n    if (!plan) {\n      throw new Error(`Fitness plan not found: ${planId}`);\n    }\n\n    // Fetch the user with profile\n    const user = await this.userService.getUser(plan.clientId);\n    if (!user) {\n      throw new Error(`User not found: ${plan.clientId}`);\n    }\n\n    let updatedPlan: FitnessPlan;\n\n    switch (operation) {\n      case 'full':\n        updatedPlan = await this.runFullFitnessPlanChain(plan, user);\n        break;\n      case 'structured':\n        updatedPlan = await this.runFitnessPlanStructuredChain(plan);\n        break;\n      case 'message':\n        updatedPlan = await this.runFitnessPlanMessageChain(plan, user);\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      success: true,\n      data: updatedPlan,\n      executionTimeMs: Date.now() - startTime,\n      operation,\n    };\n  }\n\n  private async runFullFitnessPlanChain(\n    plan: FitnessPlan,\n    user: UserWithProfile\n  ): Promise<FitnessPlan> {\n    console.log(`[ChainRunner] Running full fitness plan chain for plan ${plan.id}`);\n\n    // Use fitness plan agent service for full chain\n    const result = await fitnessPlanAgentService.generateFitnessPlan(user);\n\n    const updated = await this.fitnessPlanService.updateFitnessPlan(plan.id!, {\n      description: result.description,\n      message: result.message,\n      structured: result.structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update fitness plan: ${plan.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runFitnessPlanStructuredChain(plan: FitnessPlan): Promise<FitnessPlan> {\n    console.log(`[ChainRunner] Running structured chain for plan ${plan.id}`);\n\n    const agent = await fitnessPlanAgentService.getStructuredAgent();\n\n    // Configurable agents expect JSON string input\n    const inputJson = JSON.stringify({\n      description: plan.description || '',\n    });\n\n    const result = await agent.invoke(inputJson);\n    const structure = result.response;\n\n    const updated = await this.fitnessPlanService.updateFitnessPlan(plan.id!, {\n      structured: structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update fitness plan: ${plan.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runFitnessPlanMessageChain(\n    plan: FitnessPlan,\n    user: UserWithProfile\n  ): Promise<FitnessPlan> {\n    console.log(`[ChainRunner] Running message chain for plan ${plan.id}`);\n\n    const agent = await fitnessPlanAgentService.getMessageAgent();\n\n    // Configurable agents expect JSON string input\n    const inputJson = JSON.stringify({\n      description: plan.description || '',\n      user,\n    });\n\n    const result = await agent.invoke(inputJson);\n    const message = result.response;\n\n    const updated = await this.fitnessPlanService.updateFitnessPlan(plan.id!, {\n      message,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update fitness plan: ${plan.id}`);\n    }\n\n    return updated;\n  }\n\n  // ============================================\n  // MICROCYCLE OPERATIONS\n  // ============================================\n\n  /**\n   * Run a chain operation for a microcycle\n   */\n  async runMicrocycleChain(\n    microcycleId: string,\n    operation: ChainOperation\n  ): Promise<ChainRunResult<Microcycle>> {\n    const startTime = Date.now();\n\n    // Fetch the microcycle\n    const microcycle = await this.microcycleService.getMicrocycleById(microcycleId);\n    if (!microcycle) {\n      throw new Error(`Microcycle not found: ${microcycleId}`);\n    }\n\n    // Fetch the user with profile\n    const user = await this.userService.getUser(microcycle.clientId);\n    if (!user) {\n      throw new Error(`User not found: ${microcycle.clientId}`);\n    }\n\n    // Fetch the user's current plan for full regeneration\n    const plan = await this.fitnessPlanService.getCurrentPlan(microcycle.clientId);\n    if (!plan) {\n      throw new Error(`No active fitness plan found for client: ${microcycle.clientId}`);\n    }\n\n    let updatedMicrocycle: Microcycle;\n\n    switch (operation) {\n      case 'full':\n        updatedMicrocycle = await this.runFullMicrocycleChain(microcycle, plan, user);\n        break;\n      case 'structured':\n        updatedMicrocycle = await this.runMicrocycleStructuredChain(microcycle);\n        break;\n      case 'message':\n        updatedMicrocycle = await this.runMicrocycleMessageChain(microcycle);\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      success: true,\n      data: updatedMicrocycle,\n      executionTimeMs: Date.now() - startTime,\n      operation,\n    };\n  }\n\n  private async runFullMicrocycleChain(\n    microcycle: Microcycle,\n    plan: FitnessPlan,\n    user: UserWithProfile\n  ): Promise<Microcycle> {\n    console.log(`[ChainRunner] Running full microcycle chain for microcycle ${microcycle.id}`);\n\n    // Use microcycle agent service for full chain\n    // Fitness plan is auto-fetched by context service\n    // isDeload is determined by agent from plan's Progression Strategy\n    const result = await microcycleAgentService.generateMicrocycle(\n      user,\n      microcycle.absoluteWeek\n    );\n\n    const updated = await this.microcycleService.updateMicrocycle(microcycle.id, {\n      days: result.days,\n      description: result.description,\n      isDeload: result.isDeload,\n      message: result.message,\n      structured: result.structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update microcycle: ${microcycle.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runMicrocycleStructuredChain(microcycle: Microcycle): Promise<Microcycle> {\n    console.log(`[ChainRunner] Running structured chain for microcycle ${microcycle.id}`);\n\n    const agent = await microcycleAgentService.getStructuredAgent();\n\n    // Configurable agents expect JSON string input\n    const inputJson = JSON.stringify({\n      overview: microcycle.description || '',\n      days: microcycle.days,\n      absoluteWeek: microcycle.absoluteWeek,\n      isDeload: microcycle.isDeload,\n    });\n\n    const result = await agent.invoke(inputJson);\n    const structure = result.response;\n\n    const updated = await this.microcycleService.updateMicrocycle(microcycle.id, {\n      structured: structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update microcycle: ${microcycle.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runMicrocycleMessageChain(microcycle: Microcycle): Promise<Microcycle> {\n    console.log(`[ChainRunner] Running message chain for microcycle ${microcycle.id}`);\n\n    const agent = await microcycleAgentService.getMessageAgent();\n\n    // Configurable agents expect JSON string input\n    const inputJson = JSON.stringify({\n      overview: microcycle.description || '',\n      days: microcycle.days,\n      isDeload: microcycle.isDeload,\n    });\n\n    const result = await agent.invoke(inputJson);\n    const message = result.response;\n\n    const updated = await this.microcycleService.updateMicrocycle(microcycle.id, {\n      message,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update microcycle: ${microcycle.id}`);\n    }\n\n    return updated;\n  }\n\n  // ============================================\n  // WORKOUT OPERATIONS\n  // ============================================\n\n  /**\n   * Run a chain operation for a workout\n   */\n  async runWorkoutChain(\n    workoutId: string,\n    operation: ChainOperation\n  ): Promise<ChainRunResult<WorkoutInstance>> {\n    const startTime = Date.now();\n\n    // Fetch the workout\n    const workout = await this.workoutService.getWorkoutByIdInternal(workoutId);\n    if (!workout) {\n      throw new Error(`Workout not found: ${workoutId}`);\n    }\n\n    // Fetch the user with profile\n    const user = await this.userService.getUser(workout.clientId);\n    if (!user) {\n      throw new Error(`User not found: ${workout.clientId}`);\n    }\n\n    // Fetch microcycle for full regeneration\n    let microcycle: Microcycle | null = null;\n    if (workout.microcycleId) {\n      microcycle = await this.microcycleService.getMicrocycleById(workout.microcycleId);\n    }\n\n    let updatedWorkout: WorkoutInstance;\n\n    switch (operation) {\n      case 'full':\n        updatedWorkout = await this.runFullWorkoutChain(workout, user, microcycle);\n        break;\n      case 'structured':\n        updatedWorkout = await this.runWorkoutStructuredChain(workout);\n        break;\n      case 'message':\n        updatedWorkout = await this.runWorkoutMessageChain(workout);\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      success: true,\n      data: updatedWorkout,\n      executionTimeMs: Date.now() - startTime,\n      operation,\n    };\n  }\n\n  private async runFullWorkoutChain(\n    workout: WorkoutInstance,\n    user: UserWithProfile,\n    microcycle: Microcycle | null\n  ): Promise<WorkoutInstance> {\n    console.log(`[ChainRunner] Running full workout chain for workout ${workout.id}`);\n\n    // Determine day overview and activity type from microcycle\n    let dayOverview = workout.goal || 'General workout';\n    let activityType: 'TRAINING' | 'ACTIVE_RECOVERY' | 'REST' | undefined;\n    if (microcycle) {\n      const workoutDate = new Date(workout.date);\n      const dayOfWeek = workoutDate.getDay(); // 0 = Sunday\n      // Convert to microcycle days array index (0 = Monday)\n      const dayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n      if (microcycle.days[dayIndex]) {\n        dayOverview = microcycle.days[dayIndex];\n      }\n      // Get activity type from structured data\n      const structuredDay = microcycle.structured?.days?.[dayIndex];\n      activityType = structuredDay?.activityType as 'TRAINING' | 'ACTIVE_RECOVERY' | 'REST' | undefined;\n    }\n\n    // Use workout agent service for full chain\n    const result = await workoutAgentService.generateWorkout(\n      user,\n      dayOverview,\n      microcycle?.isDeload || false,\n      activityType\n    );\n\n    const updated = await this.workoutService.updateWorkout(workout.id, {\n      description: result.response,\n      message: result.message,\n      structured: result.structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update workout: ${workout.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runWorkoutStructuredChain(workout: WorkoutInstance): Promise<WorkoutInstance> {\n    console.log(`[ChainRunner] Running structured chain for workout ${workout.id}`);\n\n    if (!workout.description) {\n      throw new Error(`Workout ${workout.id} has no description to parse`);\n    }\n\n    const agent = await workoutAgentService.getStructuredAgent();\n    const result = await agent.invoke(workout.description);\n    const structure = result.response;\n\n    const updated = await this.workoutService.updateWorkout(workout.id, {\n      structured: structure,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update workout: ${workout.id}`);\n    }\n\n    return updated;\n  }\n\n  private async runWorkoutMessageChain(workout: WorkoutInstance): Promise<WorkoutInstance> {\n    console.log(`[ChainRunner] Running message chain for workout ${workout.id}`);\n\n    if (!workout.description) {\n      throw new Error(`Workout ${workout.id} has no description to create message from`);\n    }\n\n    const agent = await workoutAgentService.getMessageAgent();\n    const result = await agent.invoke(workout.description);\n    const message = result.response;\n\n    const updated = await this.workoutService.updateWorkout(workout.id, {\n      message,\n    });\n\n    if (!updated) {\n      throw new Error(`Failed to update workout: ${workout.id}`);\n    }\n\n    return updated;\n  }\n}\n","/**\n * Repository Factory\n *\n * Creates repository instances with a specific database connection.\n * Used for environment switching in the admin app.\n *\n * @example\n * const ctx = await createEnvContext();\n * const repos = createRepositories(ctx.db);\n * const users = await repos.user.findAll();\n */\nimport type { Kysely } from 'kysely';\nimport type { DB } from '../models/_types';\n\n// Import all repository classes\nimport { UserRepository } from './userRepository';\nimport { MessageRepository } from './messageRepository';\nimport { ProfileRepository } from './profileRepository';\nimport { FitnessPlanRepository } from './fitnessPlanRepository';\nimport { WorkoutInstanceRepository } from './workoutInstanceRepository';\nimport { MicrocycleRepository } from './microcycleRepository';\nimport { SubscriptionRepository } from './subscriptionRepository';\nimport { OnboardingRepository } from './onboardingRepository';\nimport { PromptRepository } from './promptRepository';\nimport { DayConfigRepository } from './dayConfigRepository';\nimport { MessageQueueRepository } from './messageQueueRepository';\nimport { ShortLinkRepository } from './shortLinkRepository';\nimport { ReferralRepository } from './referralRepository';\nimport { PageVisitRepository } from './pageVisitRepository';\nimport { AdminActivityLogRepository } from './adminActivityLogRepository';\nimport { UploadedImageRepository } from './uploadedImageRepository';\nimport { ProfileUpdateRepository } from './profileUpdateRepository';\nimport { UserAuthRepository } from './userAuthRepository';\n\n/**\n * Container for all repository instances\n */\nexport interface RepositoryContainer {\n  user: UserRepository;\n  message: MessageRepository;\n  profile: ProfileRepository;\n  fitnessPlan: FitnessPlanRepository;\n  workoutInstance: WorkoutInstanceRepository;\n  microcycle: MicrocycleRepository;\n  subscription: SubscriptionRepository;\n  onboarding: OnboardingRepository;\n  prompt: PromptRepository;\n  dayConfig: DayConfigRepository;\n  messageQueue: MessageQueueRepository;\n  shortLink: ShortLinkRepository;\n  referral: ReferralRepository;\n  pageVisit: PageVisitRepository;\n  adminActivityLog: AdminActivityLogRepository;\n  uploadedImage: UploadedImageRepository;\n  profileUpdate: ProfileUpdateRepository;\n  userAuth: UserAuthRepository;\n}\n\n// Cache repositories by database connection string (approximated by object identity)\nconst repoCache = new WeakMap<Kysely<DB>, RepositoryContainer>();\n\n/**\n * Create all repository instances with a specific database connection\n *\n * @param db - Kysely database instance\n * @returns Container with all repository instances\n */\nexport function createRepositories(db: Kysely<DB>): RepositoryContainer {\n  // Return cached instance if available\n  const cached = repoCache.get(db);\n  if (cached) {\n    return cached;\n  }\n\n  // Create new repository instances\n  const repos: RepositoryContainer = {\n    user: new UserRepository(db),\n    message: new MessageRepository(db),\n    profile: new ProfileRepository(db),\n    fitnessPlan: new FitnessPlanRepository(db),\n    workoutInstance: new WorkoutInstanceRepository(db),\n    microcycle: new MicrocycleRepository(db),\n    subscription: new SubscriptionRepository(db),\n    onboarding: new OnboardingRepository(db),\n    prompt: new PromptRepository(db),\n    dayConfig: new DayConfigRepository(db),\n    messageQueue: new MessageQueueRepository(db),\n    shortLink: new ShortLinkRepository(db),\n    referral: new ReferralRepository(db),\n    pageVisit: new PageVisitRepository(db),\n    adminActivityLog: new AdminActivityLogRepository(db),\n    uploadedImage: new UploadedImageRepository(db),\n    profileUpdate: new ProfileUpdateRepository(db),\n    userAuth: new UserAuthRepository(db),\n  };\n\n  // Cache for reuse\n  repoCache.set(db, repos);\n  return repos;\n}\n\n/**\n * Get repositories for a specific environment context\n * Convenience function that extracts db from context\n */\nexport function getRepositories(ctx: { db: Kysely<DB> }): RepositoryContainer {\n  return createRepositories(ctx.db);\n}\n","import { BaseRepository } from '@/server/repositories/baseRepository';\n\nexport class AdminActivityLogRepository extends BaseRepository {\n  async log(params: {\n    actorClientId?: string | null;\n    targetClientId: string;\n    action: string;\n    payload?: unknown;\n    result: 'success' | 'failure';\n    errorMessage?: string | null;\n  }): Promise<void> {\n    await this.db\n      .insertInto('adminActivityLogs')\n      .values({\n        actorClientId: params.actorClientId ?? null,\n        targetClientId: params.targetClientId,\n        action: params.action,\n        // JSON stringify/parse to ensure it's JSON-serializable for jsonb\n        payload: JSON.parse(JSON.stringify(params.payload ?? {})),\n        result: params.result,\n        errorMessage: params.errorMessage ?? null,\n      })\n      .execute();\n  }\n\n  async listForClient(targetClientId: string, options: { page?: number; pageSize?: number } = {}) {\n    const page = options.page ?? 1;\n    const pageSize = options.pageSize ?? 20;\n\n    const rows = await this.db\n      .selectFrom('adminActivityLogs')\n      .selectAll()\n      .where('targetClientId', '=', targetClientId)\n      .orderBy('createdAt', 'desc')\n      .offset((page - 1) * pageSize)\n      .limit(pageSize)\n      .execute();\n\n    return rows;\n  }\n}\n","import { BaseRepository } from './baseRepository';\nimport type { ProfileUpdates } from '../models/_types';\nimport type { Selectable, Insertable } from 'kysely';\n\nexport type ProfileUpdate = Selectable<ProfileUpdates>;\nexport type NewProfileUpdate = Insertable<ProfileUpdates>;\n\nexport class ProfileUpdateRepository extends BaseRepository {\n  /**\n   * Create a new profile update audit record\n   */\n  async create(update: NewProfileUpdate): Promise<ProfileUpdate> {\n    const result = await this.db\n      .insertInto('profileUpdates')\n      .values(update)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return result;\n  }\n\n  /**\n   * Get profile updates for a specific client\n   */\n  async getClientUpdates(\n    clientId: string,\n    limit: number = 10\n  ): Promise<ProfileUpdate[]> {\n    const updates = await this.db\n      .selectFrom('profileUpdates')\n      .where('clientId', '=', clientId)\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .selectAll()\n      .execute();\n\n    return updates;\n  }\n\n  /**\n   * Get recent profile updates across all users (for monitoring)\n   */\n  async getRecentUpdates(limit: number = 50): Promise<ProfileUpdate[]> {\n    const updates = await this.db\n      .selectFrom('profileUpdates')\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .selectAll()\n      .execute();\n\n    return updates;\n  }\n\n  /**\n   * Get profile updates by source (e.g., 'chat', 'admin', 'api')\n   */\n  async getUpdatesBySource(\n    source: string,\n    limit: number = 50\n  ): Promise<ProfileUpdate[]> {\n    const updates = await this.db\n      .selectFrom('profileUpdates')\n      .where('source', '=', source)\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .selectAll()\n      .execute();\n\n    return updates;\n  }\n\n  /**\n   * Count profile updates for a client\n   */\n  async countClientUpdates(clientId: string): Promise<number> {\n    const result = await this.db\n      .selectFrom('profileUpdates')\n      .where('clientId', '=', clientId)\n      .select(this.db.fn.count('id').as('count'))\n      .executeTakeFirstOrThrow();\n\n    return Number(result.count);\n  }\n}","/**\n * Service Factory\n *\n * Creates service instances with a specific environment context.\n * Used for environment switching in the admin app.\n *\n * This factory provides context-aware versions of services that need\n * database, Twilio, or Stripe access. Services created through this\n * factory will use the context's connections instead of the default singletons.\n *\n * @example\n * const ctx = await createEnvContext();\n * const services = getServices(ctx);\n * await services.user.getUser(userId);\n */\nimport type { EnvironmentContext } from '../context/types';\nimport { createRepositories, type RepositoryContainer } from '../repositories/factory';\n\n// Import service classes that we'll wrap\nimport { UserService } from './user/userService';\nimport { FitnessProfileService } from './user/fitnessProfileService';\nimport { MessageService } from './messaging/messageService';\nimport { DailyMessageService } from './orchestration/dailyMessageService';\nimport { WeeklyMessageService } from './orchestration/weeklyMessageService';\nimport { DayConfigService } from './calendar/dayConfigService';\n\n/**\n * Service container with context-aware service instances\n *\n * Note: Some services are stateless static classes (ChatService, ProfileService, etc.)\n * and don't need context wrapping - they get context passed to their methods.\n *\n * This container provides the main data-access services that benefit from\n * being instantiated with a specific database connection.\n */\nexport interface ServiceContainer {\n  /** Repository container for direct data access */\n  repos: RepositoryContainer;\n\n  /** Context for accessing connections directly */\n  ctx: EnvironmentContext;\n\n  // Service instances would go here if we fully refactored them\n  // For now, use repos directly or call service static methods with ctx\n}\n\n// Cache service containers by environment mode\nconst containerCache = new Map<string, ServiceContainer>();\n\n/**\n * Get a service container for the given environment context\n *\n * @param ctx - Environment context with db, twilio, stripe connections\n * @returns Service container with context-aware services\n */\nexport function getServices(ctx: EnvironmentContext): ServiceContainer {\n  const cacheKey = ctx.mode;\n\n  // Return cached container if available\n  const cached = containerCache.get(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  // Create new service container\n  const container: ServiceContainer = {\n    repos: createRepositories(ctx.db),\n    ctx,\n  };\n\n  // Cache for reuse\n  containerCache.set(cacheKey, container);\n  return container;\n}\n\n/**\n * Clear the service container cache (for testing)\n */\nexport function clearServiceCache(): void {\n  containerCache.clear();\n}\n\n/**\n * Helper type for services that accept context\n */\nexport type WithContext<T> = T & { ctx: EnvironmentContext };\n"],"names":[],"mappings":"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"}