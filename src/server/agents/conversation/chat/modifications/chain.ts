import { RunnableLambda } from '@langchain/core/runnables';
import { initializeModel } from '@/server/agents/base';
import { type ModificationsAgentInput, type ModificationsResponse } from '../types';
import { MODIFICATIONS_SYSTEM_PROMPT, buildModificationsUserMessage } from './prompts';
import type { ModifyWorkoutResult, ModifyWeekResult, ModifyPlanResult } from '@/server/services';
import { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';
import { createModificationTools, type ModifyWorkoutParams, type ModifyWeekParams, type ModifyPlanParams } from './tools';

/**
 * Dependencies for Modifications Agent (DI)
 * Includes service functions for modification operations
 */
export interface ModificationsAgentDeps {
  modifyWorkout: (params: ModifyWorkoutParams) => Promise<ModifyWorkoutResult>;
  modifyWeek: (params: ModifyWeekParams) => Promise<ModifyWeekResult>;
  modifyPlan: (params: ModifyPlanParams) => Promise<ModifyPlanResult>;
}

// Union type for all modification results
type ModificationResult = ModifyWorkoutResult | ModifyWeekResult | ModifyPlanResult;

/**
 * Modifications agent factory - handles workout change and modification requests using tools
 *
 * Executes modification tools and returns the message generated by the workout agent.
 * This avoids redundant LLM calls since workout agents already generate contextual messages.
 *
 * @param deps - Dependencies including modification service functions (DI pattern)
 * @returns Runnable that processes modification requests
 */
export const createModificationsAgent = (deps: ModificationsAgentDeps): RunnableLambda<ModificationsAgentInput, ModificationsResponse> => {
  return RunnableLambda.from(async (input: ModificationsAgentInput) => {
    const agentName = 'MODIFICATIONS';

    console.log(`[${agentName}] Processing message:`, {
      message: input.message.substring(0, 100) + (input.message.length > 100 ? '...' : ''),
      targetDay: input.targetDay,
      workoutDate: input.workoutDate,
    });

    // Create modification tools with context from input
    const tools = createModificationTools(
      {
        userId: input.user.id,
        message: input.message,
        workoutDate: input.workoutDate,
        targetDay: input.targetDay,
      },
      {
        modifyWorkout: deps.modifyWorkout,
        modifyWeek: deps.modifyWeek,
        modifyPlan: deps.modifyPlan,
      }
    );

    // Initialize model with tools
    const model = initializeModel(undefined, { model: 'gpt-5-nano' }, { tools });

    const systemMessage = {
      role: 'system',
      content: MODIFICATIONS_SYSTEM_PROMPT,
    };

    const userMessage = {
      role: 'user',
      content: buildModificationsUserMessage(input),
    };

    const messages: any[] = [ // eslint-disable-line @typescript-eslint/no-explicit-any
      systemMessage,
      ...ConversationFlowBuilder.toMessageArray(input.previousMessages || []),
      userMessage,
    ];

    // Call model with tools
    const response = await model.invoke(messages);

    // Track tool result
    let toolResult: ModificationResult | null = null;

    // Check if there are tool calls
    if (response.tool_calls && response.tool_calls.length > 0) {
      console.log(`[${agentName}] Tool calls:`, response.tool_calls.map((tc: any) => tc.name)); // eslint-disable-line @typescript-eslint/no-explicit-any

      // Execute each tool call (typically only one for modifications)
      for (const toolCall of response.tool_calls) {
        const tool = tools.find(t => t.name === toolCall.name);

        if (!tool) {
          console.error(`[${agentName}] Tool not found: ${toolCall.name}`);
          continue;
        }

        try {
          console.log(`[${agentName}] Executing tool: ${toolCall.name}`, toolCall.args);
          // Use type assertion to handle union type from modificationTools array
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const result = await (tool as any).invoke(toolCall.args) as ModificationResult;
          console.log(`[${agentName}] Tool result:`, result);

          toolResult = result;
        } catch (error) {
          console.error(`[${agentName}] Error executing tool ${toolCall.name}:`, error);
          // Create an error result
          toolResult = {
            success: false,
            messages: [],
            error: error instanceof Error ? error.message : 'Unknown error',
          };
        }
      }
    }

    // Extract messages from tool result
    if (!toolResult) {
      return {
        messages: ['I tried to make that change but encountered an issue. Please try again or let me know if you need help!'],
      };
    }

    // If tool execution succeeded
    if (toolResult.success) {
      // Use messages from tool result (agents already generated user-friendly messages)
      if (toolResult.messages && toolResult.messages.length > 0) {
        console.log(`[${agentName}] Using ${toolResult.messages.length} message(s) from tool:`, {
          messages: toolResult.messages.map(m => m.substring(0, 100) + (m.length > 100 ? '...' : '')),
        });

        return {
          messages: toolResult.messages,
        };
      }

      // No messages generated - use default success message
      console.log(`[${agentName}] No messages from tool, using default success message`);
      return {
        messages: ['Done! Your changes have been applied.'],
      };
    }

    // If failed, provide error message
    const errorMessage = toolResult.error
      ? `I tried to make that change but ran into an issue: ${toolResult.error}`
      : 'I tried to make that change but encountered an issue. Please try again or let me know if you need help!';

    return {
      messages: [errorMessage],
    };
  });
};