import { RunnableLambda } from '@langchain/core/runnables';
import { initializeModel } from '@/server/agents/base';
import { type ModificationsAgentInput, type ModificationsResponse, type ModificationsAgentConfig } from './types';
import { MODIFICATIONS_SYSTEM_PROMPT, buildModificationsUserMessage } from './prompts';
import type { ModifyWorkoutResult, ModifyWeekResult, ModifyPlanResult } from '@/server/services';
import { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';

// Re-export types for convenience
export type { ModificationsAgentConfig };

// Union type for all modification results
type ModificationResult = ModifyWorkoutResult | ModifyWeekResult | ModifyPlanResult;

/**
 * Modifications agent factory - handles workout change and modification requests using tools
 *
 * Executes modification tools and returns the message generated by the workout agent.
 * This avoids redundant LLM calls since workout agents already generate contextual messages.
 *
 * Tools are provided by the calling service (ModificationService) via config, not created here.
 * This keeps the agent focused on orchestration, not tool creation.
 *
 * @param config - Agent configuration including tools
 * @returns Runnable that processes modification requests
 */
export const createModificationsAgent = ({ tools, ...config }: ModificationsAgentConfig): RunnableLambda<ModificationsAgentInput, ModificationsResponse> => {
  // Initialize model with tools from config
  const model = initializeModel(undefined, config.model ? { model: config.model } : { model: 'gpt-5-nano' }, { tools });

  return RunnableLambda.from(async (input: ModificationsAgentInput) => {
    const agentName = 'MODIFICATIONS';

    console.log(`[${agentName}] Processing message:`, {
      message: input.message.substring(0, 100) + (input.message.length > 100 ? '...' : ''),
      targetDay: input.targetDay,
      workoutDate: input.workoutDate,
    });

    const systemMessage = {
      role: 'system',
      content: MODIFICATIONS_SYSTEM_PROMPT,
    };

    const userMessage = {
      role: 'user',
      content: buildModificationsUserMessage(input),
    };

    const messages: any[] = [ // eslint-disable-line @typescript-eslint/no-explicit-any
      systemMessage,
      ...ConversationFlowBuilder.toMessageArray(input.previousMessages || []),
      userMessage,
    ];

    // Call model with tools
    const response = await model.invoke(messages);

    // Track tool result
    let toolResult: ModificationResult | null = null;

    // Check if there are tool calls
    if (response.tool_calls && response.tool_calls.length > 0) {
      console.log(`[${agentName}] Tool calls:`, response.tool_calls.map((tc: any) => tc.name)); // eslint-disable-line @typescript-eslint/no-explicit-any

      // Execute each tool call (typically only one for modifications)
      for (const toolCall of response.tool_calls) {
        const tool = tools.find(t => t.name === toolCall.name);

        if (!tool) {
          console.error(`[${agentName}] Tool not found: ${toolCall.name}`);
          continue;
        }

        try {
          console.log(`[${agentName}] Executing tool: ${toolCall.name}`, toolCall.args);
          // Use type assertion to handle union type from modificationTools array
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const result = await (tool as any).invoke(toolCall.args) as ModificationResult;
          console.log(`[${agentName}] Tool result:`, result);

          toolResult = result;
        } catch (error) {
          console.error(`[${agentName}] Error executing tool ${toolCall.name}:`, error);
          // Create an error result
          toolResult = {
            success: false,
            messages: [],
            error: error instanceof Error ? error.message : 'Unknown error',
          };
        }
      }
    }

    // Extract messages from tool result
    if (!toolResult) {
      return {
        messages: ['I tried to make that change but encountered an issue. Please try again or let me know if you need help!'],
        response: 'Modification failed: No tool was executed',
      };
    }

    // If tool execution succeeded
    if (toolResult.success) {
      // Use messages from tool result (agents already generated user-friendly messages)
      if (toolResult.messages && toolResult.messages.length > 0) {
        console.log(`[${agentName}] Using ${toolResult.messages.length} message(s) from tool:`, {
          messages: toolResult.messages.map(m => m.substring(0, 100) + (m.length > 100 ? '...' : '')),
        });

        return {
          messages: toolResult.messages,
          response: 'Modification applied successfully',
        };
      }

      // No messages generated - use default success message
      console.log(`[${agentName}] No messages from tool, using default success message`);
      return {
        messages: ['Done! Your changes have been applied.'],
        response: 'Modification applied successfully',
      };
    }

    // If failed, provide error message
    const errorMessage = toolResult.error
      ? `I tried to make that change but ran into an issue: ${toolResult.error}`
      : 'I tried to make that change but encountered an issue. Please try again or let me know if you need help!';

    return {
      messages: [errorMessage],
      response: `Modification failed: ${toolResult.error || 'Unknown error'}`,
    };
  });
};
