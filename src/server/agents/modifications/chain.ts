import { RunnableLambda } from '@langchain/core/runnables';
import { initializeModel, type ToolResult } from '@/server/agents/base';
import { type ModificationsAgentInput, type ModificationsResponse, type ModificationsAgentConfig } from './types';
import { MODIFICATIONS_SYSTEM_PROMPT, buildModificationsUserMessage } from './prompts';
import { ConversationFlowBuilder } from '@/server/services/flows/conversationFlowBuilder';

// Re-export types for convenience
export type { ModificationsAgentConfig };

/**
 * Modifications agent factory - handles workout change and modification requests using tools
 *
 * Executes modification tools and returns the message generated by the workout agent.
 * This avoids redundant LLM calls since workout agents already generate contextual messages.
 *
 * Tools are provided by the calling service (ModificationService) via config, not created here.
 * This keeps the agent focused on orchestration, not tool creation.
 *
 * @param config - Agent configuration including tools
 * @returns Runnable that processes modification requests
 */
export const createModificationsAgent = ({ tools, ...config }: ModificationsAgentConfig): RunnableLambda<ModificationsAgentInput, ModificationsResponse> => {
  // Initialize model with tools from config
  const model = initializeModel(undefined, config, { tools });

  return RunnableLambda.from(async (input: ModificationsAgentInput) => {
    const agentName = 'MODIFICATIONS';

    console.log(`[${agentName}] Processing message:`, {
      message: input.message.substring(0, 100) + (input.message.length > 100 ? '...' : ''),
      targetDay: input.targetDay,
      workoutDate: input.workoutDate,
    });

    const systemMessage = {
      role: 'system',
      content: MODIFICATIONS_SYSTEM_PROMPT,
    };

    const userMessage = {
      role: 'user',
      content: buildModificationsUserMessage(input),
    };

    const messages: any[] = [ // eslint-disable-line @typescript-eslint/no-explicit-any
      systemMessage,
      ...ConversationFlowBuilder.toMessageArray(input.previousMessages || []),
      userMessage,
    ];

    // Call model with tools
    const response = await model.invoke(messages);

    // Track tool result - tools return ToolResult { response, messages? }
    let toolResult: ToolResult | null = null;

    // Check if there are tool calls
    if (response.tool_calls && response.tool_calls.length > 0) {
      console.log(`[${agentName}] Tool calls:`, response.tool_calls.map((tc: any) => tc.name)); // eslint-disable-line @typescript-eslint/no-explicit-any

      // Execute each tool call (typically only one for modifications)
      for (const toolCall of response.tool_calls) {
        const tool = tools.find(t => t.name === toolCall.name);

        if (!tool) {
          console.error(`[${agentName}] Tool not found: ${toolCall.name}`);
          continue;
        }

        try {
          console.log(`[${agentName}] Executing tool: ${toolCall.name}`, toolCall.args);
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const result = await (tool as any).invoke(toolCall.args) as ToolResult;
          console.log(`[${agentName}] Tool result:`, result);

          toolResult = result;
        } catch (error) {
          console.error(`[${agentName}] Error executing tool ${toolCall.name}:`, error);
          // Create an error result
          toolResult = {
            toolType: 'action',
            response: `Operation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            messages: undefined,
          };
        }
      }
    }

    // No tool was executed
    if (!toolResult) {
      return {
        toolType: 'action',
        messages: [],
        response: 'Modification failed: No tool was executed',
      };
    }

    // Check for failure (response starts with "Operation failed:")
    const isFailure = toolResult.response.startsWith('Operation failed:');

    if (isFailure) {
      console.log(`[${agentName}] Tool failed:`, toolResult.response);
      return {
        toolType: 'action',
        messages: [],  // No SMS for failures - conversation agent will craft error message
        response: toolResult.response,
      };
    }

    // Success - pass through response and messages directly
    // response = modification summary for conversation agent to use in acknowledgment
    // messages = only workout SMS (if any)
    console.log(`[${agentName}] Tool succeeded:`, {
      response: toolResult.response,
      messageCount: toolResult.messages?.length ?? 0,
    });

    return {
      toolType: 'action',
      messages: toolResult.messages || [],  // Only workout SMS if present, empty otherwise
      response: toolResult.response,  // Modification summary for conversation agent
    };
  });
};
